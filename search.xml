<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>算法挑战赛题解</title>
    <url>/ZestfulYK-blog/2025/11/20/2/</url>
    <content><![CDATA[算法挑战赛第二期题解题目
二进制小数的乘积~HC哥哥说这个很困！难！

Description



HC哥哥今天又突发奇想，它依然定义一个数字为二进制小数，如果它是一个正整数，并且其十进制表示中的所有数字都是0或1。例如，110 是一个二进制小数，而 102 和 787 不是。
现在HC哥哥给定你一个数 n，你被要求判断是否可能将 n 表示为一些（不一定是不同的）二进制小数的乘积。


Input


第一行包含一个整数 t（1≤t≤5⋅10^4）— 测试用例的数量。
每个测试用例的唯一一行包含一个整数 n（1≤n≤10^5）。


Output


对于每个测试用例，如果 n 可以表示为一些二进制小数的乘积，则输出 “YES”（不带引号），否则输出 “NO”（不带引号）。


题目解释 （翻译成人话）

计算把01串强制转换为整数，再相乘得到的数就是合法的数字，其余都是不合法的。那么直接打表就行了，总共1e5个数，打表还是很容易实现的
接下来我们来学习一下该怎么打表
打表
定义 : 计算出所有情况，然后直接判断。

比如问你100以内的数是否是质数，你肯定能直接回答，因为你已经把100以内的质数全部背下来了。这其实就是打表的一种体现，你提前计算前100内的数是否是质数，然后直接调用答案。
但是我们的计算机实际上并不知道一个问题的所有解，那么你自己提前算好告诉它不就彳亍了吗。
这时我们需要两个重要程序：打表程序和判断程序。
打表程序
用于计算所有情况的答案，不用关心时间复杂度，反正是提前计算

比如计算素数集，你直接暴力就好了，不会欧拉筛又有什么关系呢？
判断程序
用于直接获得答案的程序，时间复杂度O(n),n为数据规模，每次查询的时间复杂度为O(1)。

接下来就该思考怎么写一个无脑的程序来计算这些情况了
做法
首先先写一个无脑程序生成所有01组合的数vector&lt;ll&gt; ans;int main()&#123;    for(int i=1;i&lt;=100000;i++)&#123;        ll x=i,cnt=0,w=0;        while(x)&#123;            if(x%10&lt;2) cnt++;            w++;            x/=10;        &#125;        if(cnt==w) ans.push_back(i);    &#125;    for(auto &amp;i:ans)        cout&lt;&lt;i&lt;&lt;&quot;,&quot;;&#125;



此处是对每一位进行判断，如果01的个数和位数一样，那么就是一个合法的数字


得到如下结果：
1,10,11,100,101,110,111,1000,1001,1010,1011,1100,1101,1110,1111,10000,10001,10010,10011,10100,10101,10110,10111,11000,11001,11010,11011,11100,11101,11110,11111,100000

把以上结果复制进下一段生成代码，然后再计算所有合法的数字
ll number[1010]=&#123;0,1,10,11,100,101,110,111,1000,1001,    1010,1011,1100,1101,1110,1111,10000,10001    ,10010,10011,10100,10101,10110,10111,11000    ,11001,11010,11011,11100,11101,11110,11111,100000&#125;;set&lt;ll&gt; s;ll dfs(ll n)&#123;    s.insert(n);    for(int i=2;i&lt;=32;i++)&#123;        if(n*number[i]&lt;=100000)           dfs(n*number[i]);    &#125;    return 0;&#125;signed main()&#123;    dfs(1);    ll cnt=0;    for(auto &amp;i:s)&#123;        cout&lt;&lt;i&lt;&lt;&quot;,&quot;;        cnt++;    &#125;    cout&lt;&lt;endl&lt;&lt;cnt&lt;&lt;endl;    return 0;&#125;



此处使用了dfs(Deep First Search)，文末会有详细介绍


得到如下结果：
1,10,11,100,101,110,111,121,1000,1001,1010,1011,1100,1101,1110,1111,1210,1221,1331,10000,10001,10010,10011,10100,10101,10110,10111,10201,11000,11001,11010,11011,11100,11101,11110,11111,11121,11211,12100,12111,12210,12221,12321,13310,13431,14641,100000

最后再是无脑的判断程序：
vector&lt;string&gt; ans;ll a[1010]=&#123;0,1,10,11,100,101,110,111,121,1000,1001,1010,1011,1100,1101,    1110,1111,1210,1221,1331,10000,10001,10010,10011,10100,10101,10110,    10111,10201,11000,11001,11010,11011,11100,11101,11110,11111,11121,    11211,12100,12111,12210,12221,12321,13310,13431,14641,100000&#125;;void solve()&#123;    ll x; cin&gt;&gt;x;    for(int i=1;i&lt;=47;i++)&#123;        if(a[i]==x)&#123;            ans.push_back(&quot;YES&quot;);            return;        &#125;    &#125;    ans.push_back(&quot;NO&quot;);&#125;int main()&#123;    ll T; cin&gt;&gt;T;    while(T--) solve();    for(auto &amp;i:ans)        cout&lt;&lt;i&lt;&lt;endl;&#125;


不是我说，这种做法在打表题目是真轮椅吧，时间复杂度完全没影响，计算出来总共就47个数字，简单版甚至20个都没到，非常适合不会搜索的蒻蒟(比如我)学习和理解。
下面是对dfs(Deep First Search)算法的详细介绍：
什么是dfs？dfs是深度优先搜索的英文缩写，以深度为优先来进行计算

比如，要计算走n级楼梯（每次一到两级台阶）有几种走法，就可以使用dfs，假设第一次先走一步，依次遍历，如果能刚好走到n则方法数加1，如果超过了n则返回到上一步，回头找下一个方法。

在本题的应用

那么在这题，我们已经提前计算了所有合法的数字，我们每次乘上可能的数字，看看是否依旧合法，之后在超过1e5时返回，相当于楼梯数为1e5，每次可以走number[1….n]步，但是每一个小于n的位置都合法，并存储答案。
如果想进一步了解dfs，可以访问OIwiki进行学习！
那么本期的题解就到此结束了，感谢阅读！如果想交流算法题，也可以添加我的qq哦(717056060)
关注ZestfulYK，谢谢喵！]]></content>
  </entry>
  <entry>
    <title>算法挑战赛题解（11.2）</title>
    <url>/ZestfulYK-blog/2025/11/03/1/</url>
    <content><![CDATA[算法挑战赛题解（11.2）简单版本：题目大意：给定n个区间，判断这些区间能划分出几种不同的区域

性质不同的数字

题目分析：实际上是在讨论每个点被哪几个区包含，在样例中，数据是这样的，我们来分析一下这两个样例
Sample Input 1 11 6Sample Output 12Sample Input 240 124 136 1312 13Sample Output 26
样例分析：样例1: 0 1 1 1 1 1 1 0 0 … …  所以是两种区间样例2: 1   2  3   4   5   6   7  8    9   10  11  12  13 … …       1   1  1   1   1   1   1  1   1    1   1   1                  2   2   2   2  2   2    2   2   2   2                          3   3  3   3    3   3   3   3                                                  4   4       |&lt; ------ &gt;|&lt; ---- &gt;|&lt; ----------------- &gt;|&lt;-&gt;|&lt;-&gt;|&lt;--
所以是6种区间这样,我们就弄明白了题目在讲什么,接下来就可以思考怎么实现了
题目思路：实际上有些人会以为我们需要统计的是这个点有几个区间经过，但是这是错误的，在样例二就能发现这一点。（这也是我第一次的想法，测试样例二时发现的T_T）
我们需要思考怎么表示这一个点有哪些区间经过，而且每一个区间是互不相同的。这里我们考虑类似状态压缩的思想。
什么是状态压缩呢？简而言之就是用一个数来代替这个状态。比如说，我们用1表示未进行，2表示正在进行，3表示完成，那么一个含有4个任务的任务表可以是这样的：
            1321
（1，4任务未进行，2任务完成，3正在进行）
我们使用了一个4位数表示了这一状态，这样就实现了状态压缩，我们没有用数组存储状态，而是一个数，这样我们在判断两个状态是否相同时就可以直接判断数字是否相同了，节约了时间和判断的复杂度。
那么怎么把这个思想用在这一题呢？我们考虑给每个区间一个标号k，每个区间内的点加上2^k，这样就保证了每一个状态不会重复。但是这么写居然WA了！这是因为数据范围n是[0,300]也就是会有2^300，远大于long long的最大范围(2^64-1)这显然是不行的。
实际上这个算法已经十分接近答案了,但我们还需要改进这个算法。接着我们想到一个类似的方法，哈希表(hash)。
其实哈希表和刚才的思路差不多，不过加入了一些更高级的算法来防止数据溢出。
那么什么是hash呢？实际上也是创建一种对应关系，使得在查询时能快速访问这种情况对应的值。就像上面的例子一样，我们通过我们规定的方式把任务状态和整数一一对应。
怎么创建hash表呢？首先，找到一个质数作为进制数P，通常取131或者13331，模数mod通常取1e9+7或1e9+9，对应关系就是对应的P进制数%mod例如这个点上经过了134这三个集合，那么我们就把134转化为131进制，即1  131^2+3  131+4，在实际操作时，就是每一个集合的下标k作为对应的位数，则每一个点的表示可以是这样的：

这样我们就计算出了每一个点的唯一标识，含有相同标识的才能算是同一个点。（这里选择质数是为了防止哈希碰撞，即不同状态的得到了相同的标记；选择mod是防止溢出）
最后只要统计一下标识的个数就行了（可以用set实现）代码实现：对于简单版本，暴力完全够用了。
#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define endl &#x27;\n&#x27;const ll P=131,mod=1e9+7;int main()&#123;    ll n,z=1,a[1010]; cin&gt;&gt;n;    for(int i=0;i&lt;=1000;i++) a[i]=0;    while(n--)&#123;        ll l,r; cin&gt;&gt;l&gt;&gt;r;        for(int i=l;i&lt;=r;i++)&#123;            a[i]=(a[i]+z)%mod;        &#125;        z=(z*P)%mod;    &#125;    set&lt;ll&gt; q;    for(int i=0;i&lt;=1000;i++)&#123;        q.insert(a[i]);    &#125;    cout&lt;&lt;q.size()&lt;&lt;endl;&#125;
所以这样我们就解决了简单版本。
复杂版本：那么对于数据量大的复杂版本呢？
这里我们依然采用hash，但是由于数据量大，为了防止冲突，我们给每一个区间都分配一个随机hash值，在计算时只考虑起点和终点，在进入起点时加入标记，离开时移除标记。这时我们就想到了具有可逆性质的异或，我们只要给对应的起终点打上相同标记就行了，最后还是用set统计产生的不同标记数
参考代码：#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ULL unsigned long long#define endl &#x27;\n&#x27;int main()&#123;    ll n; cin&gt;&gt;n;    vector&lt;pair&lt;ll,int&gt;&gt; box;    for (int i=0;i&lt;n;i++)&#123;        ll l,r; cin&gt;&gt;l&gt;&gt;r;        box.push_back(&#123;l,i&#125;);        box.push_back(&#123;r+1,i&#125;);    &#125;    sort(box.begin(),box.end());    vector&lt;unsigned long long&gt; h(n);    mt19937_64 rng(time(0));    for(int i=0;i&lt;n;i++)&#123;        h[i]=rng();    &#125;    set&lt;ULL&gt; s; s.insert(0);    ULL cur=0;ll last=-2e9;    for(auto&amp; i:box)&#123;        ll pos=i.first,idx=i.second;        if(pos&gt;last&amp;&amp;last!=-2e9) s.insert(cur);        cur^=h[idx];        last=pos;    &#125;    s.insert(cur);    cout&lt;&lt;s.size()&lt;&lt;endl;&#125;
```yaml                     感谢观看！关注ZestfulYK喵，谢谢喵！
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>mod</title>
    <url>/ZestfulYK-blog/2025/11/25/mod/</url>
    <content><![CDATA[模运算（Mod）性质总结定义对于任意实数 $( x, y )$，有：
x \mod y = x - y \left\lfloor \frac{x}{y} \right\rfloor, \quad y \neq 0模运算（在一些场合使用符号 % 表示）是一个二元运算。$( x \mod y )$ 的值范围如下：

当 $( y &gt; 0 )$ 时：$( 0 \leq x \mod y &lt; y )$
当 $( y &lt; 0 )$ 时：$( 0 \geq x \mod y &gt; y )$
当 $( y = 0 )$ 时：为避免除以零，定义 $( x \mod 0 = x )$

基本运算规则模运算与基本四则运算类似（除法除外）：

加法规则：$((a + b) \mod p = (a \mod p + b \mod p) \mod p)$
减法规则：$((a - b) \mod p = (a \mod p - b \mod p) \mod p)$
乘法规则：$((a \times b) \mod p = (a \mod p \times b \mod p) \mod p)$
幂运算规则：$(a^b \mod p = ((a \mod p)^b) \mod p)$
求和规则：由第1个公式可推导出 $(\left(\sum{i=1}^{n} x_i\right) \mod p = \left(\sum{i=1}^{n} (x_i \mod p)\right) \mod p)$

运算律A. 结合律((a + b) \mod p + c) \mod p = (a + (b + c) \mod p) \mod p((a \times b) \mod p \times c) \mod p = (a \times (b \times c) \mod p) \mod pB. 交换律(a + b) \mod p = (b + a) \mod p(a \times b) \mod p = (b \times a) \mod pC. 分配律(a + b) \mod p = (a \mod p + b \mod p) \mod p((a + b) \mod p \times c) \mod p = ((a \times c) \mod p + (b \times c) \mod p) \mod p补充性质同余性质
反身性：$(a \equiv a \pmod{m})$
对称性：如果 $(a \equiv b \pmod{m})$，则 $(b \equiv a \pmod{m})$
传递性：如果 $(a \equiv b \pmod{m})$ 且 $(b \equiv c \pmod{m})$，则 $(a \equiv c \pmod{m})$

模运算与除法模运算与除法不直接兼容，但有以下性质：

如果 $(ac \equiv bc \pmod{m})$ 且 $(\gcd(c, m) = 1)$，则 $(a \equiv b \pmod{m})$

模逆元：如果 $(\gcd(a, m) = 1)$，则存在整数 $(b)$ 使得 $(ab \equiv 1 \pmod{m})$，称 $(b)$ 为 $(a)$ 模 $(m)$ 的逆元

核心性质：在模运算里除以一个数等于乘以这个数的逆元，即：c/a≡c×a^{−1} (modm)其中 $a^{-1}$ 是 $a$ 在模 $m$ 下的逆元。


重要前提：模逆元存在的充分必要条件是 $\gcd(a, m) = 1$（即 $a$ 与 $m$ 互质）。如果 $a$ 与 $m$ 不互质，则 $a$ 在模 $m$ 下没有逆元，除法操作无法进行。

计算模逆元的方法常用的计算模逆元的方法是扩展欧几里得算法，它不仅能求最大公约数，还能找到满足贝祖等式的系数。
示例代码;#include &lt;iostream&gt;using namespace std;// 扩展欧几里得算法求逆元long long mod_inverse(long long a, long long m) &#123;    long long m0 = m;    long long y = 0, x = 1;        if (m == 1) return 0;        while (a &gt; 1) &#123;        long long q = a / m;        long long t = m;                m = a % m;        a = t;        t = y;                y = x - q * y;        x = t;    &#125;        if (x &lt; 0) x += m0;        return (a == 1) ? x : -1; // 如果逆元不存在返回 -1&#125;// 使用示例int main() &#123;    long long a = 3, m = 7;    long long inv = mod_inverse(a, m);    if (inv != -1) &#123;        cout &lt;&lt; a &lt;&lt; &quot; 在模 &quot; &lt;&lt; m &lt;&lt; &quot; 下的逆元是: &quot; &lt;&lt; inv &lt;&lt; endl;    &#125; else &#123;        cout &lt;&lt; a &lt;&lt; &quot; 在模 &quot; &lt;&lt; m &lt;&lt; &quot; 下没有逆元&quot; &lt;&lt; endl;    &#125;    return 0;&#125;
应用示例计算 $6 / 3 \pmod{7}$：

先求 $3^{-1} \pmod{7}$：$3 \times 5 = 15 \equiv 1 \pmod{7}$，所以逆元为 5

$6 / 3 \equiv 6 \times 5 = 30 \equiv 2 \pmod{7}$

验证：$2 \times 3 = 6 \equiv 6 \pmod{7}$ ✓


这个性质在密码学、组合数学和算法竞赛中都有广泛应用。
模运算的周期性质
对于任意整数 $(k)$，有 $(a \mod m = (a + km) \mod m)$
模运算的结果具有周期性，周期为模数 $(m)$

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown使用教程</title>
    <url>/ZestfulYK-blog/2025/10/20/markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[标题的使用# 一级标题## 二级标题### 三级标题
字体粗体 斜体 删除线 行内代码
小标题的使用
无序列表项
另一个项目


有序列表
第二项

链接，图片[链接文字](https://example.com)![图片描述](https://example.com/image.jpg)
引用块&gt; 这是一个引用块&gt; 可以多行使用

这是一个引用块可以多行使用

表格| 姓名 | 年龄 | 城市 ||------|------|------|| 张三 | 25   | 北京 || 李四 | 30   | 上海 |




姓名
年龄
城市




张三
25
北京


李四
30
上海




]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列函数的应用</title>
    <url>/ZestfulYK-blog/2025/10/22/%E5%85%A8%E6%8E%92%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[全排列函数什么是全排列？简单来说就是排列组合的所有情况，并按照字典顺序输出例如：123全排列的结果为
123132213231312321
而实际上全排列需要在代码中用复杂的深度搜索来写这实在是太复杂了！！！于是我就发现了全排列函数这个东西^__^现在我们就来学习一下这个高级函数————next_permutation
全排列函数#include &lt;iostream&gt;  #include &lt;algorithm&gt;  using namespace std;  int main()  &#123;      int num[3]=&#123;1,2,3&#125;;      do      &#123;          cout&lt;&lt;num[0]&lt;&lt;&quot; &quot;&lt;&lt;num[1]&lt;&lt;&quot; &quot;&lt;&lt;num[2]&lt;&lt;endl;    &#125;while(next_permutation(num,num+3));      return 0;  &#125;

全排列函数详细定义对于next_permutation函数，其函数原型为：
include   bool next_permutation(iterator start,iterator end)


当当前序列不存在下一个排列时，函数返回false，否则返回true

全排列函数的特性

next_permutation(num,num+n)函数是对数组num中的前n个元素进行全排列，同时并改变num数组的值。
另外，需要强调的是，next_permutation()在使用前需要对欲排列数组按升序排序，否则只能找出该序列之后的全排列数。比如，如果数组num初始化为2,3,1，那么输出就变为了：231312321
全排列函数的应用题目链接
题目要求我们按要求完成5*5数独，且只要填ABC，可以有空格子一种方法是遍历每一个格子，逐个填入，时间复杂度(4^25)，显然不行不过我的朋友使用了大量剪枝，最后还是过了%%%大佬 qinye_leaf
代码链接
但是我们刚学了全排列函数，就不能使用一下吗？你别说，还真能使用！我们只要先填写每一行，然后就只用40^5就能计算完了因为可以加上一个判断，看看每一行是否符合标准(也算剪枝吧)
vector&lt;string&gt; eachrow(int row) &#123;    vector&lt;string&gt; result;    string h=string(n-3,&#x27;.&#x27;)+&quot;ABC&quot;;    do&#123; for(int i=0;i&lt;n;i++)&#123;        if(h[i]!=&#x27;.&#x27;)&#123;            if(h[i]==r[row]) result.push_back(h);            break;        &#125;    &#125;    &#125;while(next_permutation(h.begin(),h.end()));    return result;&#125;
那么这样我们就能得到每一行的可能情况，每行40种之后就可以正常的DFS了
个人AC代码链接
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>有理函数积分</title>
    <url>/ZestfulYK-blog/2025/12/07/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E7%AC%94%E8%AE%B02%EF%BC%88%E6%9C%89%E7%90%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%83%A8%E5%88%86%E7%A7%AF%E5%88%86%EF%BC%89/</url>
    <content><![CDATA[基本方法
凑成能第一类换元积分的式子  例如$\frac{1}{…}$类的部分分式分解有理函数积分适用条件

有理函数积分当被积函数是有理函数（两个多项式的商）时：$\int \frac{Q(x)}{P(x)}\,​dx$其中 $P(x)$ 和 $Q(x)$ 都是多项式。



分母可因式分解



部分分式分解是处理有理函数积分的系统方法，特别适用于：

分母可明确因式分解
没有更简单的特殊技巧
需要精确解析表达式

当分母 $Q(x)$ 可以分解为一次因式和不可约二次因式的乘积时：

一次因式：$(x-a)$
不可约二次因式：$(x^2+px+q)$，其中 $p^2-4q&lt;0$具体分解规则对于一次因式 $(x-a)^k$：

对应部分为：
\frac{A_1}{x-a}+\frac{A_2}{(x-a)^2}+···+\frac{A_k}{(x-a)^k}对于二次因式 $(x^2+px+q)^m$：\frac{B_1x+C_1}{x^2+px+q}+\frac{B_2x+C_2}{(x^2+px+q)^2}+···+\frac{B_mx+C_m}{(x^2+px+q)^k}但是，在这个部分有一种特殊情况，就是二次式:
\int \frac{P(x)}{Q(x)^2}
在这里，可以把函数看成$\frac{d}{dx}\frac{Ax+B}{Q(x)}+\frac{C}{Q(x)}$两种方法实际上是等价的，因为最后必然化成一个简单的倒数积分和简单的分数积分$\frac{1}{Q(x)}$。

例子：
计算$\int \frac{x^2+1}{(x^2+x+1)^2}\,dx$有两种方式，都能得到答案。1.用标准公式计算得到:\int \frac{x}{(x^2+x+1)^2}\,dx-\int \frac{1}{x^2+x+1}\,dx

接着再分别计算前后的积分，前面得到的是一个分式加上一个含$\arctan x$的式子比较麻烦，不过对于这类题目，我们知道一定能得到第二种简单的方法的式子，所以经过计算得到:
\frac{1}{3}\frac{d}{dx}\frac{x+2}{x^2+x+1}-\frac{4}{3}\int · \frac{1}{x^2+x+1}\,dx这种解法的好处是，得到前半段以后可以直接当作积分结果，不需要额外的处理。
判断步骤第一步：检查是否为真分式
如果 $\deg P(x) \geq \deg Q(x)$：先进行多项式除法（大除法）
如果 $\deg P(x) &lt; \deg Q(x)$：直接进行部分分式分解就是说最高项次数小就能用这个方法第二步：因式分解分母将分母 $Q(x)$ 完全分解为：
一次因式 $(x-a_i)^{k_i}$
不可约二次因式 $(x^2+p_jx+q_j)^{m_j}$第三步：确定分解形式根据因式分解结果，写出部分分式的一般形式。在计算过程中，可以通过给x赋值来快速计算带定值

具体例子分析例1：$\int \frac{x^3+1}{(x^2+1)^2} dx$
分母：$(x^2+1)^2$（二次因式的平方）
分解形式：$\frac{Ax+B}{x^2+1} + \frac{Cx+D}{(x^2+1)^2}$

例2：$\int \frac{1}{x(x-1)^2} dx$
分母：$x(x-1)^2$（一次因式及其平方）
分解形式：$\frac{A}{x} + \frac{B}{x-1} + \frac{C}{(x-1)^2}$

例3：$\int \frac{x^2+1}{x(x^2+4)} dx$
分母：$x(x^2+4)$（一次因式 + 二次因式）
分解形式：$\frac{A}{x} + \frac{Bx+C}{x^2+4}$

例4：$\int \frac{x+1}{x^2+4x+6}\,dx$这个题目看起来和裂项十分相似，但是分母无法因式分解，所以这个方法是不对的。注意到这里上方的次数正好是分母求导结束后的次数，所以游客能采取分开计算的方法。这里首先先把上面的分析翻倍，（因为分母的导数是$2x+4$），接下来在加一个2，减一个2外面再配上$\frac{1}{2}$即可。所以式子变为:$\frac{1}{2} \int \frac{2x+4-2}{x^2+4x+6}\,dx$然后两个部分正好都是我们能计算的第一类换元积分，完成！

$\int \frac{f’(x)}{f(x)} dx$：直接得到 $\ln|f(x)|$
$\int \frac{1}{x^2+a^2} dx$：直接得到 $\frac{1}{a}\arctan\frac{x}{a}$

个人技巧
对于一般的式子，通常是去凑积分，先对其1次项，再分离常数项，这样就能直接得到一个ln积分和一个形如$\frac{p}{t^2+a^2}$的式子了，这个是很好积分的($\arctan x$)
遇到三次式子，可能配凑一个$\pm 1$来计算
遇到分母次数很高的，考虑倒代换
其余的式子，直接展开就行了

三角代换部分重要公式当取$\tan x=u$时
\begin{cases}
\sin x=\frac{u}{\sqrt{1+u^2}} \\
\cos x=\sqrt{1+u^2}
\end{cases}当取$\tan \frac{x}{2}=u$时
\begin{cases}
\sin x=\frac{2u}{1+u^2} \\
\cos x=\frac{1-u^2}{1+u^2}
\end{cases}然后不要忘记，第二类换元积分是需要乘上对应的导数的，这个导数是t关于x的函数，乘上的是含有t的导数之后像前面一样计算就行了。
题型分类
只含有一种三角函数的，用第一类换元积分，例如：$\int \frac{1}{\sin x^4}\,dx$
上下均有且为一次式的，用上节课的方法代换，例如$\int \frac{\sin x}{\sin x+\cos x}\,dx$
同名三角函数相加，和差化积，例如$\int \frac{1}{\sin x+\sin 3x}\,dx$
正常幂(不含分母的)，按奇偶正常拆分
分母含有高次项的，拆解1，例如$\int \frac{1}{\sin x\cos x^2}$主要是把$\cos x$化成$\tan x$来计算。例如：1\int \frac{dx}{a^2+\sin x^2+b^2+\cos x^2}=\int \frac{\frac{1}{\cos x^2}}{a^2\tan x^2+b^2}\,dx=\int \frac{1+\tan x^2}{a^2\tan x^2+b^2}\,dx根式的代换

重要公式令t=\sqrt[n]{ax+b}令t=\sqrt[n]{\frac{ax+b}{cx+d}}令t=\sqrt[mn]{ax+b}看含有什么来决定怎么设t最后反解出x带入其余部分即可。
重要例题根式代换类型求下面这个函数的积分
\int \frac{dx}{\sqrt[n]{(x-a)^{n+1}(x-b)^{n-1}}}\,dx方法：先提取部分，构造类似上面2的一个式子，然后再考虑代换。
\text{原式}=\int\frac{1}{(x-a)(x-b)\sqrt[n]{\frac{x-a}{x-b}}}\,dx不过接下来直接解出x再带回比较麻烦，所以考虑直接算出$\frac{dx}{(x-a)(x-b)}$这个部分
t^n=\frac{a-b}{(x-b)^2}\frac{nt^n\,dt}{t}=\frac{a-b}{(x-b)^2}\,dx\frac{n\,dt}{t}=\frac{a-b}{(x-b)^2t^n}\,dx=\frac{a-b}{(x-a)(x-b)}\,dx所以得到原式变为：
-\frac{n}{a-b}\sqrt[n]{\frac{x-b}{x-a}}重要例题偶数次幂分数类型方法是化为平方分之括号内函数的导数即：
\int \frac{f'(x)}{f(x)^2+a}例如：
\int \frac{1}{x^4+1}\,dx=\frac{1}{2}\int\frac{1+\frac{1}{x^2}-1}{x^2+\frac{1}{x^2}}=\frac{1}{2}(\int \frac{d x-\frac{1}{x}}{(x-\frac{1}{x})^2+2}+\int \frac{d x+\frac{1}{x}}{(x+\frac{1}{x})^2+2})$$$$=\frac{1}{2\sqrt{2}}\arctan \frac{x-\frac{1}{x}}{\sqrt{2}}-\frac{1}{4\sqrt{2}}\ln|\frac{x^2-\sqrt{2}x+1}{x^2+\sqrt{2}x+1}| 所以类似于$\frac{\text{二次}}{\text{四次}}$的式子，理论上都有可能用这种方式解决
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>第一类换元积分</title>
    <url>/ZestfulYK-blog/2025/12/07/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[重要公式基本积分公式：不要忘记加C!!!
$\xi \ \delta \ \alpha \ \beta \ \pi \  \theta \ \in \ \notin$$\Delta$
$\int k \, dx = kx + C$$\int x^n \, dx = \frac{x^{n+1}}{n+1} + C \quad (n \neq -1)$$\int \frac{1}{x} \, dx = \ln|x| + C$

指数函数：$\int e^x \, dx = e^x + C$$\int a^x \, dx = \frac{a^x}{\ln a} + C$

三角函数：$\int \sin x \, dx = -\cos x + C$$\int \cos x \, dx = \sin x + C$$\int \tan x \, dx = -\ln|\cos x| + C$$\int \cot x \, dx = \ln|\sin x| + C$$\int \sec^2 x \, dx = \tan x + C$$\int \csc^2 x \, dx = -\cot x + C$$\int \sec x \tan x \, dx = \sec x + C$$\int \csc x \cot x \, dx = -\csc x + C$$\int secx\,dx= ln|secx+tanx|+C$$\int cscx\,dx= ln|cscx-cotx|+C$



反三角函数：$\int \frac{1}{\sqrt{1-x^2}} \, dx = \arcsin x + C$$\int \frac{1}{1+x^2} \, dx = \arctan x + C$

双曲函数：$\int \sinh x \, dx = \cosh x + C$$\int \cosh x \, dx = \sinh x + C$

特殊积分：$\int \frac{1}{x^2+a^2} \, dx = \frac{1}{a}\arctan\frac{x}{a} + C$$\int \frac{1}{\sqrt{a^2-x^2}} \, dx = \arcsin\frac{x}{a} + C$$\int \frac{1}{x^2-a^2} \, dx = \frac{1}{2a}\ln\left|\frac{x-a}{x+a}\right| + C$

和差化积公式：$\sin A + \sin B = 2 \sin\left(\frac{A+B}{2}\right) \cos\left(\frac{A-B}{2}\right)$$\sin A - \sin B = 2 \cos\left(\frac{A+B}{2}\right) \sin\left(\frac{A-B}{2}\right)$$\cos A + \cos B = 2 \cos\left(\frac{A+B}{2}\right) \cos\left(\frac{A-B}{2}\right)$$\cos A - \cos B = -2 \sin\left(\frac{A+B}{2}\right) \sin\left(\frac{A-B}{2}\right)$

积化和差公式：$\sin A \cos B = \frac{1}{2}[\sin(A+B) + \sin(A-B)]$$\cos A \sin B = \frac{1}{2}[\sin(A+B) - \sin(A-B)]$$\cos A \cos B = \frac{1}{2}[\cos(A+B) + \cos(A-B)]$$\sin A \sin B = -\frac{1}{2}[\cos(A+B) - \cos(A-B)]$


对部分公式的推导：$\int \tan x \, dx = -\ln|\cos x| + C$$\int \tan x \, dx = \int \frac{sinx}{cosx} \,dx = - \int \frac{dcosx}{sinx} \, = -ln|cosx|+ C$

对于 $\int cotx$ 同理
小技巧：
$sinx^m cosx^n$之类的，奇数的话拆一个进去积分，偶数的话用倍角或半角公式

在对$\int tanx\,dx$或者$\int secx\,dx$等方法一样，可以类比

奇数如$\int sin^3 \, dx$或者$\int sin^3cosx\,dx$等比如$\int sinx^3\,dx=-\int sinx^2\,dcosx=-\int(1-cos^2x)\,dcosx$$=-cosx+\frac{1}{3}cosx^3+C$
偶数如$\int cosx^4\,dx$等比如$\int cosx^4\,dx=\int(\frac{1+cos2x}{2})^2\,dx=\frac{1}{4}\int1+cos2x^2+2cos2x\,dx$$=\frac{1}{4}(x+\frac{1}{2}\int cos2x^2\,d2x+\int cos2x\,d2x)+C$$=\frac{1}{4}(x+sin2x+\frac{1}{2}\int \frac{1+cos4x}{2}\,d2x)+C$$=\frac{1}{4}(x+sin2x+\frac{1}{8} \int(1+cos4x)\,d4x)+C$$=\frac{1}{4}(x+sin2x+\frac{1}{8}(4x+sin4x))+C$$=\frac{3}{8}x+\frac{1}{4}sin2x+\frac{1}{32}sin4x+C$

对于$\frac{…+…}{…}$类的可能是把上面的式子拆成两个分别计算例如：$\int \frac{1+x}{\sqrt{2-3x^2}}\,dx$$=\int \frac{1}{\sqrt{2-3x^2}}\,dx+\int \frac{x}{\sqrt{2-3x^2}}\,dx$

要熟记各种三角函数的导数和公式以及转换关系：$secx^2-1=tanx^2$$cscx^2-1=cotx^2$
arctan(\frac{1}{x})=\begin{cases}
arccot(x)\ \ \ \ \ \ \ \ \ x>0\\
arccot(x)-\pi  \ \ x]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>分步积分笔记</title>
    <url>/ZestfulYK-blog/2025/12/07/%E5%88%86%E6%AD%A5%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[核心公式\int u\,dv = uv - \int v\,du选择原则：”反对幂指三”优先级从高到低选择 $u$：

反三角函数（$arcsin$,$arccos$, $arctan$等）
对数函数（$\ln x$, $log x$等）
幂函数（$x^n$, $x^2$, $\sqrt{x}$等）
指数函数（$e^x$, $a^x$等）
三角函数（$\sin x$, $\cos x$等）

口诀解释：越靠前的类型越优先选为 $u$，越靠后的类型越优先放入 $dv$。

经典类型与解法类型1：幂函数 × 三角函数$\int x^n\cos x\,dx$ 或 $\int x^n\sin x\,dx$

将三角函数放入 $dv$（如 $\cos x\,dx = d(\sin x)$）
通过 $n$ 次分部积分逐次降幂

类型2：幂函数 × 指数函数$\int x^n e^{ax}\,dx$

将指数函数放入 $dv$（如 $e^{ax}\,dx = \frac{1}{a}d(e^{ax})$）
逐次降幂至 $x^0$

类型3：幂函数 × 对数函数$\int x^n \ln x\,dx$

将对数函数选为 $u$（$\ln x$ 求导得 $\frac{1}{x}$，可消去 $x$ 幂）
幂函数放入 $dv$

类型4：指数函数 × 三角函数$\int e^{ax}\sin(bx)\,dx$ 或 $\int e^{ax}\cos(bx)\,dx$

任选其一放入 $dv$（通常选三角函数）
两次分部积分后出现循环，解方程求得原积分


高级技巧与注意事项技巧1：隐藏的 $dv$当被积函数为分式时，常将分母或其部分放入 $dv$：
\int \frac{x\arcsin x}{\sqrt{1-x^2}}\,dx令 $u=\arcsin x$，$dv=\frac{x}{\sqrt{1-x^2}}dx$，则 $v=-\sqrt{1-x^2}$
技巧2：凑微分调整对于 $\int \frac{x}{e^{2x}}\,dx$，可改写为 $\int x e^{-2x}\,dx$

令 $u=x$，$dv=e^{-2x}dx$
则 $du=dx$，$v=-\frac{1}{2}e^{-2x}$
代入公式：$-\frac{1}{2}xe^{-2x} + \frac{1}{2}\int e^{-2x}dx$

技巧3：多次分部积分\int x^2 e^x\,dx = x^2 e^x - 2\int x e^x\,dx需连续使用分部积分，直到幂函数降为常数
技巧4：递推关系某些积分可建立递推公式：
\int x^n e^x\,dx = x^n e^x - n\int x^{n-1} e^x\,dx技巧5：组合拆分对于 $\int e^x(\sin x + \cos x)\,dx$，可拆分为两个分部积分，但更简单的方法是观察导数关系：$d(e^x \sin x) = e^x(\sin x + \cos x)dx$

常见易错点
符号错误：公式中的减号易漏写
$v$ 计算错误：求 $v$ 时积分常数可省略（因最后会抵消）
选择不当：违反”反对幂指三”可能导致积分更复杂
循环处理：$\int e^x \sin x\,dx$ 类问题，移项时注意系数


典型例题例1：对数函数\int \ln x\,dx = x\ln x - \int x\cdot\frac{1}{x}dx = x\ln x - x + C例2：反三角函数\int \arcsin x\,dx = x\arcsin x - \int \frac{x}{\sqrt{1-x^2}}dx = x\arcsin x + \sqrt{1-x^2} + C例3：循环积分\int e^x \sin x\,dx
第一次：$u=\sin x$，$dv=e^x dx$，得 $e^x \sin x - \int e^x \cos x\,dx$
第二次：对 $\int e^x \cos x\,dx$ 再分部积分
得方程：$I = e^x \sin x - e^x \cos x - I$
解得：$I = \frac{e^x(\sin x - \cos x)}{2} + C$

例4：含负指数\int \frac{\arctan e^x}{e^{2x}}\,dx = -\frac{1}{2}\int \arctan e^x\,d(e^{-2x})令 $u=\arctan e^x$，$dv=d(e^{-2x})$，需注意 $du=\frac{e^x}{1+e^{2x}}dx$

特殊情形处理
只有一类函数：如 $\int \ln x\,dx$，视为 $1\cdot\ln x\,dx$
乘积含三个因子：先组合两个放入 $dv$，或换元简化
分母复杂：考虑整体代换或分部积分后消去分母
定积分：计算时先求原函数，注意上下限代入

还有更重要的一点是不要被形式迷惑了双眼，$\frac{1}{\cos x^2}$是什么啊？不认识？这就不对了我认为，直接先表示回去就行了，这下认出来了（然后看到对$\sec x$求导时不要忘记公式，还在企图自己推导
商的导数逆运算（反向商法则）在积分中，有时会遇到形如 $\frac{u’v - uv’}{v^2}$ 的被积函数，这正是商函数 $\left( \frac{u}{v} \right)’$ 的导数。因此，可以直接写出原函数 $\frac{u}{v} + C$。

核心识别技巧
分母为平方形式：通常为 $v^2$ 或可化为 $v^2$。
分子为两项之差：且每项均为两个函数的乘积（即 $u’v$ 和 $uv’$）。
找出 $u$ 和 $v$：从分母中猜测 $v$（通常为分母的“一部分”），再根据分子确定 $u$。


一般步骤设被积函数为 $\frac{P(x)}{Q(x)}$：

尝试将 $Q(x)$ 写成 $v^2$ 的形式（或类似）。
观察 $P(x)$ 是否能表示为 $u’v - uv’$。
若可以，则积分结果为 $\frac{u}{v} + C$。例题：\int\frac{xf'(x)-(1+x)f(x)}{x^2e^x}\,dx


分母：$x^2 e^x = (x e^x)^2 \cdot e^{-x}$？实际上，直接考虑函数 $\frac{f(x)}{x e^x}$ 的导数。
设 $v = x e^x$，则 $v’ = (1+x)e^x$。
设 $u = f(x)$，则 $u’ = f’(x)$。
计算 $\left( \frac{u}{v} \right)’ = \frac{u’v - uv’}{v^2} = \frac{f’(x) \cdot x e^x - f(x) \cdot (1+x)e^x}{(x e^x)^2} = \frac{x f’(x) - (1+x)f(x)}{x^2 e^x}$。
因此，原积分 $= \frac{f(x)}{x e^x} + C$。

常用构造
对于 $\int \frac{f’(x)g(x) - f(x)g’(x)}{g(x)^2} dx$，结果为 $\frac{f(x)}{g(x)} + C$。
对于 $\int \frac{f’(x)g(x) - f(x)g’(x)}{[g(x)]^n} dx$（$n \neq 2$），通常需要调整。

]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>压行技巧</title>
    <url>/ZestfulYK-blog/2025/10/24/%E5%8E%8B%E8%A1%8C%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[如何给你的代码压行？如果不会压行，你的代码看起来会是这样的：
int ml(vector&lt;int&gt; s, int n)&#123;    int m = s[0];    for (int i = 0; i &lt;= n; i++)    &#123;        if (s[i] &gt; m)            m = s[i];    &#125;    return m;&#125;
整整用了9行！实际上其实根本不需用那么多行：int ml(vector&lt;int&gt; s,int n)&#123;    int m=s[0];    for(int i=0;i&lt;=n;i++)&#123;        if(s[i]&gt;m)m=s[i];    &#125;    return m;&#125;
当然也可以更短：int ml(vector&lt;int&gt; s,int n)&#123;    int m=s[0];    for(int i=0;i&lt;=n;i++) if(s[i]&gt;m) m=s[i];    return m;&#125;那么问题来了，怎么在不影响代码运行的情况下合理的压行呢？
判断类循环类的压行技巧判断类如果判断语句仅一行，可以考虑压行：
if(a==1) sum++;else sum--;//或者这样if(a==1)    sum++;//可以通过缩进来方便区分
两句的话，压行可以考虑用大括号包起来压行前提是你觉得看着没影响
if(a==1) &#123;sum++;a=2;&#125;
注意在大括号里的每一句都是要加上封号的，因为这一段代码实际上等价于：
if(a==1)&#123;    sum++;    a=2;&#125;
循环类压行也和判断的一样，可以这么压行：
for(int i=1;i&lt;=n;i++) cout&lt;&lt;1&lt;&lt;endl;//或者这样：for(int i=1;i&lt;=n;i++)    cout&lt;&lt;1&lt;&lt;endl;
如果是输出的话，其实可以这么写：
for(int i=1;i&lt;=n;i++) cout&lt;&lt;i&lt;&lt;&quot; &quot;; cout&lt;&lt;endl;
因为C++cout&lt;&lt;endl;其实是在循环之外的，所以这么写是正确的
头文件压行下面送给大家万能头文件：
#include&lt;bits/stdc++.h&gt;
其他技巧#define ll long long#define rep(1,n) for(int i=1;i&lt;=(n);i++)ll n;int main()&#123;    rep(1,n) cout&lt;&lt;&quot;*&quot;; cout&lt;&lt;endl;&#125;
通过define来减少代码长度，增加可读性
一些非常有用的C++自带函数sort(a,a+n);//a为数组，n为a的大小__gcd(x,y);//x，y的最大公约数x=1&lt;&lt;n;//2的n次方
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>广工月赛</title>
    <url>/ZestfulYK-blog/2025/10/20/%E5%B9%BF%E5%B7%A5%E6%9C%88%E8%B5%9B/</url>
    <content><![CDATA[ZestfulYK的战绩
比赛难度中等，以基础题为主，拼尽全力战胜少量难题
部分代码F
分析很不错的博弈题目，使我的大脑旋转，最后打表做出来了

题目链接

代码:#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123;    ll n,m;    cin&gt;&gt;n&gt;&gt;m;    if(n==0&amp;&amp;m==0) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==1&amp;m==0) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl;    else if(n==2&amp;m==0) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==3&amp;m==0) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==0&amp;m==1) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl;    else if(n==0&amp;m==2) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==0&amp;m==3) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl;//    else if(n==1&amp;m==1) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==1&amp;m==2) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==1&amp;m==3) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl;//    else if(n==2&amp;m==1) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==2&amp;m==2) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==2&amp;m==3) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl;//    else if(n==3&amp;m==1) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==3&amp;m==2) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==3&amp;m==3) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl;&#125;
J
分析这题目也不错，但其实看代码找规律就行了

题目链接

代码:
#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123;    ll n; cin&gt;&gt;n;    ll s=sqrt(n);    if(s*s!=n) s++;    ll last=n%s;    for(int i=last;i&gt;=1;i--) cout&lt;&lt;i&lt;&lt;&quot; &quot;;    for(int j=1;j&lt;=n/s;j++)&#123;        for(int i=last+j*s;i&gt;last+(j-1)*s;i--) cout&lt;&lt;i&lt;&lt;&quot; &quot;;    &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机18讲题解</title>
    <url>/ZestfulYK-blog/2025/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA18%E8%AE%B2%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[小技巧
在网页前面加上read有奇效例如：
raed:https://www.reach-top.cn.com
这个是阅读器模式，开启以后就能获取里面原先不让复制的内容了
A题
题目描述每个整数都应输出一个各位数字和，并独占一行。

解题思路拿之前上课的程序自然是能解决的，直接一个循环算到底每一位的值是n%10，要取得下一位就n/=10再算就彳亍了但是注意到这节课的标题是函数，那么我们就编写一个递归程序来计算每一位的和边界条件：n&lt;=10递推式子：n %10+solve(n/10)
参考代码
ll solve(ll n)&#123;  if(n&lt;10) return n;  return n%10+solve(n/10);&#125;signed main()&#123;  ll T;  while(cin&gt;&gt;T)	cout&lt;&lt;solve(T)&lt;&lt;endl;  return 0;&#125;//此处#define ll long long
B题
题目描述给定若干个正整数，请你从这些整数中找到最小值和第二小的值，计算一下第二小的数值减去最小值的结果是不是素数，如果是则输出Yes，否则输出No”o。 

解题思路直接写一个循环计算最小值和次小值，然后判断差是不是素数就行了计算最小值和次小值的思路，如果输入值x比最小值小，那么把次小值改成原先的最小值，再把最小值修改为输入值x，如果只是比次小值小，那么把次小值改成输入值x
参考代码void isprime(int n)&#123;  if(n==1)&#123;    cout&lt;&lt;&quot;No\&quot;o&quot;&lt;&lt;endl;    return;  &#125;  for(int i=2;i&lt;=sqrt(n);i++)&#123;    if(n%i==0)&#123;      cout&lt;&lt;&quot;No\&quot;o&quot;&lt;&lt;endl;      return;    &#125;  &#125;  cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;&#125;signed main()  ll minn1=1e18,minn2=1e18,x;  while(cin&gt;&gt;x)&#123;    if(x&lt;minn1)&#123;      minn2=minn1;      minn1=x;    &#125;    else if(x&lt;minn2)      minn2=x;  &#125;  isprime(minn2-minn1);  return 0;&#125;


C题
题目描述哥德巴赫猜想大家都知道一点吧。我们现在不是想证明这个结论，而是想在程序语言内部能够表示的数集中，任意取出一个偶数，来寻找两个素数，使得其和等于该偶数。  做好了这件实事，就能说明这个猜想是成立的。由于可以有不同的素数对来表示同一个偶数，所以专门要求所寻找的素数对是两个值最相近的。
解题思路直接暴力求解从中间开始计算，设两个数分别是x，y，然后x—，y++，判断是否是合法的，如果合法那么输出，这样得到的第一组解必然是最小的一组解。判断是否是素数的代码可以用上一题的代码。
参考代码bool isprime(ll n)&#123;  if(n==1) return false;  for(int i=2;i&lt;=sqrt(n);i++)&#123;    if(n%i==0)      return false;  &#125;  return true;&#125;signed main()&#123;  ll x;  while(cin&gt;&gt;x&amp;&amp;x)&#123;    ll a1=x/2,a2=x/2;    while(1)&#123;      if(isprime(a1)&amp;&amp;isprime(a2))&#123;        cout&lt;&lt;a1&lt;&lt;&#x27; &#x27;&lt;&lt;a2&lt;&lt;endl;        break;      &#125;      a1--; a2++;    &#125;  &#125;  return 0;&#125;


D题
题目描述求给定n个正整数的最大公约数
解题思路计算每个数和现在得到的最大公约数的最大公约数首先先默认最大公约数为第一个正数，然后计算即可。计算最大公约数其实有两种方式，要是你用万能头的话，可以使用自带函数直接计算。这里采用的是标准的辗转相除法。
参考代码ll gcd(ll n,ll m)&#123;  if(n%m==0) return m;  else return gcd(m,n%m);&#125;signed main()&#123;  ll n,x; cin&gt;&gt;n;  ll m=n,maxgcd;  while(cin&gt;&gt;x&amp;&amp;n)&#123;    if(x&lt;=0) continue;    if(n==m) maxgcd=x;    n--;    maxgcd=gcd(maxgcd,x);    //maxgcd=__gcd(x,maxgcd);这个是自带的函数，也是可以的  &#125;  cout&lt;&lt;maxgcd&lt;&lt;endl;&#125;


E题
题目描述找比x大的第一个回文数
解题思路每次加1，直到找到回文数为止。判断回文数的话，直接先一位一位取出来，然后计算，一个正向遍历，一个反向遍历，结果一样就是回文。
参考代码bool hws(ll x)&#123;  ll a[2000],id=1;  while(x)&#123;    a[id++]=x%10;    x/=10;  &#125;  for(int i=1;i&lt;id;i++)    if(a[i]!=a[id-i])      return false;  return true;&#125;signed main()&#123;  ll x;  while(cin&gt;&gt;x)&#123;    x++;    while(!hws(x++));    cout&lt;&lt;x-1&lt;&lt;endl;  &#125;&#125;
这里因为要求要比x大，所以先x++，最后输出x-1的原因是循环里写的是x++最后会多1。

F题
题目描述如果一个数从左到右和从右到左读都一样，那么这个数就叫做“回文数”。如果一个数的十进制和二进制表示都是回文数，则把这个数叫做“双重回文数”。例如，十进制33是回文数，将其转化为二进制表示100001也是回文数，所以33是双重回文数。编写程序，查找1~1000的所有双重回文数。
解题思路和上一题一样，只不过要多出力一个二进制的而已。
参考代码bool hws(ll x)&#123;  ll a[2000],id=1;  ll y=x;  while(x)&#123;    a[id++]=x%10;    x/=10;  &#125;  for(int i=1;i&lt;id;i++)    if(a[i]!=a[id-i])      return false;    id=1;  while(y)&#123;    a[id++]=y%2;    y/=2;  &#125;  for(int i=1;i&lt;id;i++)    if(a[i]!=a[id-i])      return false;  return true;&#125;signed main()&#123;  for(int i=1;i&lt;=1000;i++)    if(hws(i)) cout&lt;&lt;i&lt;&lt;&quot;为双重回文数&quot;&lt;&lt;endl;&#125;


]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>程C笔记</title>
    <url>/ZestfulYK-blog/2025/12/07/%E7%A8%8BC%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[1. 头文件和命名空间C++ 中的 string 类定义在头文件 string 中，通常使用 std 命名空间。
s3=strcat(s1,s2);//加在后面int x=strcmp(s1,s2)//返回三种情况,见下面cout&lt;&lt;strlen(s1)&lt;&lt;endl;//输出的是长度，等同于s1.length()strcpy(s1+x1,s2+x2);//把前面的对应部分添加到前面去，完全覆盖之前的内容memcpy(a+x1,b+x2,sizeof(int)*8);//也是把后面的放到前面，只不过需要规定放入的内容sizeof(s1);//考虑后面的&#x27;\0&#x27;，比strlen大1.
x=strcmp(s1,s2)= 
\begin{cases}
 -1  \ \ \ \ \ s1 \leq s2\\
0\ \ \ \ s1=s2\\
1\ \ \ \ s1 \geq s2
\end{cases}memcpy例子：int a[8]=&#123;1,2,3,4,5,6,7,8&#125;;int b[10]=&#123;10,9,8,7,6,5,4,3,2,1&#125;;memcpy(b,a,sizeof(int)*8);for(int i=0;i&lt;10;i++)    cout&lt;&lt;b[i];输出：1234567821
2.函数int maxGap(int* p, int n)//传入p[0]的地址，能改变在主函数里的值static int t;//静态局部变量，下次还是调用上次的值//例如：int cnm(int p,int q)&#123;	static int t=0;	t+=p+q;	return t;&#125;signed main()&#123;	cout&lt;&lt;cnm(1,2)&lt;&lt;cnm(2,3)&lt;&lt;endl;&#125;

局部变量，全局变量，如果多个声明，那么优先使用内部的数据
int a=5;int main()&#123;	int a=10,b=20;	for(int i=1;i&lt;=3;i++)&#123;		cout&lt;&lt;a++&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;		&#123;			static a=0;			for(int j=1;j&lt;=5;j++)&#123;				a+=j;			&#125;			b+=a;		&#125;	&#125;&#125;

要根据函数返回的类型来决定函数的类型

要根据函数内的使用变量来决定函数使用的参数值//例如：char* fun(int c)&#123;//程C一般不用string，自己写都行	return &quot;yes&quot;;&#125;int* fun1(int c)&#123;	int a[]=&#123;1,2,3&#125;;	return a;&#125;


]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>过关考模拟考题解</title>
    <url>/ZestfulYK-blog/2025/10/23/%E8%BF%87%E5%85%B3%E8%80%83%E6%A8%A1%E6%8B%9F%E8%80%83%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[过关考模拟考题解A签到题
分析:

要是这也不会那学习委员真没招了

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    cout&lt;&lt;&quot;Help others voluntarily but never let them know they owe you a favor.&quot;&lt;&lt;endl;&#125;
B选择结构
分析:

按照要求逐个判断，然后取最小值就行了

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    double x,y,n,p,ans=200;    cin&gt;&gt;x&gt;&gt;y&gt;&gt;n&gt;&gt;p;    if(p&gt;=x) ans=min(ans,p-y);    ans=min(ans,p/10*n);    printf(&quot;%.2lf&quot;,ans);&#125;
C循环
分析:

分三种情况，&lt;10的一定成立，两三四位数自己判断就行了

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n,cnt=0; cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        if(i&lt;10) cnt++;        else if(i&lt;100)&#123;            if(i%10==i/10) cnt++;        &#125;        else if(i&lt;1000)&#123;            if(i%10==i/10%10&amp;&amp;i%10==i/100) cnt++;        &#125;        else if(i%10==i/10%10&amp;&amp;i%10==i/100%10&amp;&amp;i%10==i/1000) cnt++;    &#125;    cout&lt;&lt;cnt&lt;&lt;endl;&#125;

打表的做法

为什么没人想到这题能打表呢？总共也就28个数啊
#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int a[30]=&#123;1,2,3,4,5,6,7,8,9,11,    22,33,44,55,66,77,88,99,111,    222,333,444,555,666,777,888,999,1111,2222&#125;,n;    cin&gt;&gt;n;    for(int i=0;i&lt;=28;i++)&#123;        if(a[i]&gt;n) &#123;cout&lt;&lt;i&lt;&lt;endl;break;&#125;    &#125;&#125;
D菱形
分析:

逐行输出，先上半部分，再是后半部分

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n; cin&gt;&gt;n;    for(int i=0;i&lt;=n/2;i++)&#123;        for(int j=1;j&lt;=n/2-i;j++) cout&lt;&lt;&quot;.&quot;;        cout&lt;&lt;&quot;#&quot;;        for(int j=1;j&lt;=i*2-1;j++) cout&lt;&lt;&quot;.&quot;;        if(i!=0) cout&lt;&lt;&quot;#&quot;;        for(int j=1;j&lt;=n/2-i;j++) cout&lt;&lt;&quot;.&quot;;        cout&lt;&lt;endl;    &#125;    for(int i=n/2-1;i&gt;=0;i--)&#123;        for(int j=1;j&lt;=n/2-i;j++) cout&lt;&lt;&quot;.&quot;;        cout&lt;&lt;&quot;#&quot;;        for(int j=1;j&lt;=i*2-1;j++) cout&lt;&lt;&quot;.&quot;;        if(i!=0) cout&lt;&lt;&quot;#&quot;;        for(int j=1;j&lt;=n/2-i;j++) cout&lt;&lt;&quot;.&quot;;        cout&lt;&lt;endl;    &#125;&#125;
E金字塔
分析:

逐个循环相加就行了

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n,ans=0; cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++) ans+=i*i;    cout&lt;&lt;ans&lt;&lt;endl;&#125;
F假期阅读
分析:

最多k*t页，但不能超过n

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n,k,t; cin&gt;&gt;n&gt;&gt;k&gt;&gt;t;    cout&lt;&lt;min(n,k*t)&lt;&lt;endl;&#125;
G值日
分析:

求最小公倍数

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n,m,i; cin&gt;&gt;n&gt;&gt;m;    for(i=n;i%m!=0;i+=n);    cout&lt;&lt;i&lt;&lt;endl;&#125;
H数三角形
分析:

循环i 1..n，j 1..i即可，每次判断一下是否存在整数解

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n,cnt=0; cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=i;j++)&#123;            if(i*j%2==0) cnt++;        &#125;    &#125;    cout&lt;&lt;cnt&lt;&lt;endl;&#125;
I幂数和
分析:

直接暴力枚举所有数，判断是否能拆就行了遍历每种可能的情况，计算和是否为这个数就行了至于代码中的&lt;&lt;是二进制内左移的意思，用来计算2的n次幂比如1&lt;&lt;1是10，变成了2，同理还有右移，自己学习

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int l,r,cnt=0; cin&gt;&gt;l&gt;&gt;r;    for(int i=l;i&lt;=r;i++)&#123;        bool f=false;        for(int j=0;j&lt;=20;j++)&#123;            for(int k=0;k&lt;=20;k++)&#123;                if((1&lt;&lt;j)+(1&lt;&lt;k)==i) &#123;cnt++;f=true;break;&#125;            &#125;            if(f) break;        &#125;    &#125;    cout&lt;&lt;cnt&lt;&lt;endl;&#125;
J质因数分解
分析:

第一空，先输出n，免得后面n的值变掉了第二空判断是否算一个因子，当然最后一个是需要特判的第三空，既然发现了因子，那么把n减小，变为n/i第四空，找的不对，i自增，寻找下一个位置第五空，输出最后一个质因数

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123;    ll n,i=2; cin&gt;&gt;n;    cout&lt;&lt;n&lt;&lt;&quot;=&quot;;    for(i=2;i&lt;=n;)&#123;        if(n%i==0&amp;&amp;n/i!=1)&#123;            cout&lt;&lt;i&lt;&lt;&quot;*&quot;;            n/=i;        &#125;        else&#123;            i++;        &#125;    &#125;    cout&lt;&lt;i-1&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
