<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>格雷码及其应用</title>
    <url>/ZestfulYK-blog/2025/02/12/(%E6%A0%BC%E9%9B%B7%E7%A0%81)%E6%9E%84%E9%80%A0%E5%BA%8F%E5%88%97,%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E5%BC%82%E6%88%96%E5%92%8C%E6%9C%80%E5%B0%8F/</url>
    <content><![CDATA[题目输入n,构造长度为$2^n-1$的序列,使得下面在这个式子的值最小
\sum_{i=1}^{2^n-1}a_{i-1} \oplus a_i方法:每组相邻元素最好二进制中只有一位不一样
打表结果:
n=1  0 1n=2  0 1 3 2n=3  0 1 3 2 6 7 5 4     1 0 2 3 7 6 4 5
所以暴力或者按结论使用格雷码
#include &lt;iostream&gt;using namespace std;int main() &#123;    int n;    cin &gt;&gt; n;    int m = 1 &lt;&lt; n;    for (int i = 0; i &lt; m; ++i) &#123;        cout &lt;&lt; (i ^ (i &gt;&gt; 1));        if (i &lt; m - 1) cout &lt;&lt; &#x27; &#x27;;    &#125;    cout &lt;&lt; endl;    return 0;&#125;
ll n; cin&gt;&gt;n;  set&lt;ll&gt; s;  s.insert(0);  cout&lt;&lt;&quot;0 &quot;;  ll last=0;  for(int i=1;i&lt;=(1ll&lt;&lt;n)-1;i++)&#123;    for(int j=0;j&lt;=18;j++)&#123;      ll next;      if((last&gt;&gt;j)%2==0)&#123;        next=last+(1ll&lt;&lt;j);      &#125;      else&#123;        next=last-(1ll&lt;&lt;j);      &#125;      if(s.find(next)==s.end())&#123;        cout&lt;&lt;next&lt;&lt;&quot; &quot;;        s.insert(next);        last=next;        break;      &#125;    &#125;  &#125;  cout&lt;&lt;endl;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM训练</title>
    <url>/ZestfulYK-blog/2025/12/07/ACM%E8%AE%AD%E7%BB%83%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[简单题
对于简单题目，最好还是仔细一点，或者使用最暴力的解法，而不是投机取巧，或者构造高级方法，通常样例数据都是片面的，常常会有坑。

sleeping through classes
比如这一题，数据没有包含i+k中间有1的情况，直接i+=k导致错误。
中等题目
中等题目就需要强观察力和trick技巧了

Niko’s Tactical Cards
这一道题目是动态规划的变种，虽然要求每一步最优，但是可能发生最小值突然转变成最大值的情况，因此，计算最小值也是必要的。只要计算这两个值就行了。
Kanade’s Perfect Multiples
这题希望我们构造一个满足要求的B，这个就有点类似于筛法求素数了，实际上两者的代码几乎是一样的，但是在做的时候要注意区分原始数据和v数组，一个一个遍历就行了，找不到就可以直接退出，因为不然当前确定的最小值就无法被覆盖了。
Merging the Sets
你想选择其中的一些集合（可能一个都不选，也可能全部都选），使得 1 和 m 之间的每个整数都包含在个所选集合中的至少一个中。思维误区，不用一边读入一边判断，因为数据保证$l\leq 2*10^5$所以先读入再判断就行了，此外，要方法合法需要这个集合不存在也合法，那么只要用桶来看看去掉会不会变0就行了。原先想到的覆盖才合法的思路不对的原因是前后都有可能覆盖。
Abraham’s Great Escape
要求构造一个方阵，每个位置一个箭头，满足有k个格子能沿箭头出去。其实只要管最后一行，前面k个填U，后面的填D，最后一行填$RRR……RL$就行了比如：19 4UUUUDDRRL这样在最后一行产生循环，前面的不管。原来的做法是两个两个组合，产生循环，虽然也能做，但是不方便。
Cake Assignment
这个题目的重要观察点是，当最后一步确定后，上一步的操作一定是确定的，于是我们就可以倒推
XOR Array
这题的要求是构造一个数组，满足仅在l到r上的异或和为0，其他位置全非0，异或有一个特点，和前缀和一样，可以构建前缀异或和，因为$x\oplus y \oplus x==x$此外非常容易陷入的一个点是，可能会想到之间填入1-n来构造，但是实际上，这么异或会产生很多的0，所以这个方法是不行的。（比如1，2，3）因此，这里我们的操作是构造最终异或的结果，写一个前缀异或数组，最后再反推原数组就行了。详细信息可以见异或的笔记部分
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法挑战赛题解（11.2）</title>
    <url>/ZestfulYK-blog/2025/11/03/1/</url>
    <content><![CDATA[算法挑战赛题解（11.2）简单版本：题目大意：给定n个区间，判断这些区间能划分出几种不同的区域

性质不同的数字

题目分析：实际上是在讨论每个点被哪几个区包含，在样例中，数据是这样的，我们来分析一下这两个样例
Sample Input 1 11 6Sample Output 12Sample Input 240 124 136 1312 13Sample Output 26
样例分析：样例1: 0 1 1 1 1 1 1 0 0 … …  所以是两种区间样例2: 1   2  3   4   5   6   7  8    9   10  11  12  13 … …       1   1  1   1   1   1   1  1   1    1   1   1                  2   2   2   2  2   2    2   2   2   2                          3   3  3   3    3   3   3   3                                                  4   4       |&lt; ------ &gt;|&lt; ---- &gt;|&lt; ----------------- &gt;|&lt;-&gt;|&lt;-&gt;|&lt;--
所以是6种区间这样,我们就弄明白了题目在讲什么,接下来就可以思考怎么实现了
题目思路：实际上有些人会以为我们需要统计的是这个点有几个区间经过，但是这是错误的，在样例二就能发现这一点。（这也是我第一次的想法，测试样例二时发现的T_T）
我们需要思考怎么表示这一个点有哪些区间经过，而且每一个区间是互不相同的。这里我们考虑类似状态压缩的思想。
什么是状态压缩呢？简而言之就是用一个数来代替这个状态。比如说，我们用1表示未进行，2表示正在进行，3表示完成，那么一个含有4个任务的任务表可以是这样的：
            1321
（1，4任务未进行，2任务完成，3正在进行）
我们使用了一个4位数表示了这一状态，这样就实现了状态压缩，我们没有用数组存储状态，而是一个数，这样我们在判断两个状态是否相同时就可以直接判断数字是否相同了，节约了时间和判断的复杂度。
那么怎么把这个思想用在这一题呢？我们考虑给每个区间一个标号k，每个区间内的点加上2^k，这样就保证了每一个状态不会重复。但是这么写居然WA了！这是因为数据范围n是[0,300]也就是会有2^300，远大于long long的最大范围(2^64-1)这显然是不行的。
实际上这个算法已经十分接近答案了,但我们还需要改进这个算法。接着我们想到一个类似的方法，哈希表(hash)。
其实哈希表和刚才的思路差不多，不过加入了一些更高级的算法来防止数据溢出。
那么什么是hash呢？实际上也是创建一种对应关系，使得在查询时能快速访问这种情况对应的值。就像上面的例子一样，我们通过我们规定的方式把任务状态和整数一一对应。
怎么创建hash表呢？首先，找到一个质数作为进制数P，通常取131或者13331，模数mod通常取1e9+7或1e9+9，对应关系就是对应的P进制数%mod例如这个点上经过了134这三个集合，那么我们就把134转化为131进制，即1  131^2+3  131+4，在实际操作时，就是每一个集合的下标k作为对应的位数，则每一个点的表示可以是这样的：

这样我们就计算出了每一个点的唯一标识，含有相同标识的才能算是同一个点。（这里选择质数是为了防止哈希碰撞，即不同状态的得到了相同的标记；选择mod是防止溢出）
最后只要统计一下标识的个数就行了（可以用set实现）代码实现：对于简单版本，暴力完全够用了。
#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define endl &#x27;\n&#x27;const ll P=131,mod=1e9+7;int main()&#123;    ll n,z=1,a[1010]; cin&gt;&gt;n;    for(int i=0;i&lt;=1000;i++) a[i]=0;    while(n--)&#123;        ll l,r; cin&gt;&gt;l&gt;&gt;r;        for(int i=l;i&lt;=r;i++)&#123;            a[i]=(a[i]+z)%mod;        &#125;        z=(z*P)%mod;    &#125;    set&lt;ll&gt; q;    for(int i=0;i&lt;=1000;i++)&#123;        q.insert(a[i]);    &#125;    cout&lt;&lt;q.size()&lt;&lt;endl;&#125;
所以这样我们就解决了简单版本。
复杂版本：那么对于数据量大的复杂版本呢？
这里我们依然采用hash，但是由于数据量大，为了防止冲突，我们给每一个区间都分配一个随机hash值，在计算时只考虑起点和终点，在进入起点时加入标记，离开时移除标记。这时我们就想到了具有可逆性质的异或，我们只要给对应的起终点打上相同标记就行了，最后还是用set统计产生的不同标记数
参考代码：#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ULL unsigned long long#define endl &#x27;\n&#x27;int main()&#123;    ll n; cin&gt;&gt;n;    vector&lt;pair&lt;ll,int&gt;&gt; box;    for (int i=0;i&lt;n;i++)&#123;        ll l,r; cin&gt;&gt;l&gt;&gt;r;        box.push_back(&#123;l,i&#125;);        box.push_back(&#123;r+1,i&#125;);    &#125;    sort(box.begin(),box.end());    vector&lt;unsigned long long&gt; h(n);    mt19937_64 rng(time(0));    for(int i=0;i&lt;n;i++)&#123;        h[i]=rng();    &#125;    set&lt;ULL&gt; s; s.insert(0);    ULL cur=0;ll last=-2e9;    for(auto&amp; i:box)&#123;        ll pos=i.first,idx=i.second;        if(pos&gt;last&amp;&amp;last!=-2e9) s.insert(cur);        cur^=h[idx];        last=pos;    &#125;    s.insert(cur);    cout&lt;&lt;s.size()&lt;&lt;endl;&#125;
```yaml                     感谢观看！关注ZestfulYK喵，谢谢喵！
]]></content>
      <tags>
        <tag>算法挑战赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title>算法挑战赛题解</title>
    <url>/ZestfulYK-blog/2025/11/20/2/</url>
    <content><![CDATA[算法挑战赛第二期题解题目
二进制小数的乘积~HC哥哥说这个很困！难！

Description



HC哥哥今天又突发奇想，它依然定义一个数字为二进制小数，如果它是一个正整数，并且其十进制表示中的所有数字都是0或1。例如，110 是一个二进制小数，而 102 和 787 不是。
现在HC哥哥给定你一个数 n，你被要求判断是否可能将 n 表示为一些（不一定是不同的）二进制小数的乘积。


Input


第一行包含一个整数 t（1≤t≤5⋅10^4）— 测试用例的数量。
每个测试用例的唯一一行包含一个整数 n（1≤n≤10^5）。


Output


对于每个测试用例，如果 n 可以表示为一些二进制小数的乘积，则输出 “YES”（不带引号），否则输出 “NO”（不带引号）。


题目解释 （翻译成人话）

计算把01串强制转换为整数，再相乘得到的数就是合法的数字，其余都是不合法的。那么直接打表就行了，总共1e5个数，打表还是很容易实现的
接下来我们来学习一下该怎么打表
打表
定义 : 计算出所有情况，然后直接判断。

比如问你100以内的数是否是质数，你肯定能直接回答，因为你已经把100以内的质数全部背下来了。这其实就是打表的一种体现，你提前计算前100内的数是否是质数，然后直接调用答案。
但是我们的计算机实际上并不知道一个问题的所有解，那么你自己提前算好告诉它不就彳亍了吗。
这时我们需要两个重要程序：打表程序和判断程序。
打表程序
用于计算所有情况的答案，不用关心时间复杂度，反正是提前计算

比如计算素数集，你直接暴力就好了，不会欧拉筛又有什么关系呢？
判断程序
用于直接获得答案的程序，时间复杂度O(n),n为数据规模，每次查询的时间复杂度为O(1)。

接下来就该思考怎么写一个无脑的程序来计算这些情况了
做法
首先先写一个无脑程序生成所有01组合的数vector&lt;ll&gt; ans;int main()&#123;    for(int i=1;i&lt;=100000;i++)&#123;        ll x=i,cnt=0,w=0;        while(x)&#123;            if(x%10&lt;2) cnt++;            w++;            x/=10;        &#125;        if(cnt==w) ans.push_back(i);    &#125;    for(auto &amp;i:ans)        cout&lt;&lt;i&lt;&lt;&quot;,&quot;;&#125;



此处是对每一位进行判断，如果01的个数和位数一样，那么就是一个合法的数字


得到如下结果：
1,10,11,100,101,110,111,1000,1001,1010,1011,1100,1101,1110,1111,10000,10001,10010,10011,10100,10101,10110,10111,11000,11001,11010,11011,11100,11101,11110,11111,100000

把以上结果复制进下一段生成代码，然后再计算所有合法的数字
ll number[1010]=&#123;0,1,10,11,100,101,110,111,1000,1001,    1010,1011,1100,1101,1110,1111,10000,10001    ,10010,10011,10100,10101,10110,10111,11000    ,11001,11010,11011,11100,11101,11110,11111,100000&#125;;set&lt;ll&gt; s;ll dfs(ll n)&#123;    s.insert(n);    for(int i=2;i&lt;=32;i++)&#123;        if(n*number[i]&lt;=100000)           dfs(n*number[i]);    &#125;    return 0;&#125;signed main()&#123;    dfs(1);    ll cnt=0;    for(auto &amp;i:s)&#123;        cout&lt;&lt;i&lt;&lt;&quot;,&quot;;        cnt++;    &#125;    cout&lt;&lt;endl&lt;&lt;cnt&lt;&lt;endl;    return 0;&#125;



此处使用了dfs(Deep First Search)，文末会有详细介绍


得到如下结果：
1,10,11,100,101,110,111,121,1000,1001,1010,1011,1100,1101,1110,1111,1210,1221,1331,10000,10001,10010,10011,10100,10101,10110,10111,10201,11000,11001,11010,11011,11100,11101,11110,11111,11121,11211,12100,12111,12210,12221,12321,13310,13431,14641,100000

最后再是无脑的判断程序：
vector&lt;string&gt; ans;ll a[1010]=&#123;0,1,10,11,100,101,110,111,121,1000,1001,1010,1011,1100,1101,    1110,1111,1210,1221,1331,10000,10001,10010,10011,10100,10101,10110,    10111,10201,11000,11001,11010,11011,11100,11101,11110,11111,11121,    11211,12100,12111,12210,12221,12321,13310,13431,14641,100000&#125;;void solve()&#123;    ll x; cin&gt;&gt;x;    for(int i=1;i&lt;=47;i++)&#123;        if(a[i]==x)&#123;            ans.push_back(&quot;YES&quot;);            return;        &#125;    &#125;    ans.push_back(&quot;NO&quot;);&#125;int main()&#123;    ll T; cin&gt;&gt;T;    while(T--) solve();    for(auto &amp;i:ans)        cout&lt;&lt;i&lt;&lt;endl;&#125;


不是我说，这种做法在打表题目是真轮椅吧，时间复杂度完全没影响，计算出来总共就47个数字，简单版甚至20个都没到，非常适合不会搜索的蒻蒟(比如我)学习和理解。
下面是对dfs(Deep First Search)算法的详细介绍：
什么是dfs？dfs是深度优先搜索的英文缩写，以深度为优先来进行计算

比如，要计算走n级楼梯（每次一到两级台阶）有几种走法，就可以使用dfs，假设第一次先走一步，依次遍历，如果能刚好走到n则方法数加1，如果超过了n则返回到上一步，回头找下一个方法。

在本题的应用

那么在这题，我们已经提前计算了所有合法的数字，我们每次乘上可能的数字，看看是否依旧合法，之后在超过1e5时返回，相当于楼梯数为1e5，每次可以走number[1….n]步，但是每一个小于n的位置都合法，并存储答案。
如果想进一步了解dfs，可以访问OIwiki进行学习！
那么本期的题解就到此结束了，感谢阅读！如果想交流算法题，也可以添加我的qq哦(717056060)
关注ZestfulYK，谢谢喵！]]></content>
      <tags>
        <tag>算法挑战赛题解</tag>
      </tags>
  </entry>
  <entry>
    <title>Abel公式</title>
    <url>/ZestfulYK-blog/2025/02/12/Abel%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[公式S=\sum_{i=1}^{m}a_ib_i=a_mB_m-\sum_{i-1}^{m-1}(a_{i+1}-a_i)B_i]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++几何计算(保姆级教程)</title>
    <url>/ZestfulYK-blog/2025/12/23/C++%E5%87%A0%E4%BD%95%E8%AE%A1%E7%AE%97(%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%95%99%E7%A8%8B)/</url>
    <content><![CDATA[版权说明此文章的所有代码均由qinye_leaf 勤叶大佬收集整理，感谢喵Orz Orz Orz
初始化由于双精度和单精度存在精度问题，所以补能直接判断是否为0或者相等，那么怎么办呢？我们可以取绝对值，然后和一个非常小的数字比较
代码示例：// 浮点数精度阈值(根据题目要求调整，通常1e-8)const double EPS = 1e-8;
符号函数判断正负号的函数，但是是浮点数数版本的
// 符号函数：判断浮点数正负int sgn(double x) &#123;    if (fabs(x) &lt; EPS) return 0;    return x &gt; 0 ? 1 : -1;&#125;
构造函数介绍解释一下构造函数的用法，这里可以直接赋初始值，方便初始化
Point(double x_ = 0, double y_ = 0) : x(x_), y(y_) &#123;&#125;//那么我们可以这么来定义一个变量Point p1(2.0,3.0);Point p2;
如果不传参数，那么就是直接得到初始值0,0,要是有值的化就是直接赋值，这样就避免了先定义再赋值的痛点。
点点的定义点的定义我们使用结构体struct和重载操作符定义点的操作，这样我们就能直接计算两个点构成的向量这里面最重要的是加减，但是既然定义了那么就完整定义
// 点/向量结构体（二维）struct Point &#123;    double x, y;    // 构造函数    Point(double x_ = 0, double y_ = 0) : x(x_), y(y_) &#123;&#125;    // 向量运算重载（核心）    // 向量加法    Point operator+ (const Point&amp; other) const &#123;        return Point(x + other.x, y + other.y);    &#125;    // 向量减法    Point operator- (const Point&amp; other) const &#123;        return Point(x - other.x, y - other.y);    &#125;    // 向量数乘（缩放）    Point operator* (double k) const &#123;        return Point(x * k, y * k);    &#125;    // 向量数除    Point operator/ (double k) const &#123;        return Point(x / k, y / k);    &#125;    // 浮点数相等判断（带精度）    bool operator== (const Point&amp; other) const &#123;        return sgn(x - other.x) == 0 &amp;&amp; sgn(y - other.y) == 0;    &#125;&#125;;
两点间的距离根据上面的定义，相减以后得到向量，然后再套用下面的向量长度计算公式
// 两点间距离double dist(const Point&amp; a, const Point&amp; b) &#123;    return len(a - b);&#125;
线段只要这两个变量就能确定一个线段，所以存点
// 线段结构体struct Segment &#123;    Point a, b; // 线段端点    Segment() &#123;&#125;    Segment(Point a_, Point b_) : a(a_), b(b_) &#123;&#125;&#125;;
线段的旋转这里的化，先转化为极坐标，得到：设$\vec a$和x轴的夹角为$\alpha$,所以$a=(x,y)=(r\cos\alpha,r\sin\alpha)$旋转后得到$a’=(r\cos(\alpha+\theta),r\sin(\alpha+\theta))$展开得到$a’=(r\cos(\alpha)\cos(\theta) - r\sin(\alpha)\sin(\theta), r\sin(\alpha)\cos(\theta) + r\cos(\alpha)\sin(\theta)$带回坐标就得到公式了。如果是原点，直接计算，如果不是，那么先平移一下再计算
// 向量a绕原点旋转rad弧度(逆时针为正，顺时针为负)Point rotate(const Point&amp; a, double rad) &#123;    double c = cos(rad), s = sin(rad);    return Point(a.x * c - a.y * s, a.x * s + a.y * c);&#125;// 向量a绕点p旋转rad弧度Point rotate_point(const Point&amp; a, const Point&amp; p, double rad) &#123;    return rotate(a - p, rad) + p;&#125;
用处的化，要是一个几何图形，你一个一个转过去，最后再连起来，就是旋转后的图形了
圆需要圆心和半径
// 圆结构体struct Circle &#123;    Point o; // 圆心    double r; // 半径    Circle() &#123;&#125;    Circle(Point o_, double r_) : o(o_), r(r_) &#123;&#125;&#125;;
向量的计算向量点乘这里直接用Point来代替向量了，但是实际上差不多,不过是先处理一下而已。
// 向量点乘(a·b)double dot(const Point&amp; a, const Point&amp; b) &#123;    return a.x * b.x + a.y * b.y;&#125;
用途：计算向量夹角、投影长度、判断向量垂直；公式：$\vec a · \vec b = |\vec a||\vec b|\cos(\theta)$   ($\theta$为两向量的夹角)
向量的单位化计算$\frac{\vec a}{|\vec a|}$
// 向量单位化(避免零向量)Point normalize(const Point&amp; a) &#123;    double l = len(a);    if (sgn(l) == 0) return Point(0, 0);    return a / l;&#125;
求向量的模长和单纯平方计算$|\vec a|$和$|\vec a|^2$
//点乘延伸:// 向量的模长(长度)平方,(避免开根号，提升效率)double len2(const Point&amp; a) &#123;    return dot(a, a);&#125;// 向量的模长(长度)double len(const Point&amp; a) &#123;    return sqrt(len2(a));&#125;
求$\vec a$在$\vec b$上的投影向量公式 :
\frac{\vec a ·\vec b}{|\vec b|}double proj_len(const Point&amp; a, const Point&amp; b) &#123;    return b * ( dot(a, b) / len2(b) );&#125;
求$\vec a$在$\vec b$上的投影向量的模长// 向量投影长度：向量a在向量b上的投影长度 ( projection length（投影长度）)double proj_len(const Point&amp; a, const Point&amp; b) &#123;    return dot(a, b) / len(b);&#125;
判断向量是否垂直这个很好理解，因为\vec a·\vec b=0\iff\vec a\perp\vec b// 判断两向量垂直bool is_vertical(const Point&amp; a, const Point&amp; b) &#123;    return sgn(dot(a, b)) == 0;&#125;
向量的叉乘叉乘的定义首先叉乘的定义是什么说实话我也不知道该怎么解释，反正知道它的性质就能计算了
计算方式\vec a\times \vec b=x_1*y_2-y_1*x_2// 向量叉乘(a×b)double cross(const Point&amp; a, const Point&amp; b) &#123;    return a.x * b.y - a.y * b.x;&#125;
长度(模长)\vec a\times \vec b=|\vec a||\vec b|\sin叉乘的性质方向的表示根据我的理解叉乘的符号，表示了$\vec a$到$\vec b$的方向变化方式从a到b：即$\vec a\times \vec b$如果是正的，那么是逆时针转的如果是负的，那么是顺时针转的
此处的额外要求是把向量的起点放到同一个位置，不过实际上你会发现把向量头尾衔接起来貌似更好理解。下面我都会详细讲解的，保证记住示例：顺时针(对应负)从a到b
         b        ^        |        |a&lt;-------
逆时针(对应正)从a到b
 b^||-------&gt;a
但是直接记结论貌似不简单？那么试试我的理解方式
首先先把向量整成头尾相接的形式，如下：
b^ \  \   \    ^a    |    |    |
然后拿出你的右手，手心向着左边，手掌的走向和a一致，手指的走向和b一致，那么再看看你的大拇指是什么方向呢？朝上对不对？所以是正的。那么我们就记住了正对应逆时针。易如反掌实际操作时，只要摆对手心和手指的方向就彳亍了，你总不会把手指掰到反面吧 (找到舒服的那一侧就是正确的摆法，总之重要的还是记住方向和正负号的关系。
下面给出代码：
// 判断向量a是否在向量b的顺时针方向bool is_clockwise(const Point&amp; a, const Point&amp; b) &#123;    return sgn(cross(a, b)) &lt; 0;&#125;// 判断向量a是否在向量b的逆时针方向bool is_counter_clockwise(const Point&amp; a, const Point&amp; b) &#123;    return sgn(cross(a, b)) &gt; 0;&#125;//直接使用的话是这样的:// 判断向量b相对于向量a的方向double val = cross(a, b);if (val &gt; 0) &#123;    // b在a的逆时针方向&#125; else if (val &lt; 0) &#123;    // b在a的顺时针方向&#125; else &#123;    // a和b共线(同向或反向)&#125;
所以下面我们就可以延申到对点和直线关系的判断上了
首先我们判断点和直线关系的本质还是看顺逆时针的变化，构造一条直线，连接向量的尾和这个点，看顺逆时针的变化，所以代码就很理解了
值得注意的是，这里是相对向量的方向而言的，主要作用是为后面点和多边形关系做铺垫
// 判断点c在直线ab的左侧/右侧/线上// 返回值：&gt;0 左侧，&lt;0 右侧，=0 线上int point_line_side(const Point&amp; a, const Point&amp; b, const Point&amp; c) &#123;    return sgn(cross(b - a, c - a));//注意顺序&#125;
和面积的关系因为叉乘的模长定义为了
\vec a\times \vec b=|\vec a||\vec b|\sin也就是
2*\frac{1}{2}|\vec a||\vec b|\sin那么就是这三个顶点构成的三角形面积的两倍，或者说，是向量构成的平行四边形的面积
于是我们的三角形的计算公式就有了，下面给出对应的代码
// 三点构成的三角形面积(绝对值/2)double triangle_area(const Point&amp; a, const Point&amp; b, const Point&amp; c) &#123;    return fabs(cross(b - a, c - a)) / 2.0;&#125;
四边形的计算方法如下：因为我们只要两个向量就彳亍了，这里选择的是$\vec {AB}$和$\vec {AD}$，
// 四点构成的四边形面积（平行四边形）double parallelogram_area(const Point&amp; a, const Point&amp; b, const Point&amp; d) &#123;    return fabs(cross(b - a, d - a));&#125;
叉乘的运算规律加法的左分配律
a\times(b+c)=a\times b+a\times c加法的右分配律
(a+b)\times c=a\times c+b\times c标量乘法
(\lambda a)\times b=\lambda(a\times b)=a\times(\lambda b)计算点到直线的距离因为能表示面积，所以能拿来计算距离，具体的推导如下：
\vec a\times \vec b=|\vec a||\vec b|\sin=h_1*|\vec a|=h_2*|\vec b|所以计算点到直线的距离也可以这么来拆分：首先画出三角形，计算这个三角形的面积，然后乘2再除以AB的长度，化简一下就是：
d=\frac{\vec{AP}\times\vec{AB}}{|\vec{AB}|}// 点p到直线ab的距离double point_line_dist(const Point&amp; a, const Point&amp; b, const Point&amp; p) &#123;    return fabs(cross(b - a, p - a)) / len(b - a);&#125;
那么有人会问了，要是是线段怎么办？其实差不多
// 点p到线段ab的距离double point_segment_dist(const Point&amp; a, const Point&amp; b, const Point&amp; p) &#123;    if (a == b) return dist(a, p); // 线段退化为点    // 投影参数t：判断垂足是否在线段上    double t = proj_len(p - a, b - a);    if (sgn(t) &lt;= 0) return dist(p, a); // 垂足在a外侧    if (sgn(t - len(b - a)) &gt;= 0) return dist(p, b); // 垂足在b外侧    return point_line_dist(a, b, p); // 垂足在线段内，返回点到直线距离&#125;
计算点在线段上的垂足首先先计算一下投影向量，然后加上起点a就彳亍啦
// 计算点p在直线ab上的垂足Point foot_point(const Point&amp; a, const Point&amp; b, const Point&amp; p) &#123;    Point ab = b - a;    double t = dot(p - a, ab) / len2(ab); // 投影参数t(归一化)    return a + ab * t;&#125;
判断点是否在线段上这里有两个要求，首先p得在这条线上，可以通过计算$\vec {AP}$和$\vec {BP}$的叉乘得到，叉乘必须为0；其次，需要两个向量方向相反，那么点乘为负。
// 判断点p是否在线段ab上（含端点）bool point_on_segment(const Point&amp; a, const Point&amp; b, const Point&amp; p) &#123;    // 1. p在直线ab上；2. p的坐标在a和b之间    return sgn(cross(b - a, p - a)) == 0 &amp;&amp; sgn(dot(p - a, p - b)) &lt;= 0;&#125;
判断两直线是否相交这里我们引入一下包围盒的概念，包围盒的意思是能吧图形包围进去的最小的矩阵，且这个矩阵的边界得和坐标轴平行。
例如：-----B|   /||  / || /  ||/   |A-----
上面这个就是AB的包围盒
那么有什么用呢？要是包围盒都不相交，那么一定不相交
所以代码如下：
// 快速排斥：判断两线段的包围盒是否相交bool rect_intersect(const Point&amp; a1, const Point&amp; a2, const Point&amp; b1, const Point&amp; b2) &#123;    double min_x1 = min(a1.x, a2.x), max_x1 = max(a1.x, a2.x);    double min_y1 = min(a1.y, a2.y), max_y1 = max(a1.y, a2.y);    double min_x2 = min(b1.x, b2.x), max_x2 = max(b1.x, b2.x);    double min_y2 = min(b1.y, b2.y), max_y2 = max(b1.y, b2.y);    return max_x1 &gt;= min_x2 - EPS &amp;&amp; max_x2 &gt;= min_x1 - EPS        &amp;&amp; max_y1 &gt;= min_y2 - EPS &amp;&amp; max_y2 &gt;= min_y1 - EPS;&#125;
要是严格判定的话，需要用叉乘，实际上，保证A，B在CD异侧就彳亍了要是线段AB相交于直线CD的话，那么AC，CD的叉积符号必然和BC，CD的符号相反
这样得到的图实际上可能是这样的：
      C     ^|^    / | \   /  v  \  /   D   \ /         \A-----------B
那么我们就发现了，AC到CD和BC到CD的方向一定是不一样的，但是不适用与线段的情况
// 跨立实验：判断线段ab是否跨立直线cdbool cross_stand(const Point&amp; a, const Point&amp; b, const Point&amp; c, const Point&amp; d) &#123;    return sgn(cross(d - c, a - c)) * sgn(cross(d - c, b - c)) &lt;= 0;&#125;
但是要是都是线段的话，还要保证C，D在AB异侧，所以代码：也就是保证CD和AB也有类似的关系，那么化工图发现这样的一定相交
// 判断两线段是否相交（含端点）bool segment_intersect(const Segment&amp; s1, const Segment&amp; s2) &#123;    Point a = s1.a, b = s1.b, c = s2.a, d = s2.b;    // 快速排斥    if (!rect_intersect(a, b, c, d)) return false;    // 跨立实验(双向)    return cross_stand(a, b, c, d) &amp;&amp; cross_stand(c, d, a, b);&#125;
求直线或者线段的交点首先先保证相交再来计算
建议在使用函数之前先调用一下上面的相交函数
下面是交点函数的证明：
             A            /|           / |h1C---------E---------------D    h2|  /      | /      |/      B
我们先计算A和B分别到CD的距离，记作$h_1\text{和} h_2$那么先相似一下，然后再比例得到E的坐标
E=\frac{h_1}{h_1+h_2}\times\vec{AB}+A然后，前面刚讲过，高可以由面积得到，那么直接用叉乘代替高就得到计算公式了设$s_1=\vec{CD}\times\vec{CA},s_2=\vec{CD}\times\vec{CB}$由于符号相反，所以可以这么写：
E=\frac{s_1}{s_1-s_2}\times\vec{AB}+A但是上面考虑的时AB在CD的异侧时的情况那么我们来考虑一下如果AB在CD的同侧该怎么计算
	             A	            /|	           / |h1		      /  |	         B   |	         |   |	         |h2 |C---------E---------------D    
我们用叉乘的话可以发现，叉乘符号相同，那么发现公式还是上面那个，统一一下，所以代码写起来就简单了然后我们把点带入得到：
E=\frac{s_1}{s_1-s_2}\times(B-A)+A=\frac{B*s_1-A*s_2}{s_1-s_2}// 计算两直线ab和cd的交点（需保证直线不平行）Point line_intersect(const Point&amp; a, const Point&amp; b, const Point&amp; c, const Point&amp; d) &#123;    double s1 = cross(d - c, a - c);    double s2 = cross(d - c, b - c);    return (a * s2 - b * s1) / (s2 - s1);&#125;
线段的话，可以先算出交点，然后判断交点是不是在线段上
// 计算两线段的交点（仅当相交时返回有效点）Point segment_intersect_point(const Segment&amp; s1, const Segment&amp; s2) &#123;    return line_intersect(s1.a, s1.b, s2.a, s2.b);&#125;
圆相关的计算判断点和圆的关系为了保证精度，所以采用平方
// 判断点p与圆c的位置：&gt;0 圆外，=0 圆上，&lt;0 圆内int point_circle_relation(const Point&amp; p, const Circle&amp; c) &#123;    double d2 = len2(p - c.o); // 距离平方(避免开根号)    double r2 = c.r * c.r;    return sgn(d2 - r2);&#125;
点到圆的切线长度这个很好理解，就是勾股定理
// 点p到圆c的切线长度double tangent_len(const Point&amp; p, const Circle&amp; c) &#123;    double d = dist(p, c.o);    if (sgn(d - c.r) &lt;= 0) return 0.0; // 点在圆内/圆上，无切线    return sqrt(d * d - c.r * c.r);&#125;
求直线与圆的交点首先先计算垂足，判断交点个数的情况，要是有两个交点的话，计算方式是，垂足+垂足到交点的距离乘上直线AB的单位向量
// 计算直线ab与圆c的交点（返回交点列表）vector&lt;Point&gt; line_circle_intersect(const Point&amp; a, const Point&amp; b, const Circle&amp; c) &#123;    vector&lt;Point&gt; res;    Point foot = foot_point(a, b, c.o); // 圆心到直线的垂足    double d = point_line_dist(a, b, c.o); // 圆心到直线的距离    if (sgn(d - c.r) &gt; 0) return res; // 无交点    if (sgn(d - c.r) == 0) &#123; // 相切，一个交点        res.push_back(foot);        return res;    &#125;    // 相交，两个交点：垂足向两侧移动 len = sqrt(r² - d²)    double Len = sqrt(c.r * c.r - d * d);    Point dir = (b - a) / len(b - a); // 直线方向单位向量    res.push_back(foot + dir * Len);    res.push_back(foot - dir * Len);    return res;&#125;
线段与圆的交点首先先算直线和圆的交点，然后再判断这个点是否在线段上
// 计算线段ab与圆c的交点（返回交点列表）vector&lt;Point&gt; segment_circle_intersect(const Point&amp; a, const Point&amp; b, const Circle&amp; c) &#123;    vector&lt;Point&gt; res, line_inter = line_circle_intersect(a, b, c);    // 筛选交点是否在线段上    for (auto&amp; p : line_inter) &#123;        if (point_on_segment(a, b, p)) &#123;            res.push_back(p);        &#125;    &#125;    return res;&#125;
多边形的计算多边形的面积计算这个由于我们已经有了一个很好的工具，叉乘，那么我们划分一下面积再计算比较好理解的方法是，以$P_0$为每个三角形的顶点，依次计算，所以公式
\frac{1}{2}\sum_{i=1}^n(P_i-P_0)\times(P_{i+1}-P_0)但是注意到我们的叉乘具有向量加法的左右分配律，所以展开上面这个式子
\begin{split}
&\ \ \ \ \ \frac{1}{2}\sum_{i=1}^nP_i\times P_{i+1}-P_i\times P_0-P_0\times P_{i+1}+P_0\times P_0\\
&=\frac{1}{2}\sum_{i=1}^nP_i\times P_{i+1}
\end{split}首先$P0\times P_0$一定是等于0的，其次，因为所有点都遍历了，那么$\sum{i=1}^nPi\times P_0=-\sum{i=1}^nP0\times P{i+1}$相当于只是后移了一位，但是结果一样，所以直接遍历点的叉乘就可以计算了。
// 计算多边形面积（顶点数组，闭合：最后一个点无需等于第一个）double polygon_area(const vector&lt;Point&gt;&amp; poly) &#123;    int n = poly.size();    double area = 0.0;    for (int i = 0; i &lt; n; i++) &#123;        int j = (i + 1) % n;        area += cross(poly[i], poly[j]);    &#125;    return fabs(area) / 2.0;&#125;
判断点是否在多边形内部首先做一条射线，向右射出，计算这条射线和多边形的交点数量，奇数则在内部，偶数则在外部
// 判断点p是否在多边形poly内（含边界）bool point_in_polygon(const Point&amp; p, const vector&lt;Point&gt;&amp; poly) &#123;    int n = poly.size();    int cnt = 0;    for (int i = 0; i &lt; n; i++) &#123;        Point a = poly[i], b = poly[(i + 1) % n];        if (point_on_segment(a, b, p)) return true; // 在边界上        // 射线法：判断射线与线段是否相交        if (sgn(a.y - p.y) &gt; sgn(b.y - p.y)) swap(a, b);        if (sgn(b.y - p.y) &lt;= 0) continue;        if (sgn(cross(b - a, p - a)) &gt; 0) cnt++;    &#125;    return cnt % 2 == 1; // 奇数：内部，偶数：外部&#125;
感谢看完这篇文章！要是有什么想法或者建议，欢迎来交流讨论！
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>DP(01)最长不下降子序列及其变种</title>
    <url>/ZestfulYK-blog/2025/02/12/DP(01)%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97%E5%8F%8A%E5%85%B6%E5%8F%98%E7%A7%8D/</url>
    <content><![CDATA[变种一就是01串,方法在下面,懒得解释了,自己看注释吧题目:问最少能把01串划成几个0101…类型的字符串//关键点,类似最长不下降子序列的题目,但是由于是01串,只要管有几个0结尾和1结尾的串就好了ll c0=0,c1=0;for(int i=0;i&lt;t.length();i++)&#123;   if(t[i]==&#x27;1&#x27;)&#123;     if(c0) c0--;//接到0结尾的后面     c1++;//多了一个以1结尾的串   &#125;   else&#123;     if(c1) c1--;//接到1结尾的后面     c0++;//多了一个以0结尾的串   &#125; &#125; return c0+c1;
变种二是有有限个结尾的dp
例如牛客周赛题目:把字符串变成相邻字母的ASCALL码之差都一样,求最小操作次数
因为只有26个字母,所以可以直接滚动数组+dp,然后设dp[i][j]表示以第i位结尾改成char(&#39;a&#39;+j)的最少修改次数,或者也可以设成改为char(&#39;a&#39;+j)后最长的连续长度
最后结论就是模拟26种d(实则只用13种),然后公式中每次只要上面的两个状态就行
dp[i][j]=max(dp[i-1][(j-d+26)%26],dp[i-1][(j+d+26)%26])+(s[i]==char(&#x27;a&#x27;+j)?0:1);//设修改次数dp[i][j]=max(dp[i-1][(j-d+26)%26],dp[i-1][(j+d+26)%26])+(s[i]==char(&#x27;a&#x27;+j)?1:0);//设合法长度
又例如div3C:C. Dice Roll Sequence
这题是把一串1-6的数字串改成任意相邻两个数字都和不为7
方法也是如上,要么设修改次数要么设合法长度,我写的还是修改次数
for(int now=1;now&lt;=6;now++)&#123;  for(int last=1;last&lt;=6;last++)&#123;    if(now!=last&amp;&amp;now+last!=7)&#123;      if(now==a[i]) now_dp[now]=min(now_dp[now],dp[last]);      else now_dp[now]=min(now_dp[now],dp[last]+1);    &#125;  &#125;&#125;
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>DP习题笔记-二进制拆分</title>
    <url>/ZestfulYK-blog/2025/02/24/DP%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B0-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[题目描述给定一个非负整数 $n(0\leq n \leq 10^7)$，求有多少个长为 30 的非负整数序列 a ,满足 $\sum_{i=0}^{29}2^i*a_i=n$由于答案可能很大，请将结果对 998244353 取模后再输出。
解法看到题目，第一反应就是一个完全背包的动态规划题目，所以直接打表解决，不过发现超时了，那么怎么办呢？
输出前30个数得到如下结果：1 2 2 4 4 6 6 10 10 14 14 20 20 26 26 36 36 46 46 60 60 74 74 94 94 114 114 140 140 166观察得到，每两个数是一样的，如果去重的话得到：
1 2 4 6 10 14 20 26 36 46 60
每一次的差正好都在前面出现过且这个差的位置刚好是n/2，那么可以得到递推式子：$$\begin{cases}dp[i]=dp[i-1]\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \text{i为奇数}\dp[i]=dp[i-1]+dp[i/2]\ \ \ \ \ \ \text{i为偶数}\end{cases}
$$但是为什么这个递推式子是正确的呢？
实际上可以这么理解：
当n为奇数时，实际上就是在偶数的基础上加上了1，所以方法数和偶数时一样的当n为偶数时，分两种情况：含有至少一个1的方法和不含有1的方法含有一个1的方法是必然都是奇数的情况转移而来的，因为要在奇数的基础上加上一个1，不含1的情况实际上就是把方案里的数全部乘以2，因此要看n/2的答案。
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>DP习题笔记</title>
    <url>/ZestfulYK-blog/2025/12/16/DP%E4%B9%A0%E9%A2%98%E7%AC%94%E8%AE%B01(%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%BC%95%E5%85%A5)/</url>
    <content><![CDATA[循环的遍历
注意一下最内层的循环是什么，他决定了这一步的决策是什么。

例题纸币问题 2

这一题要我们求完全背包的方案数（考虑顺序）
那么内层循环应该放的是面额的遍历，因为最后一步的面额是不一定的。
正确写法✔：
for(int i=1;i&lt;=w;i++)   for(int j=1;j&lt;=n;j++)      if(i&gt;=a[j])        dp[i]=(dp[i-a[j]]+dp[i])%mod;

错误写法❌：
for(int i=1;i&lt;=n;i++)&#123;    ll x; cin&gt;&gt;x;    for(int j=x;j&lt;=w;j++)&#123;        dp[j]=(dp[j-x]+dp[j])%mod;    &#125;&#125;
为什么下面那个是错误的？
因为把当前面额作为内层循环，相当于固定了最后一步只能是这个面额，没法考虑到顺序问题。这样的话第二次只能在第一次的基础上增加。实际上，第一次的面额也可以在第二次的基础上增加。因此这个做法是不正确的。注意：下面那个方法因为只考虑了最开始的顺序(即输入顺序)，所以只有一种顺序，那么就可以拿来统计组合数

在解决这类问题时，关键要问自己：

题目要求的是组合数还是排列数？
我的循环顺序是否允许不同的支付顺序？
我是否在无意中强加了某种顺序限制？(关键点)对于这道题，既然要求考虑支付顺序，就必须使用金额在外层的循环方式。

特殊例题计算容积不超过n得到的最大的占有体积
思路：设$dp[i]$表示不超过i获得的最大值，那么每一个物品的体积是x，价值也是x。
状态转移方程：dp[i]=max(dp[i],dp[i-x]+x)例题

考前临时抱佛脚 - 洛谷

题目说可以双核，那么只要一边最接近sum/2就彳亍了，所以可以用上面那个模型
01背包0也有值的问题
在正常的01背包中，如果遍历不到就不管了，但是现在要求不能放入时也有一定的值，那么这时就要管了，在体积不够时，每一个都只有一种选法，那就是不选。所以每一个都要加上不选所对应的值。
例题：

5 倍经验日 - 洛谷

题目说了在打不过时也能得到经验，你要是不给玩家经验，当然是不对的啦

DP的一般思路
首先看看是否是背包或者背包的变形，要是是的话就简单了
看一下每一次有几种转移方式，把可能的变化列一下，看看是否有规律
在这一讲还是不用区分特殊类型的DP的

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++模板</title>
    <url>/ZestfulYK-blog/2026/01/23/C-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[说明这些是我平时攒下来的模板,现在送给大家!
火车头#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;array&gt;#include &lt;unordered_map&gt;#include &lt;numeric&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;chrono&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define ll long long#define int ll#define i128 __int128#define ld long double#define pb push_back#define fs first#define sd second#define all(a) a.begin(),a.end()#define rall(a) a.rbegin(),a.rend()#define debug(a) cout&lt;&lt;a&lt;&lt;&quot; &quot;;#define endl &#x27;\n&#x27;mt19937 rnd(time(nullptr));ll lowerbit(ll x)&#123;return x&amp;(-x);&#125;ll binary_min_palce(ll x)&#123;return(__builtin_ctz(x));&#125;//返回二进制最后有几个0ll gcd(ll a,ll b)&#123;return b==0?a:gcd(b,a%b);&#125;void rad(ll h[],ll maxn,ll minn,ll n)&#123;default_random_engine e(time(0));uniform_int_distribution&lt;int&gt; u(minn,maxn);for(int i=1;i&lt;=n;i++)h[i]=u(e);&#125;template&lt;typename T&gt;void fast_erase(vector&lt;T&gt;&amp; container,typename std::vector&lt;T&gt;::size_type index)&#123;if(index&gt;=container.size()) return;if(index!=container.size()-1)container[index]=move(container.back());container.pop_back();&#125;inline void read128(__int128&amp;x)&#123;x=0;__int128 f=1;char ch=getchar();while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;)&#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;)&#123;x=x*10+ch-&#x27;0&#x27;;ch =getchar();&#125;&#125;void print128(__int128 x)&#123;if(x&lt;0)&#123;putchar(&#x27;-&#x27;);x=-x;&#125;if(x&gt;9)print128(x/10);putchar(x%10+&#x27;0&#x27;);&#125;const ll inf=1e9+1;const ll mod=998244353;const ld pi=atan2(0,-1);const ld eps=1e-6;
水印/*0.注意vector的size是size_t不能直接减去一个数，要类型转换1.深呼吸，不要紧张，慢慢读题，读明白题，题目往往比你想的简单。2.暴力枚举:枚举什么，是否可以使用一些技巧加快枚举速度（预处理、前缀和、数据结构、数论分块）。3.贪心:需要排序或使用数据结构（pq）吗，这么贪心一定最优吗。4.二分：满足单调性吗，怎么二分，如何确定二分函数返回值是什么。5.位运算：按位贪心，还是与位运算本身的性质有关。6.数学题：和最大公因数、质因子、取模是否有关。7.dp：怎么设计状态，状态转移方程是什么，初态是什么，使用循环还是记搜转移。8.搜索：dfs 还是 bfs ，搜索的时候状态是什么，需要记忆化吗。9.树上问题：是树形dp、树上贪心、或者是在树上搜索。10.图论：依靠什么样的关系建图，是求环统计结果还是最短路。11.组合数学：有几种值，每种值如何被组成，容斥关系是什么。12.交互题：log(n)次如何二分，2*n 次如何通过 n 次求出一些值，再根据剩余次数求答案。13.如果以上几种都不是，多半是有一个 point 你没有注意到，记住正难则反.  _____  _____   ____    _____   _____   _   _   _      __   __  _  __ |__  / | ____| / ___|  |_   _| |  ___| | | | | | |     \ \ / / | |/ /   / /  |  _|   \___ \    | |   | |_    | | | | | |      \ V /  | &#x27; /  / /_  | |___   ___) |   | |   |  _|   | |_| | | |___    | |   | . \   | /____| |_____| |____/    |_|   |_|      \___/  |_____|   |_|   |_|\_\  |*/
INT128// 字符串转 __int128inline void read128(__int128 &amp;x)&#123;    x=0;    __int128 f=1;    char ch = getchar();    while (ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;        if (ch == &#x27;-&#x27;) f = -1;        ch = getchar();    &#125;    while (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;        x = x * 10 + ch - &#x27;0&#x27;;        ch = getchar();    &#125;&#125;// __int128 转字符串（输出用）void print128(__int128 x) &#123;    if (x &lt; 0) &#123;        putchar(&#x27;-&#x27;);        x = -x;    &#125;    if (x &gt; 9) print128(x / 10);    putchar(x % 10 + &#x27;0&#x27;);&#125;int main() &#123;    // 读取 __int128    __int128 a; read128(a);    __int128 b; read128(b);    // 运算（和普通整数一样）    __int128 sum = a + b;    __int128 product = a * b;    // 输出    cout &lt;&lt; &quot;Sum: &quot;;    print128(sum);    cout &lt;&lt; &quot;Product: &quot;;    print128(product);    return 0;&#125;
01背包val_baseconst ll INF=1e9;ll w[110],v[110],sum=0,n,f[100010],ans=0,W;int main()&#123;    cin&gt;&gt;n&gt;&gt;W;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;w[i]&gt;&gt;v[i];        sum+=v[i];    &#125;    fill(f,f+100005,INF);    f[0]=0;    for(int i=1;i&lt;=n;i++)        for(int j=sum;j&gt;=v[i];j--)            if(f[j-v[i]]!=INF)                f[j]=min(f[j],f[j-v[i]]+w[i]);    for(int j=sum;j&gt;=0;j--)        if(f[j]&lt;=W)&#123;            ans=j;            break;        &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;
01背包ll N,W,w[200010],v[200010],ans[200010];int main()&#123;    cin&gt;&gt;N&gt;&gt;W;    for(int i=1;i&lt;=N;i++)        cin&gt;&gt;w[i]&gt;&gt;v[i];    for(int i=1;i&lt;=N;i++)&#123;        for(int l=W;l&gt;=w[i];l--)&#123;            ans[l]=max(ans[l-w[i]]+v[i],ans[l]);        &#125;    &#125;    cout&lt;&lt;ans[W]&lt;&lt;endl;&#125;/*仔细观察代码可以发现：对于当前处理的物品 𝑖i 和当前状态 𝑓𝑖,𝑗f_&#123;i,j&#125;，在 𝑗 ⩾𝑤𝑖j\geqslant w_&#123;i&#125; 时，𝑓𝑖,𝑗f_&#123;i,j&#125; 是会被 𝑓𝑖,𝑗−𝑤𝑖f_&#123;i,j-w_&#123;i&#125;&#125; 所影响的。这就相当于物品 𝑖i 可以多次被放入背包，与题意不符。（事实上，这正是完全背包问题的解法）*/
01bfsconst int INF = 0x3f3f3f3f;const int MAXN = 1e5+1;vector&lt;pair&lt;int, int&gt;&gt; graph[MAXN];int main()&#123;    int n, m, source;    deque&lt;int&gt; dq;    vector&lt;int&gt; dist(n, INF);    dist[source] = 0;    dq.push_front(source);    while (!dq.empty()) &#123;        int u = dq.front(); dq.pop_front();        for (auto [v, w] : graph[u]) &#123;            if (w == 0 &amp;&amp; dist[v] &gt; dist[u]) &#123;                dist[v] = dist[u];                dq.push_front(v);  // 边权0，加入前端            &#125; else if (w == 1 &amp;&amp; dist[v] &gt; dist[u] + 1) &#123;                dist[v] = dist[u] + 1;                dq.push_back(v);   // 边权1，加入后端            &#125;        &#125;    &#125;&#125;
单调队列int h=0,t=-1,q[1000010],n,a[1000010];int main()&#123;    ll n,m; cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];    for(int i=1;i&lt;=n;i++)&#123;        if(h&lt;=t &amp;&amp; q[h]&lt;i-m+1) h++;        while(h&lt;=t &amp;&amp; a[i]&lt;=a[q[t]]) t--;        q[++t]=i;        if(i&gt;m-1) printf(&quot;%d &quot;,a[q[h]]);    &#125;    cout&lt;&lt;endl;&#125;/*对只除去开头元素来保证不过期的解释：新的大元素会淘汰所有旧元素，清空后新元素下标最大，确保不会漏掉过期检查队列下标的**单调递增**保证了过期检测的简单性使用方式：可以用于配合求区间最值，如区间和，加上前缀和，减掉最小位置就行了*/
单调栈stack&lt;ll&gt; s;ll N,ans[3000010],a[3000010];int main()&#123;    cin&gt;&gt;N;    for(int i=1;i&lt;=N;i++)&#123;        cin&gt;&gt;a[i];        while(!s.empty()&amp;&amp;a[i]&gt;a[s.top()])&#123;            ans[s.top()]=i;            s.pop();        &#125;        s.push(i);    &#125;    for(int i=1;i&lt;=N;i++) cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;&#125;
多重背包ll f[200010],n,V,q[200010],g[200010];int main()&#123;    cin&gt;&gt;n&gt;&gt;V;    for(int i=1;i&lt;=n;i++)&#123;        memcpy(g,f,sizeof(f));        ll v,w,s; cin&gt;&gt;w&gt;&gt;v&gt;&gt;s;  //vol worth shu        for(int j=0;j&lt;v;j++)&#123;            ll h=0,t=-1;            for(int k=j;k&lt;=V;k+=v)&#123;                if(h&lt;=t &amp;&amp; q[h]&lt;k-s*v) h++;//处理过期元素                if(h&lt;=t) f[k]=max(g[k],g[q[h]]+(k-q[h])/v*w);//使用头部最大值                while(h&lt;=t &amp;&amp; g[k]&gt;=g[q[t]]+(k-q[t])/v*w) t--; //尾部值加上可能的价值还没现在这个大，那么就出队                q[++t]=k;            &#125;        &#125;    &#125;    cout&lt;&lt;f[V]&lt;&lt;endl;&#125;/*因为更新时是分为余数相同的v-1类的因为当余数为j时，只会访问相同余数的情况，而且是有一定范围的(窗口)每一类都可以单独用单调队列来优化，这样每次都可以取到最大值从而优化代码的复杂度，不然相当于每种情况都在寻找最小值，不优*/
二维背包ll f[2010][2010],V,M,n;int main()&#123;    cin&gt;&gt;n&gt;&gt;V&gt;&gt;M;    for(int i=1;i&lt;=n;i++)&#123;        ll v,m,w; cin&gt;&gt;w&gt;&gt;v&gt;&gt;m;        for(int j=V;j&gt;=v;j--)            for(int k=M;k&gt;=m;k--)                f[j][k]=max(f[j-v][k-m]+w,f[j][k]);    &#125;    cout&lt;&lt;f[V][M]&lt;&lt;endl;&#125;/*w为价值v为体积(第一维)w为重量(第二维)*/
分组背包ll f[200010],n,V,v[200010],w[200010]; //vol worthint main()&#123;    cin&gt;&gt;n&gt;&gt;V;    for(int i=1;i&lt;=n;i++)&#123;        ll s;cin&gt;&gt;s;        for(int j=1;j&lt;=s;j++) cin&gt;&gt;v[j]&gt;&gt;w[j];        for(int j=V;j&gt;=1;j--)&#123;            for(int k=1;k&lt;=s;k++)&#123;                if(j&gt;=v[k])                    f[j]=max(f[j],f[j-v[k]]+w[k]);            &#125;        &#125;    &#125;    cout&lt;&lt;f[V]&lt;&lt;endl;&#125;/*和01背包同理，需要从后往前计算保证每种物品只被计算一遍*/
高斯约旦消元法const double eps=1e-8;double a[110][110];void solve()&#123;  ll n; cin&gt;&gt;n;  for(int i=1;i&lt;=n;i++)&#123;    for(int j=1;j&lt;=n+1;j++)&#123;      cin&gt;&gt;a[i][j];    &#125;  &#125;  for(int i=1;i&lt;=n;i++)&#123;    ll r=i;    for(int k=i;k&lt;=n;k++)&#123;      if(fabs(a[k][i])&gt;eps)&#123;// 找到非0行,换到最前面        r=k;        break;      &#125;    &#125;    if(r!=i)      swap(a[i],a[r]);    if(fabs(a[i][i])&lt;eps)&#123;//double不能直接和0比较，所以和一个非常小的数比较      cout&lt;&lt;&quot;No Solution&quot;&lt;&lt;endl;//如果为0了，那么必然是没有唯一解的      return;    &#125;    for(int k=1;k&lt;=n;k++)&#123;//把这一列除了a[i][i]全变为0      if(k==i) continue;      double t=a[k][i]/a[i][i];//计算倍数      for(int j=i;j&lt;=n+1;j++)&#123;//减去对应的数        a[k][j]-=t*a[i][j];      &#125;    &#125;  &#125;  for(int i=1;i&lt;=n;i++)&#123;    cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;a[i][n+1]/a[i][i]&lt;&lt;endl;  &#125;&#125;
快速幂long long quickpow(ll a, ll b, ll m)&#123;    ll sum=1;    while(b&gt;0)&#123;        if(b&amp;1)            sum=sum*a%m;        a=a*a%m;        b&gt;&gt;=1;    &#125;    return sum;&#125;
区间dpll n,a[410],ans[410][410],sum[410];int main()&#123;    cin&gt;&gt;n;    memset(ans,0x3f,sizeof(ans));    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a[i];        sum[i]=sum[i-1]+a[i];        ans[i][i]=0;    &#125;    for(int l=2;l&lt;=n;l++)&#123;        for(int i=1;i+l-1&lt;=n;i++)&#123;            ll j=i+l-1;            for(int k=i;k&lt;j;k++)&#123;                ans[i][j]=min(ans[i][k]+ans[k+1][j]+sum[j]-sum[i-1],ans[i][j]);            &#125;        &#125;    &#125;    cout&lt;&lt;ans[1][n]&lt;&lt;endl;&#125;/*首先，每个区间自己合并的代价是0，之后枚举长度，枚举起点，计算每个区间的值，记得加上区间的总值，即合并后所需的代价。*/
拓扑排序const ll MAXN=200010;ll n, m;vector&lt;ll&gt; G[MAXN];ll in[MAXN];  // 存储每个结点的入度bool toposort() &#123;    vector&lt;ll&gt; L;    queue&lt;ll&gt; S;    for (int i = 1; i &lt;= n; i++)        if (in[i] == 0) S.push(i);    while (!S.empty()) &#123;        int u = S.front();        S.pop();        L.push_back(u);        for (auto v : G[u]) &#123;            if (--in[v] == 0) &#123;                S.push(v);            &#125;        &#125;    &#125;    if (L.size() == n) &#123;        for (auto i : L) cout &lt;&lt; i &lt;&lt; &#x27; &#x27;;        return true;    &#125;    return false;&#125;
依赖背包ll n,v[65],w[65],f[65][32010],V;vector&lt;ll&gt; a[65];void dfs(ll now)&#123;    for(int i=v[now];i&lt;=V;i++)        f[now][i]=v[now];    for(auto &amp;s:a[now])&#123;        dfs(s);        for(int j=V;j&gt;=v[now];j--)            for(int k=v[s];k+v[now]&lt;=j;k++)                f[now][j]=max(f[now][j],f[now][j-k]+f[s][k]);    &#125;&#125;int main()&#123;    cin&gt;&gt;V&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        ll f; cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;f;        a[f].push_back(i);    &#125;    dfs(0);    cout&lt;&lt;f[0][V]&lt;&lt;endl;&#125;/*循环时，从根往上计算，外层遍历体积，内层为决策，看选择子树体积为k时是否合理来判断要不要选择。f[i][j]表示选择i时体积为j的最大值*/
字典树const ll INF=1e18,N=1e5+10;char s[N];int ch[N][26],cnt[N],idx=0;void insert(char *s)&#123;    int p=0;    for(int i=0;s[i];i++)&#123;        int j=s[i]-&#x27;a&#x27;;        if(!ch[p][j]) ch[p][j]=++idx;        p=ch[p][j];    &#125;    cnt[p]++;&#125;int query(char *s)&#123;    int p=0;    for(int i=0;s[i];i++)&#123;        int j=s[i]-&#x27;a&#x27;;        if(!ch[p][j]) return 0;        p=ch[p][j];    &#125;    return cnt[p];&#125;
最大区间和ll a[200010];int main()&#123;    ll n; cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)        cin&gt;&gt;a[i];    ll max_ending_here=a[1];    ll max_so_far=a[1];    for(int i=2;i&lt;=n;i++)&#123;        max_ending_here=max(a[i],max_ending_here+a[i]);        max_so_far=max(max_so_far,max_ending_here);    &#125;    cout&lt;&lt;max_so_far&lt;&lt;endl;    ll sum=0;    for(int i=1;i&lt;=n;i++)&#123;        sum=sum+a[i];        max_so_far=max(max_so_far,sum);        if(sum&lt;0) sum=0;    &#125;&#125;
dijkstralong long N;const long long INF=1e18;vector&lt;pair&lt;LL,LL&gt;&gt; g[10010];int main()&#123;    priority_queue&lt;pair&lt;LL, LL&gt;, vector&lt;pair&lt;LL, LL&gt;&gt;, greater&lt;pair&lt;LL, LL&gt;&gt;&gt; pq;vector&lt;bool&gt; vis(N+1, false);    vector&lt;LL&gt; dis(N+1, INF);    dis[1] = 0;    pq.push(&#123;0, 1&#125;);    while(!pq.empty()) &#123;        auto [d, u] = pq.top(); pq.pop();        if(vis[u]) continue;        vis[u] = true;        for(auto [v, w] : g[u]) &#123;            if(!vis[v] &amp;&amp; dis[v] &gt; dis[u] + w) &#123;                dis[v] = dis[u] + w;                pq.push(&#123;dis[v], v&#125;);            &#125;        &#125;    &#125;&#125;
交互题int main()&#123;    int T; cin&gt;&gt;T;    while(T--)&#123;        ll n,y; cin&gt;&gt;n;        ll sum=n*(n+1)/2;        cout&lt;&lt;&quot;2 1 &quot;&lt;&lt;n&lt;&lt;endl;        cout.flush();        cin&gt;&gt;y;        ll len=y-sum,l=1,r=n;        while(l&lt;=r)&#123;            ll mid=(l+r)&gt;&gt;1;            cout&lt;&lt;&quot;1 1 &quot;&lt;&lt;mid&lt;&lt;endl;            cout.flush();            ll last; cin&gt;&gt;last;            cout&lt;&lt;&quot;2 1 &quot;&lt;&lt;mid&lt;&lt;endl;            cout.flush();            ll now; cin&gt;&gt;now;            ll f=now-last;            if(f==0) l=mid+1;            else r=mid-1;        &#125;        cout&lt;&lt;&quot;! &quot;&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;l+len-1&lt;&lt;endl;        cout.flush();    &#125;&#125;
KMPint main()&#123;    string t,p; cin&gt;&gt;t&gt;&gt;p;    vector&lt;ll&gt; ans,pi(p.length());    for(int i=1;i&lt;p.length();i++)&#123;        ll j=pi[i-1];        while(j&gt;0&amp;&amp;p[j]!=p[i]) j=pi[j-1];        if(p[i]==p[j]) j++;        pi[i]=j;    &#125;//上面是next函数，对pattern数据处理，方便查找长度    for(int i=0,j=0;i&lt;t.length();i++)&#123;        while(j&gt;0&amp;&amp;t[i]!=p[j])j=pi[j-1];        if(p[j]==t[i])j++;        if(j==p.length())&#123;            ans.push_back(i-p.length()+1);            j=pi[j-1];        &#125;    &#125;//计算可能的位置    for(auto &amp;i:ans) cout&lt;&lt;i+1&lt;&lt;endl;    for(int i=0;i&lt;p.length();i++) cout&lt;&lt;pi[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl;&#125;/*关键点，比较时j会向前跳，pi[j]记录的依旧是长度可以用计算前缀的函数来理解最后记得要向前跳一位，因为不然下一次会直接认为是正确答案而且跳不回去了，所以要j=pi[j-1]*/
LCSll f[3010][3010],p[3010][3010];string s,t;int main()&#123;    cin&gt;&gt;s&gt;&gt;t;    ll m=s.length(),n=t.length();    for(int i=1;i&lt;=m;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            if(s[i-1]==t[j-1])&#123;                f[i][j]=f[i-1][j-1]+1;                p[i][j]=1;            &#125;            else if(f[i][j-1]&gt;f[i-1][j])&#123;                f[i][j]=f[i][j-1];                p[i][j]=2;            &#125;            else&#123;                f[i][j]=f[i-1][j];                p[i][j]=3;            &#125;        &#125;    &#125;    ll i,j,k; char ch[3010];    i=m,j=n,k=f[m][n];    while(i&gt;0&amp;&amp;j&gt;0)&#123;        if(p[i][j]==1)&#123;            ch[k--]=s[i-1];            i--; j--;        &#125;        else if(p[i][j]==2) j--;        else i--;    &#125;    for(int i=1;i&lt;=f[m][n];i++)        cout&lt;&lt;ch[i]; cout&lt;&lt;endl;&#125;
Mabacherconst ll INF=1e18;ll p[22000010],mid=0,r=0,ans=1;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    string x; vector&lt;char&gt; s;    s.push_back(&#x27;~&#x27;);s.push_back(&#x27;#&#x27;);    cin&gt;&gt;x; ll len=x.length()*2+1;    for(int i=0;i&lt;x.length();i++)&#123;s.push_back(x[i]);        s.push_back(&#x27;#&#x27;);&#125;    s.push_back(&#x27;!&#x27;);    for(int i=2;i&lt;len-1;i++)&#123;        if(i&lt;=r) p[i]=min(p[mid*2-i],r-i+1);        else p[i]=1;        while(s[i-p[i]]==s[i+p[i]]) p[i]++;        if(i+p[i]-1&gt;r)&#123;r=p[i]+i-1;mid=i;&#125;        ans=max(p[i],ans);    &#125;    cout&lt;&lt;ans-1&lt;&lt;endl;&#125;/*加入几个字符使得每一段都是奇数，然后记录的是半径，所以值为r-1然后如果在已知最右范围之内，那么就先默认为对称值，之后再扩张更新初始化时记得使用vector，因为用字符串的相加是需要O(n)时间复杂度*/
SPFAconst long long INF=1e18;vector&lt;pair&lt;LL,LL&gt;&gt; g[10010];int main()&#123;    queue&lt;LL&gt; q;    vector&lt;bool&gt; inQueue(N+1, false);    vector&lt;LL&gt; dis(N+1, INF);    dis[1] = 0;    q.push(1);    inQueue[1] = true;    while(!q.empty()) &#123;        LL u = q.front(); q.pop();        inQueue[u] = false;        for(auto [v, w] : g[u]) &#123;            if(dis[v] &gt; dis[u] + w) &#123;                dis[v] = dis[u] + w;                if(!inQueue[v]) &#123;                    q.push(v);                    inQueue[v] = true;                &#125;            &#125;        &#125;    &#125;&#125;
String Hashtypedef unsigned long long ULL;const ll P=131;unordered_set&lt;ll&gt; a;ULL p[2200],h[2200];ll init(string s)&#123;    p[0]=1,h[0]=0;    for(int i=1;i&lt;=s.length();i++)&#123;        p[i]=p[i-1]*P;        h[i]=h[i-1]*P+s[i-1];    &#125;    return h[s.length()];&#125;ll gethash(ll l,ll r)&#123;    return h[r]-h[l-1]*p[r-l+1];&#125;ll sbstr(ll l1,ll r1,ll l2,ll r2)&#123;    return gethash(l1,r1)==gethash(l2,r2);&#125;
String prefixll pi[300010];int main()&#123;    string s; cin&gt;&gt;s;    for(int i=1;i&lt;s.length();i++)&#123;        ll j=pi[i-1];        while(j&gt;0&amp;&amp;s[j]!=s[i]) j=pi[j-1];//跳到子问题的最大值位置，即i-1那一段所能求得的前缀最大那一段        if(s[i]==s[j]) j++;        pi[i]=j;    &#125;    for(int i=0;i&lt;s.length();i++)cout&lt;&lt;pi[i]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl;&#125;/*比如字符串为acaca...acacc           01234      ^               ^      |               |      i               jj此时为4，判断下面这个等式，不成立，那么长度只能是p[j-1]的最大值(p[j]是要比较的值，所以最大前缀值实际上是j-1)，这样就得到了第二小的值如果合法，那么s[p[i]]==s[i+1]因为长度为x的话，而是string从0开始的，所以如果相等则符合要求，找到了一个位置可以+1*/
substrint main() &#123;    std::string str = &quot;Short&quot;;    // 安全使用：检查位置是否有效    size_t pos = 10;    if (pos &lt; str.length()) &#123;        std::string sub = str.substr(pos);        std::cout &lt;&lt; sub &lt;&lt; std::endl;    &#125; else &#123;        std::cout &lt;&lt; &quot;位置超出字符串范围！&quot; &lt;&lt; std::endl;    &#125;    // 如果长度超过字符串剩余部分，会自动调整    std::string safe_sub = str.substr(2, 100); // 只会提取 &quot;ort&quot;    std::cout &lt;&lt; safe_sub &lt;&lt; std::endl;    std::string filename = &quot;document.pdf&quot;;    // 找到最后一个点的位置    size_t dotPos = filename.find_last_of(&#x27;.&#x27;);    if (dotPos != std::string::npos) &#123;        std::string extension = filename.substr(dotPos + 1);        std::cout &lt;&lt; &quot;文件扩展名: &quot; &lt;&lt; extension &lt;&lt; std::endl; // 输出 &quot;pdf&quot;    &#125;    std::string str = &quot;Hello, World!&quot;;    // 提取前 5 个字符    std::string sub3 = str.substr(0, 5);    std::cout &lt;&lt; sub3 &lt;&lt; std::endl; // 输出 &quot;Hello&quot;    return 0;&#125;
树状数组ll c[200010],n;//树状数组的常见写法int lowbit(int x)&#123;return x&amp;-x;&#125;int getsum(int x)&#123;  // a[1]..a[x]的和    int ans=0;    while(x&gt;0)&#123;        ans=ans+c[x];        x=x-lowbit(x);    &#125;    return ans;&#125;void add(int x,int k)&#123; // idx,val    while(x&lt;=n)&#123;  // 不能越界        c[x]=c[x]+k;        x=x+lowbit(x);    &#125;&#125;
树状数组前缀和ll t1[1000005],t2[1000005],n;ll lowbit(int x) &#123;return x&amp;(-x);&#125;void build(ll k,ll v)&#123;    ll v1=v*k;    while(k&lt;n)&#123;        t1[k]+=v;t2[k]+=v1;        k+=lowbit(k);    &#125;&#125;ll getsum(ll *t1,int k)&#123;    ll sum=0;    while(k&gt;0)&#123;        sum+=t1[k];        k-=lowbit(k);    &#125;    return sum;&#125;void add(ll k,ll v)&#123;    build(k,v);&#125;void change(ll l,ll r,ll v)&#123;    add(l,v);add(r+1ll,-v);&#125;ll getsum1(ll l,ll r)&#123;    return (r+1ll)*getsum(t1,r)+l*getsum(t1,l-1ll)-getsum(t2,r)-getsum(t2,l-1ll);&#125;
Z函数int main()&#123;    string t; cin&gt;&gt;t;    vector&lt;ll&gt; zt(t.length());    zt[0]=t.length();    for(ll i=1,l=0,r=0;i&lt;t.length();i++)&#123;        if(i&lt;=r)zt[i]=min(zt[i-l],r-i+1);        while(t[zt[i]]==t[i+zt[i]]&amp;&amp;i+zt[i]&lt;t.length()) zt[i]++;        if(i+zt[i]-1&gt;r) l=i,r=zt[i]+i-1;    &#125;    for(auto &amp;i:zt) cout&lt;&lt;i&lt;&lt;&quot; &quot;; cout&lt;&lt;endl;&#125;/*zt记录的是字符串中，每一个位置作为起点能和开头匹配上的最长长度方法和马拉车算法类似，规定一个盒子，在盒子内的使用之前的数据，但是注意可能会超出边界，因此要加上一个判断。之后更新答案，这里没有判断在盒子外的才扩张是因为：如果可以发生扩张，那么说明现在这个边界不是最优的，因此如果在盒子内不会进入while因此这个算法和manacher一样是O(n),除此之外这个算法就和之前的前缀算法没有太大区别了*/
并查集const int N = 2e5+5;int fa[N];int n, m;int find(int x)&#123;    if(fa[x] == x) return x;    else return fa[x] = find(fa[x]); // 比起朴素代码只改了这里&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; ++i) fa[i] = i; // 初始化    for(int i = 1; i &lt;= m; ++i)&#123;        int op, x, y;        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;        if(op == 1)&#123; // 合并操作            x = find(x), y = find(y); // 查询各自的代表元素            if(x == y) continue; // 如果已经在同一个集合，跳过            fa[x] = y; // 这里的合并顺序可以任意        &#125;        else&#123; // 查询操作的一种变形            x = find(x), y = find(y); // 查询各自的代表元素            if(x == y) cout &lt;&lt; &quot;Y&quot; &lt;&lt; endl; // 是否在同一个集合            else cout &lt;&lt; &quot;N&quot; &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;
最小生成树int fa[1010];  // 定义父亲int n, m, k;struct edge &#123;  int u, v, w;&#125;;int l;edge g[10010];void add(int u, int v, int w) &#123;  l++;  g[l].u = u;  g[l].v = v;  g[l].w = w;&#125;// 标准并查集int findroot(int x) &#123; return fa[x] == x ? x : fa[x] = findroot(fa[x]); &#125;void Merge(int x, int y) &#123;  x = findroot(x);  y = findroot(y);  fa[x] = y;&#125;bool cmp(edge A, edge B) &#123; return A.w &lt; B.w; &#125;// Kruskal 算法void kruskal() &#123;  int tot = 0;  // 存已选了的边数  int ans = 0;  // 存总的代价  for (int i = 1; i &lt;= m; i++) &#123;    int xr = findroot(g[i].u), yr = findroot(g[i].v);    if (xr != yr) &#123;        // 如果父亲不一样      Merge(xr, yr);       // 合并      tot++;               // 边数增加      ans += g[i].w;       // 代价增加      if (tot == n - k) &#123;  // 检查选的边数是否满足 k 个棉花糖        cout &lt;&lt; ans &lt;&lt; &#x27;\n&#x27;;        return;      &#125;    &#125;  &#125;  cout &lt;&lt; &quot;No Answer\n&quot;;  // 无法连成&#125;int main() &#123;  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;  if (n == k) &#123;  // 特判边界情况    cout &lt;&lt; &quot;0\n&quot;;    return 0;  &#125;  for (int i = 1; i &lt;= n; i++) &#123;  // 初始化    fa[i] = i;  &#125;  for (int i = 1; i &lt;= m; i++) &#123;    int u, v, w;    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;    add(u, v, w);  // 添加边  &#125;  sort(g + 1, g + m + 1, cmp);  // 先按边权排序  kruskal();  return 0;&#125;
欧拉筛vector&lt;int&gt; pri;bool not_prime[N];void pre(int n) &#123;  for (int i = 2; i &lt;= n; ++i) &#123;    if (!not_prime[i]) &#123;      pri.push_back(i);    &#125;    for (int pri_j : pri) &#123;      if (i * pri_j &gt; n) break;      not_prime[i * pri_j] = true;      if (i % pri_j == 0) &#123;        // i % pri_j == 0        // 换言之，i 之前被 pri_j 筛过了        // 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被        // pri_j 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break        // 掉就好了        break;      &#125;    &#125;  &#125;&#125;
离散化// std::vector&lt;int&gt; arr;std::vector&lt;int&gt; tmp(arr);  // tmp 是 arr 的一个副本std::sort(tmp.begin(), tmp.end());tmp.erase(std::unique(tmp.begin(), tmp.end()), tmp.end());for (int i = 0; i &lt; n; ++i)  arr[i] = std::lower_bound(tmp.begin(), tmp.end(), arr[i]) - tmp.begin();
线段树void build(int s, int t, int p) &#123;  // 对 [s,t] 区间建立线段树,当前根的编号为 p  if (s == t) &#123;    d[p] = a[s];    return;  &#125;  int m = s + ((t - s) &gt;&gt; 1);  // 移位运算符的优先级小于加减法，所以加上括号  // 如果写成 (s + t) &gt;&gt; 1 可能会超出 int 范围  build(s, m, p * 2), build(m + 1, t, p * 2 + 1);  // 递归对左右区间建树  d[p] = d[p * 2] + d[(p * 2) + 1];&#125;int getsum(int l, int r, int s, int t, int p) &#123;  // [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号  if (l &lt;= s &amp;&amp; t &lt;= r)    return d[p];  // 当前区间为询问区间的子集时直接返回当前区间的和  int m = s + ((t - s) &gt;&gt; 1), sum = 0;  if (l &lt;= m) sum += getsum(l, r, s, m, p * 2);  // 如果左儿子代表的区间 [s, m] 与询问区间有交集, 则递归查询左儿子  if (r &gt; m) sum += getsum(l, r, m + 1, t, p * 2 + 1);  // 如果右儿子代表的区间 [m + 1, t] 与询问区间有交集, 则递归查询右儿子  return sum;&#125;
懒标记修改法// [l, r] 为修改区间, c 为被修改的元素的变化量, [s, t] 为当前节点包含的区间, p// 为当前节点的编号void update(int l, int r, int c, int s, int t, int p) &#123;  // 当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改  if (l &lt;= s &amp;&amp; t &lt;= r) &#123;    d[p] += (t - s + 1) * c, b[p] += c;    return;  &#125;  int m = s + ((t - s) &gt;&gt; 1);  if (b[p] &amp;&amp; s != t) &#123;    // 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值    d[p * 2] += b[p] * (m - s + 1), d[p * 2 + 1] += b[p] * (t - m);    b[p * 2] += b[p], b[p * 2 + 1] += b[p];  // 将标记下传给子节点    b[p] = 0;                                // 清空当前节点的标记  &#125;  if (l &lt;= m) update(l, r, c, s, m, p * 2);  if (r &gt; m) update(l, r, c, m + 1, t, p * 2 + 1);  d[p] = d[p * 2] + d[p * 2 + 1];&#125;  int getsum(int l, int r, int s, int t, int p) &#123;  // [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号  if (l &lt;= s &amp;&amp; t &lt;= r) return d[p];  // 当前区间为询问区间的子集时直接返回当前区间的和  int m = s + ((t - s) &gt;&gt; 1);  if (b[p]) &#123;    // 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值    d[p * 2] += b[p] * (m - s + 1), d[p * 2 + 1] += b[p] * (t - m);    b[p * 2] += b[p], b[p * 2 + 1] += b[p];  // 将标记下传给子节点    b[p] = 0;                                // 清空当前节点的标记  &#125;  int sum = 0;  if (l &lt;= m) sum = getsum(l, r, s, m, p * 2);  if (r &gt; m) sum += getsum(l, r, m + 1, t, p * 2 + 1);  return sum;&#125;
直接修改为特定值void update(int l, int r, int c, int s, int t, int p) &#123;  if (l &lt;= s &amp;&amp; t &lt;= r) &#123;    d[p] = (t - s + 1) * c, b[p] = c, v[p] = 1;    return;  &#125;  int m = s + ((t - s) &gt;&gt; 1);  // 额外数组储存是否修改值  if (v[p]) &#123;    d[p * 2] = b[p] * (m - s + 1), d[p * 2 + 1] = b[p] * (t - m);    b[p * 2] = b[p * 2 + 1] = b[p];    v[p * 2] = v[p * 2 + 1] = 1;    v[p] = 0;  &#125;  if (l &lt;= m) update(l, r, c, s, m, p * 2);  if (r &gt; m) update(l, r, c, m + 1, t, p * 2 + 1);  d[p] = d[p * 2] + d[p * 2 + 1];&#125;int getsum(int l, int r, int s, int t, int p) &#123;  if (l &lt;= s &amp;&amp; t &lt;= r) return d[p];  int m = s + ((t - s) &gt;&gt; 1);  if (v[p]) &#123;    d[p * 2] = b[p] * (m - s + 1), d[p * 2 + 1] = b[p] * (t - m);    b[p * 2] = b[p * 2 + 1] = b[p];    v[p * 2] = v[p * 2 + 1] = 1;    v[p] = 0;  &#125;  int sum = 0;  if (l &lt;= m) sum = getsum(l, r, s, m, p * 2);  if (r &gt; m) sum += getsum(l, r, m + 1, t, p * 2 + 1);  return sum;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>DP笔记</title>
    <url>/ZestfulYK-blog/2025/12/07/DP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[DP题目的特点
数据较小，至少有一维是可以接受的，比如每一步的决策小于3，总数小于1000等等
每一步的答案可以由之前的答案得到，比如数字三角形

DP题目的大致做法设DP数组
明确DP数组的含义，保证每次求解的答案都是这个含义，不然就可能出错(这也是我之前的一大误区)

分类讨论
明确有几种决策方案，明确这一步的答案是怎么推断出来的(非常重要!!!)

接下来编写代码就行了
举例：迎新赛M题
题目传送门：


ZJUTOJ | 2024ZJUT迎新赛-决赛-M. 三色小屋

题目理解：
首先发现每一步的方案数可以接受，并且这一步的答案只由上一步转移而来，所以可以使用DP
每个位置只能填R/G/B三种颜色，而且之和上一步和相邻的颜色有关，几种方案互不影响，符合动态规划的特点
分类讨论：
分为两大类，因为开头要初始化，所以单独讨论



dp[i][j] = 
\begin{cases}
i==1\begin{cases}
    c[i]==\ '0' & \text{可以用的颜色为1} \\
    c[i]\ !=\ \ '0' & \text{这个颜色为1}
\end{cases}\\ \\
i\ !=1\begin{cases}
    c[i]==\ '0' & \text{可以填入的颜色为前两个的和} \\
    c[i] \ !=\ \ '0' & \text{这个颜色为前两个的和}
\end{cases}
\end{cases}DP概率题求期望的几个重要公式\begin{aligned}
E(aX+b)=aE(x)+b \\ \\
E(X+Y)=E(X)+E(Y)\\ \\
E(XY)=E(X)E(Y)
\end{aligned}
上面两个说明了期望的线性关系，下面两个说明了期望的独立性

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>DP变种,n过大找规律题</title>
    <url>/ZestfulYK-blog/2025/02/12/DP%E5%8F%98%E7%A7%8D,n%E8%BF%87%E5%A4%A7%E6%89%BE%E8%A7%84%E5%BE%8B%E9%A2%98/</url>
    <content><![CDATA[
题目:要用qcjjkkt,和td构造字符串,每出现一个qcjjkkt获得a快乐度,每个td获得b快乐度即只有三种物品,体积为2,7,8,价值为a,b,a+b,数量无限,n上限为$10^9$,求最大价值

方法:完全背包


但是发现貌似超时,此时发现若n为56倍数很好解决,所以先提取完整的56,剩下部分单独计算.
然后发现qcjjkkt和td可以连接,要是前面56的循环选的是qcjjkkt最后如果剩下1位置,可以填入d,所以得加上特判,太麻烦了,所以改为计算最后112个就行
AC代码:
void solve()&#123;  ll n,a,b; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;  vector&lt;ll&gt; dp(120,0);  ll ans=0;  if(n&gt;112)&#123;    ans=(n/56-1)*max(&#123;28*b,8*a,7*(a+b)&#125;);    n-=(n/56-1)*56;  &#125;  for(int i=2;i&lt;=n;i++) dp[i]=max(dp[i-2]+b,dp[i]);  for(int i=7;i&lt;=n;i++) dp[i]=max(dp[i-7]+a,dp[i]);  for(int i=8;i&lt;=n;i++) dp[i]=max(dp[i-8]+b+a,dp[i]);  cout&lt;&lt;ans+dp[n]&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>DSU模板</title>
    <url>/ZestfulYK-blog/2025/02/24/DSU/</url>
    <content><![CDATA[DSU是并查集的缩写
总共有三种操作
初始化,查找根节点和连接
代码如下:
struct dsu&#123;//dsu std  vector&lt;ll&gt; fa,sz;  dsu(ll n):fa(n+1),sz(n+1,1)&#123;    for(int i=1;i&lt;=n;++i)&#123;      fa[i]=i;    &#125;  &#125;  ll find(ll x)&#123;return fa[x]==x?x:fa[x]=find(fa[x]);&#125;  void uni(ll x,ll y)&#123;    if(sz[x]&lt;sz[y]) swap(x,y);    fa[y]=x;    sz[x]+=sz[y];  &#125;&#125;;
使用方法如下:
dsu dsu1(n);ll fu=dsu1.find(u),fv=dsu2.find(v);if(fu!=fv) uni(fv,fu);
加了一个sz数组来计算每片区域的大小,这样就能防止图退化成一条链
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>拓展欧几里得算法</title>
    <url>/ZestfulYK-blog/2025/02/24/ex_gcd%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[拓展欧几里得算法用于在计算gcd的同时计算形如
ax+by=gcd(a,b)方程的答案
怎么计算呢?
首先考虑一个类似的方程:
bx_2+(a\ mod\ b)y_2=gcd(b,a\ mod\ b)要是能得到这个方程的解,上面那个也行因为
a-\lfloor \frac{a}{b}\rfloor*b=a\ mod\ b所以
bx_2+(a-\lfloor \frac{a}{b}\rfloor*b)y_2=b*(x_2-\lfloor \frac{a}{b}\rfloor y_2)+ay_2因为
gcd(a,b)==gcd(b,a\ mod\ b)两个系数相同的方程有相同的解,那么解对应相等
\begin{cases}x_1=y_2
\\ y_1=x_2-\lfloor \frac{a}{b}\rfloor y_2
\end{cases}接下来只要一直往下递归计算就能得到答案了
边界条件是b=0的时候,在C++内默认gcd(a,0)=a,所以最后一步的方程为
ax+0*y=a因此一般返回值是1,0
最后就能得到一组特解和gcd(a,b)了
代码:
i128 exgcd(i128 a,i128 b,i128 &amp;x,i128 &amp;y)&#123;//也可以当正常的gcd函数使用,相当于同时计算了一下方程的解  if(b==0)&#123;//最后递归到b=0时,得到ax=a,所以返回1,0    x=1;y=0;    return a;  &#125;  i128 d=exgcd(b,a%b,x,y);  i128 t=x;x=y;y=t-(a/b)*y;  return d;&#125;i128 ceil_div(i128 p,i128 q)&#123;  if(p&gt;=0) return (p+q-1)/q;//-1的目的是,万一刚好是整数倍,ceil不变  else return p/q;//负数去掉小数相当于向上取整&#125;i128 floor_div(i128 p,i128 q)&#123;  if(p&gt;=0) return p/q;//向下取整的逻辑恰好相反  else return (p+q-1)/q;&#125;
那么怎么得到通解呢?
实际上特解变化一下就行,考虑x增大的情况,为了保持不变,y得减小所以这个步长实际上就是b和a,反过来就行,因为这样才能保持等式的成立但是既然我们算出了gcd(a,b),那么再除一下化简
这样就得到了特解
注意:只有等号右边的常数为gcd(a,b)的倍数时,方程才有解,因为不然上面的方法就失效了,哪来的解
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown使用教程</title>
    <url>/ZestfulYK-blog/2025/10/20/markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[标题的使用# 一级标题## 二级标题### 三级标题
字体粗体 斜体 删除线 行内代码
小标题的使用
无序列表项
另一个项目


有序列表
第二项

链接，图片[链接文字](https://example.com)![图片描述](https://example.com/image.jpg)
引用块&gt; 这是一个引用块&gt; 可以多行使用

这是一个引用块可以多行使用

表格| 姓名 | 年龄 | 城市 ||------|------|------|| 张三 | 25   | 北京 || 李四 | 30   | 上海 |




姓名
年龄
城市




张三
25
北京


李四
30
上海




]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>模运算性质总结</title>
    <url>/ZestfulYK-blog/2025/11/25/mod/</url>
    <content><![CDATA[说明感谢YuukiX和qinye_leaf大佬的指正,现已对部分内容进行了修改和补充
本文最后修改时间: 2026/1/23/15:08
模运算（Mod）性质总结定义对于任意实数 $( x, y )$，有：
x \mod y = x - y \left\lfloor \frac{x}{y} \right\rfloor, \quad y \neq 0模运算（在一些场合使用符号 % 表示）是一个二元运算。$( x \mod y )$ 的值范围如下：

当 $( y &gt; 0 )$ 时：$( 0 \leq x \mod y &lt; y )$
当 $( y &lt; 0 )$ 时：$( 0 \geq x \mod y &gt; y )$
当 $( y = 0 )$ 时：为避免除以零，定义 $( x \mod 0 = x )$

基本运算规则模运算与基本四则运算类似（除法除外）：

加法规则：$((a + b) \mod p = (a \mod p + b \mod p) \mod p)$
减法规则：$((a - b) \mod p = (a \mod p - b \mod p + p) \mod p)$
乘法规则：$((a \times b) \mod p = (a \mod p \times b \mod p) \mod p)$
幂运算规则：$(a^b \mod p = ((a \mod p)^b) \mod p)$
求和规则：由第1个公式可推导出 (\left(\sum_{i=1}^{n} x_i\right) \mod p = \left(\sum_{i=1}^{n} (x_i \mod p)\right) \mod p)

对减法运算的解释: 注意此处可能减去后得到负数,因此要先加上一个mod
运算律A. 结合律((a + b) \mod p + c) \mod p = (a + (b + c) \mod p) \mod p((a \times b) \mod p \times c) \mod p = (a \times (b \times c) \mod p) \mod pB. 交换律(a + b) \mod p = (b + a) \mod p(a \times b) \mod p = (b \times a) \mod pC. 分配律(a + b) \mod p = (a \mod p + b \mod p) \mod p((a + b) \mod p \times c) \mod p = ((a \times c) \mod p + (b \times c) \mod p) \mod p补充性质同余性质
反身性：$(a \equiv a \pmod{m})$
对称性：如果 $(a \equiv b \pmod{m})$，则 $(b \equiv a \pmod{m})$
传递性：如果 $(a \equiv b \pmod{m})$ 且 $(b \equiv c \pmod{m})$，则 $(a \equiv c \pmod{m})$

模运算与除法模运算与除法不直接兼容，但有以下性质：

如果 $(ac \equiv bc \pmod{m})$ 且 $(\gcd(c, m) = 1)$，则 $(a \equiv b \pmod{m})$

模逆元：如果 $(\gcd(a, m) = 1)$，则存在整数 $(b)$ 使得 $(ab \equiv 1 \pmod{m})$，称 $(b)$ 为 $(a)$ 模 $(m)$ 的逆元

核心性质：在模运算里除以一个数等于乘以这个数的逆元，即：c/a≡c×a^{−1} (modm)其中 $a^{-1}$ 是 $a$ 在模 $m$ 下的逆元。


重要前提：模逆元存在的充分必要条件是 $\gcd(a, m) = 1$（即 $a$ 与 $m$ 互质）。如果 $a$ 与 $m$ 不互质，则 $a$ 在模 $m$ 下没有逆元，除法操作无法进行。

计算模逆元的方法常用的计算模逆元的方法是扩展欧几里得算法，它不仅能求最大公约数，还能找到满足贝祖等式的系数。
示例代码;#include &lt;iostream&gt;using namespace std;// 扩展欧几里得算法求逆元long long mod_inverse(long long a, long long m) &#123;    long long m0 = m;    long long y = 0, x = 1;        if (m == 1) return 0;        while (a &gt; 1) &#123;        long long q = a / m;        long long t = m;                m = a % m;        a = t;        t = y;                y = x - q * y;        x = t;    &#125;        if (x &lt; 0) x += m0;        return (a == 1) ? x : -1; // 如果逆元不存在返回 -1&#125;// 使用示例int main() &#123;    long long a = 3, m = 7;    long long inv = mod_inverse(a, m);    if (inv != -1) &#123;        cout &lt;&lt; a &lt;&lt; &quot; 在模 &quot; &lt;&lt; m &lt;&lt; &quot; 下的逆元是: &quot; &lt;&lt; inv &lt;&lt; endl;    &#125; else &#123;        cout &lt;&lt; a &lt;&lt; &quot; 在模 &quot; &lt;&lt; m &lt;&lt; &quot; 下没有逆元&quot; &lt;&lt; endl;    &#125;    return 0;&#125;
应用示例计算 $6 / 3 \pmod{7}$：

先求 $3^{-1} \pmod{7}$：$3 \times 5 = 15 \equiv 1 \pmod{7}$，所以逆元为 5

$6 / 3 \equiv 6 \times 5 = 30 \equiv 2 \pmod{7}$

验证：$2 \times 3 = 6 \equiv 6 \pmod{7}$ ✓


这个性质在密码学、组合数学和算法竞赛中都有广泛应用。
模运算的周期性质
对于任意整数 $(k)$，有 $(a \mod m = (a + km) \mod m)$
模运算的结果具有周期性，周期为模数 $(m)$

逆元的计算
如果是计算单个的逆元，那么使用小费定理：
ll qpow(ll a,b=mod-2) &#123;    ll res = 1;    while (b) &#123;        if (b &amp; 1) res = res * a % mod;        a = a * a % mod;        b &gt;&gt;= 1;    &#125;    return res;&#125;

计算多个数字的逆元，使用拓展欧几里得算法
LL inv[mod+5]; void getInv(LL mod) &#123; 	inv[1]=1; 	for(int i=2;i&lt;mod;i++) 		inv[i]=(mod-mod/i)*inv[mod%i]%mod; &#125;

然后如果是一个等式的话，考虑两边同时取逆元

例如：计算$n!$的逆元，得到递推式子(i+1)! \equiv i \,!*(i+1) \mod p所以：inv[(i+1)!]\equiv inv[i]*inv[i+1] \mod p又因为：inv[i+1]*(i+1)\equiv1\mod p所以把已知的$inv[i+1]$移到左边，得到：inv[(i+1)!]*(i+1)\equiv inv[i] \mod p这就是求阶乘逆元的递推式了

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第一类换元积分</title>
    <url>/ZestfulYK-blog/2025/12/07/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[重要公式基本积分公式：不要忘记加C!!!
$\xi \ \delta \ \alpha \ \beta \ \pi \  \theta \ \in \ \notin$$\Delta$
$\int k \, dx = kx + C$$\int x^n \, dx = \frac{x^{n+1}}{n+1} + C \quad (n \neq -1)$$\int \frac{1}{x} \, dx = \ln|x| + C$

指数函数：$\int e^x \, dx = e^x + C$$\int a^x \, dx = \frac{a^x}{\ln a} + C$

三角函数：$\int \sin x \, dx = -\cos x + C$$\int \cos x \, dx = \sin x + C$$\int \tan x \, dx = -\ln|\cos x| + C$$\int \cot x \, dx = \ln|\sin x| + C$$\int \sec^2 x \, dx = \tan x + C$$\int \csc^2 x \, dx = -\cot x + C$$\int \sec x \tan x \, dx = \sec x + C$$\int \csc x \cot x \, dx = -\csc x + C$$\int secx\,dx= ln|secx+tanx|+C$$\int cscx\,dx= ln|cscx-cotx|+C$



反三角函数：$\int \frac{1}{\sqrt{1-x^2}} \, dx = \arcsin x + C$$\int \frac{1}{1+x^2} \, dx = \arctan x + C$

双曲函数：$\int \sinh x \, dx = \cosh x + C$$\int \cosh x \, dx = \sinh x + C$

特殊积分：$\int \frac{1}{x^2+a^2} \, dx = \frac{1}{a}\arctan\frac{x}{a} + C$$\int \frac{1}{\sqrt{a^2-x^2}} \, dx = \arcsin\frac{x}{a} + C$$\int \frac{1}{x^2-a^2} \, dx = \frac{1}{2a}\ln\left|\frac{x-a}{x+a}\right| + C$

和差化积公式：$\sin A + \sin B = 2 \sin\left(\frac{A+B}{2}\right) \cos\left(\frac{A-B}{2}\right)$$\sin A - \sin B = 2 \cos\left(\frac{A+B}{2}\right) \sin\left(\frac{A-B}{2}\right)$$\cos A + \cos B = 2 \cos\left(\frac{A+B}{2}\right) \cos\left(\frac{A-B}{2}\right)$$\cos A - \cos B = -2 \sin\left(\frac{A+B}{2}\right) \sin\left(\frac{A-B}{2}\right)$

积化和差公式：$\sin A \cos B = \frac{1}{2}[\sin(A+B) + \sin(A-B)]$$\cos A \sin B = \frac{1}{2}[\sin(A+B) - \sin(A-B)]$$\cos A \cos B = \frac{1}{2}[\cos(A+B) + \cos(A-B)]$$\sin A \sin B = -\frac{1}{2}[\cos(A+B) - \cos(A-B)]$


对部分公式的推导：$\int \tan x \, dx = -\ln|\cos x| + C$$\int \tan x \, dx = \int \frac{sinx}{cosx} \,dx = - \int \frac{dcosx}{sinx} \, = -ln|cosx|+ C$

对于 $\int cotx$ 同理
小技巧：
$sinx^m cosx^n$之类的，奇数的话拆一个进去积分，偶数的话用倍角或半角公式

在对$\int tanx\,dx$或者$\int secx\,dx$等方法一样，可以类比

奇数如$\int sin^3 \, dx$或者$\int sin^3cosx\,dx$等比如$\int sinx^3\,dx=-\int sinx^2\,dcosx=-\int(1-cos^2x)\,dcosx$$=-cosx+\frac{1}{3}cosx^3+C$
偶数如$\int cosx^4\,dx$等比如$\int cosx^4\,dx=\int(\frac{1+cos2x}{2})^2\,dx=\frac{1}{4}\int1+cos2x^2+2cos2x\,dx$$=\frac{1}{4}(x+\frac{1}{2}\int cos2x^2\,d2x+\int cos2x\,d2x)+C$$=\frac{1}{4}(x+sin2x+\frac{1}{2}\int \frac{1+cos4x}{2}\,d2x)+C$$=\frac{1}{4}(x+sin2x+\frac{1}{8} \int(1+cos4x)\,d4x)+C$$=\frac{1}{4}(x+sin2x+\frac{1}{8}(4x+sin4x))+C$$=\frac{3}{8}x+\frac{1}{4}sin2x+\frac{1}{32}sin4x+C$

对于$\frac{…+…}{…}$类的可能是把上面的式子拆成两个分别计算例如：$\int \frac{1+x}{\sqrt{2-3x^2}}\,dx$$=\int \frac{1}{\sqrt{2-3x^2}}\,dx+\int \frac{x}{\sqrt{2-3x^2}}\,dx$

要熟记各种三角函数的导数和公式以及转换关系：$secx^2-1=tanx^2$$cscx^2-1=cotx^2$
arctan(\frac{1}{x})=\begin{cases}
arccot(x)\ \ \ \ \ \ \ \ \ x>0\\
arccot(x)-\pi  \ \ x]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>不定积分习题</title>
    <url>/ZestfulYK-blog/2025/12/13/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[第一类有理积分主要方法
放入分子
放入分子的部分
放入分母
放入分母的部分
特殊构造|—商的导数求积分部分|—两个函数相乘求导$e^x$|—三角函数构造$\tan x$
最后复习一下一些特殊的积分公式放入分子
这一中方法比较基础。
如果是放入分子的，那么必然是如下形式的\int \frac{f'(x)}{f(x)}\,dx
这样就能得到\int \frac{df(x)}{f(x)}
所以先看一下分母求导的结果有没有可能等于分子，如果是，那么就可以用这种方法
例题\int \frac{\sin x+\cos x}{\sqrt[3]{\sin x-\cos x}}\,dx放入分子的部分
这个通常出现在三角函数中，因为这样可以把所有三角函数化程同名。

然后放入时注意一下和分子的形式要对上。例题\int \frac{\sin x\cos x^3}{1+\cos x^2}\,dx
这题直接放入$\sin x$还不行，因为要注意一下分母的形式。所以注意到可以凑出$\sin 2x$，这样放入时形式就一样了

放入分母
放入分母的实际上是这种形式$\int f’(x)f(x)\,dx$
然后被$f’(x)$正好是分数的形式，看起来就像分式罢了。
所以记得先看看分子求导是否可能是一个分式，比如$\ln x$或者是$\sqrt{x^2-1}$这种形式的式子
所以也有可能是分子的导数会穿一部分到分子来，所以建议是先对分子的部分进行求导
主要问题是，出题人会把求导结果化到最简，导致看不出来
例题
\int \frac{\sqrt{\ln(x+\sqrt{1+x^2})+1}}{\sqrt{1+x^2}}\,dx
\int\frac{e^{\sqrt{1+\sin x}}\cos x}{\sqrt{1+\sin x}}\,dx放入分母的部分


这一种情况通常是在含有$\ln x$和$\frac{1}{x}$时使用，因为可以把$\frac{1}{x}$放入。目前只发现这一种情况可以用这个来解决


例题\int \frac{\ln x^2}{x(1+\ln x^2)}\,dx特殊构造
比较难想到，但是遇到以后下次就有概率会写
商的导数求积分部分
这一种之前做过一次，可以看一下分部积分的商的导数求积分部分。

传送门：分步积分笔记

两个函数相乘导数的积分
实际上，这个是\int e^{ax}f(x)\,dx然后可以被转化为\int e^{ax}(ah(x)+h'(x))\,dx所以是$e^{ax}$和别的函数的乘积得到的，通常也只有$e^{ax}$能有这种特殊做法。

为什么只有$e^{ax}$有这个性质
$e^{ax}$求导有不变性，这样求导了以后才会出现这种情况，所以只有$e^{ax}$才应当考虑有无这种特殊解法，其余的直接计算就好了，不要想那么多

识别方法：
观察结构：被积函数通常包含指数函数$e^{ax}$与另一个函数f(x)的乘积。
分析 $f(x)$：尝试将 $f(x)$拆分为两部分，其中一部分是某个函数 $h(x)$，另一部分是其导数 $h’(x)$（或 $ah(x)+h’(x)$）。常见的线索包括：


$f(x)$ 为有理函数或三角函数，且分子或分母具有导数的特征。
通过经验猜测$h(x)$的形式.


验证：对猜想的 $h(x)$ 求导，检查是否满足 $f(x)=ah(x)+h’(x)$

例题：\int \frac{(1+\sin x)e^x}{1+\cos x}\,dx发现有$e^{ax}$考虑一下是否可以这么做，那么先计算前面能否拆成$f(x)=ah(x)+h’(x)$，计算得到:
(\frac{\sin x}{1+\cos x})'=\frac{1}{(1+\cos x)}所以这么拆分是合法的。最后得到：
\frac{e^x \sin x}{1+\cos x}+C此外，还有一题和这个思路十分类似：
\int \frac{\cos x^2-\sin x}{\cos x(1+e^{\sin x}\cos x)}\,dx注意到：
(e^{\sin x}\cos x)'=\cos x^2-\sin x所以可以把分子放入进行计算，这里依然是$e^{ax}$的性质。此外放入以后发现少了一个$e^{\sin x}$，那么再加上一个$e^{\sin x}$再$dx$里面，正好使得分母多了一个$e^{\sin x}$，那么换元一下就是有理函数的积分了
总结：遇到$e^{ax}$，求导一下总是有用的，能简化计算。
余正弦化正切
遇到这么一种情况，有$\sin x$和$\cos x$，但是表现出的却是加法的形式，无法把其中一部分提取出来，那么这时我们就应该考虑一下是不是可以化成$\tan x$来计算。

例题1.
\int \frac{dx}{\sin x^2+2\cos x^2}
这里无法采用上述提及的所有方法，于是我们采用上下同时除以$\cos x^2$的方法来计算，得到有关$\sec x^2$和$\tan x^2$的式子，这样就可以计算了。

2.
\int \frac{x+\sin x\cos x}{(\cos x-x\sin x)^2}\,dx
注意到下面部分的导数并非上半部分，上半部分也不能被提取，那么考虑能否转换为$\tan x$和$\sec x$的式子，于是先提取一个$\cos x$，得到：\int \frac{x\sec x+\tan x}{(1-x\tan x)^2}\,dx
接着就发现下面的导数等于上面部分了，那么就好做了。

特殊积分公式复习
首先是特殊的三角公式\int \sec x\,dx=ln|\sec x+\tan x|+C\int \csc x\,dx= ln|\csc x-\cot x|+C
接下来是裂项公式\int \frac{1}{x^2-a^2} \, dx = \frac{1}{2a}\ln\left|\frac{x-a}{x+a}\right| + C\int \frac{1}{a^2-x^2} \, dx = \frac{1}{2a}\ln\left|\frac{a+x}{a-x}\right| + C(要是记不住这个好像也可以直接当有理函数来做？)
最后是反三角式
\int \frac{1}{\sqrt{a^2-x^2}} \, dx = \arcsin\frac{x}{a} + C\int \frac{1}{x^2+a^2} \, dx = \frac{1}{a}\arctan\frac{x}{a} + C这一个只有两种情况，剩下的老老实实进行$\sec x$和$\tan x$代换上下其实都会消去一个$\frac{1}{a}$但是下面那个是二次式子，所以就剩下了一个$\frac{1}{a}$.
额外提醒
注意$\frac{1}{\cos x}$和$\sec x$的转换，如果只是单出现一个，那么就转换成没有分数的式子

注意一下同时含有$\tan x\text{和}\sec x$的分式，可能需要展开消去部分$\cos x$来简化计算
需不需要展开计算看你是否可以消去

第二类换元积分主要方法
第二类换元积分开始和有理积分接近，所以换元完要考虑一下有理积分。
含有根式的只有$\sqrt{a^2-x^2}$有公式，其他老老实实计算！
倒带换是把x换为$\frac{1}{t}$，别代换错了
要是根式含有$a^x$，那么令整一个根号为t，其他令$a^x$为t

简单根式代换
除了$\tan x\text{和}\sec x$的代换以外，还有这么一种情况：\int \frac{x^2\,dx}{\sqrt{(x^2-a^2)^3}}
实际上，里面的次数是没有影响的，因为每一个都可以拆出一个，得到三次式，然后再老老实实计算。
其他含有根式的，要么时属于有理函数的积分，有吗就是可以直接按照三角换元做出来。例题

\int \frac{dx}{(1+x^2)\sqrt{1-x^2}}
直接把x代换为$\sin t$即可，然后这个式子貌似很熟悉？
质数函数的代换
例如分母含有$e^x$等赘述函数时，直接代换这一部分

如果在根式中，代换整个根式例题

代换指数函数
例如求\int \frac{1}{e^x+e^{2x}}\,dx
代换$x=\ln t(e^x=t)$得到\int \frac{1}{t+t^2}\frac{1}{t}\,dt
就能变成有理函数的积分了
代换整个根式
例如求$\int \frac{1}{\sqrt{e^x+1}}\,dx$

代换整个根号$x=\ln(t^2-1)\,(t=\sqrt{e^x+1})$得到$\int \frac{1}{t}\frac{2t}{t^2-1}\,dt$
从而又被化成了有理函数的积分

倒代换
代换为$\frac{1}{t}$，别把$\frac{1}{x}$代换成了t就彳亍
然后注意时用在幂函数上，别搞错就彳亍
例题
如计算$\int \frac{1}{x(x^6+1)}\,dx$

直接代换得到-\int \frac{1}{\frac{1}{t}((\frac{1}{t})^6+1)}\frac{1}{t^2}\,dt=\int \frac{t^5}{1+t^6}\,dt
就变成第一类换元积分了

特殊例子
看似一般的根式，凑成可以三角代换的式子

例题\int \sqrt{2x-x^2}\,dx
先凑一下，得到$\int \sqrt{1-(x-1)^2}\,dx$
然后就会计算了
关注ZestfulYK喵，谢谢喵！


]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>有理函数积分</title>
    <url>/ZestfulYK-blog/2025/12/07/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E7%AC%94%E8%AE%B02%EF%BC%88%E6%9C%89%E7%90%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%83%A8%E5%88%86%E7%A7%AF%E5%88%86%EF%BC%89/</url>
    <content><![CDATA[基本方法
凑成能第一类换元积分的式子  例如$\frac{1}{…}$类的部分分式分解有理函数积分适用条件

有理函数积分当被积函数是有理函数（两个多项式的商）时：$\int \frac{Q(x)}{P(x)}\,​dx$其中 $P(x)$ 和 $Q(x)$ 都是多项式。



分母可因式分解



部分分式分解是处理有理函数积分的系统方法，特别适用于：

分母可明确因式分解
没有更简单的特殊技巧
需要精确解析表达式

当分母 $Q(x)$ 可以分解为一次因式和不可约二次因式的乘积时：

一次因式：$(x-a)$
不可约二次因式：$(x^2+px+q)$，其中 $p^2-4q&lt;0$具体分解规则对于一次因式 $(x-a)^k$：

对应部分为：
\frac{A_1}{x-a}+\frac{A_2}{(x-a)^2}+···+\frac{A_k}{(x-a)^k}对于二次因式 $(x^2+px+q)^m$：\frac{B_1x+C_1}{x^2+px+q}+\frac{B_2x+C_2}{(x^2+px+q)^2}+···+\frac{B_mx+C_m}{(x^2+px+q)^k}但是，在这个部分有一种特殊情况，就是二次式:
\int \frac{P(x)}{Q(x)^2}
在这里，可以把函数看成$\frac{d}{dx}\frac{Ax+B}{Q(x)}+\frac{C}{Q(x)}$两种方法实际上是等价的，因为最后必然化成一个简单的倒数积分和简单的分数积分$\frac{1}{Q(x)}$。

例子：
计算$\int \frac{x^2+1}{(x^2+x+1)^2}\,dx$有两种方式，都能得到答案。1.用标准公式计算得到:\int \frac{x}{(x^2+x+1)^2}\,dx-\int \frac{1}{x^2+x+1}\,dx

接着再分别计算前后的积分，前面得到的是一个分式加上一个含$\arctan x$的式子比较麻烦，不过对于这类题目，我们知道一定能得到第二种简单的方法的式子，所以经过计算得到:
\frac{1}{3}\frac{d}{dx}\frac{x+2}{x^2+x+1}-\frac{4}{3}\int · \frac{1}{x^2+x+1}\,dx这种解法的好处是，得到前半段以后可以直接当作积分结果，不需要额外的处理。
判断步骤第一步：检查是否为真分式
如果 $\deg P(x) \geq \deg Q(x)$：先进行多项式除法（大除法）
如果 $\deg P(x) &lt; \deg Q(x)$：直接进行部分分式分解就是说最高项次数小就能用这个方法第二步：因式分解分母将分母 $Q(x)$ 完全分解为：
一次因式 $(x-a_i)^{k_i}$
不可约二次因式 $(x^2+p_jx+q_j)^{m_j}$第三步：确定分解形式根据因式分解结果，写出部分分式的一般形式。在计算过程中，可以通过给x赋值来快速计算带定值

具体例子分析例1：$\int \frac{x^3+1}{(x^2+1)^2} dx$
分母：$(x^2+1)^2$（二次因式的平方）
分解形式：$\frac{Ax+B}{x^2+1} + \frac{Cx+D}{(x^2+1)^2}$

例2：$\int \frac{1}{x(x-1)^2} dx$
分母：$x(x-1)^2$（一次因式及其平方）
分解形式：$\frac{A}{x} + \frac{B}{x-1} + \frac{C}{(x-1)^2}$

例3：$\int \frac{x^2+1}{x(x^2+4)} dx$
分母：$x(x^2+4)$（一次因式 + 二次因式）
分解形式：$\frac{A}{x} + \frac{Bx+C}{x^2+4}$

例4：$\int \frac{x+1}{x^2+4x+6}\,dx$这个题目看起来和裂项十分相似，但是分母无法因式分解，所以这个方法是不对的。注意到这里上方的次数正好是分母求导结束后的次数，所以游客能采取分开计算的方法。这里首先先把上面的分析翻倍，（因为分母的导数是$2x+4$），接下来在加一个2，减一个2外面再配上$\frac{1}{2}$即可。所以式子变为:$\frac{1}{2} \int \frac{2x+4-2}{x^2+4x+6}\,dx$然后两个部分正好都是我们能计算的第一类换元积分，完成！

$\int \frac{f’(x)}{f(x)} dx$：直接得到 $\ln|f(x)|$
$\int \frac{1}{x^2+a^2} dx$：直接得到 $\frac{1}{a}\arctan\frac{x}{a}$

个人技巧
对于一般的式子，通常是去凑积分，先对其1次项，再分离常数项，这样就能直接得到一个ln积分和一个形如$\frac{p}{t^2+a^2}$的式子了，这个是很好积分的($\arctan x$)
遇到三次式子，可能配凑一个$\pm 1$来计算
遇到分母次数很高的，考虑倒代换
其余的式子，直接展开就行了

三角代换部分重要公式当取$\tan x=u$时
\begin{cases}
\sin x=\frac{u}{\sqrt{1+u^2}} \\
\cos x=\sqrt{1+u^2}
\end{cases}当取$\tan \frac{x}{2}=u$时
\begin{cases}
\sin x=\frac{2u}{1+u^2} \\
\cos x=\frac{1-u^2}{1+u^2}
\end{cases}然后不要忘记，第二类换元积分是需要乘上对应的导数的，这个导数是t关于x的函数，乘上的是含有t的导数之后像前面一样计算就行了。
题型分类
只含有一种三角函数的，用第一类换元积分，例如：$\int \frac{1}{\sin x^4}\,dx$
上下均有且为一次式的，用上节课的方法代换，例如$\int \frac{\sin x}{\sin x+\cos x}\,dx$
同名三角函数相加，和差化积，例如$\int \frac{1}{\sin x+\sin 3x}\,dx$
正常幂(不含分母的)，按奇偶正常拆分
分母含有高次项的，拆解1，例如$\int \frac{1}{\sin x\cos x^2}$主要是把$\cos x$化成$\tan x$来计算。例如：1\int \frac{dx}{a^2+\sin x^2+b^2+\cos x^2}=\int \frac{\frac{1}{\cos x^2}}{a^2\tan x^2+b^2}\,dx=\int \frac{1+\tan x^2}{a^2\tan x^2+b^2}\,dx根式的代换

重要公式令
t=\sqrt[n]{ax+b}令
t=\sqrt[n]{\frac{ax+b}{cx+d}}令
t=\sqrt[mn]{ax+b}看含有什么来决定怎么设t最后反解出x带入其余部分即可。
重要例题根式代换类型求下面这个函数的积分
\int \frac{dx}{\sqrt[n]{(x-a)^{n+1}(x-b)^{n-1}}}\,dx方法：先提取部分，构造类似上面2的一个式子，然后再考虑代换。
\text{原式}=\int\frac{1}{(x-a)(x-b)\sqrt[n]{\frac{x-a}{x-b}}}\,dx不过接下来直接解出x再带回比较麻烦，所以考虑直接算出$\frac{dx}{(x-a)(x-b)}$这个部分
t^n=\frac{a-b}{(x-b)^2}\frac{nt^n\,dt}{t}=\frac{a-b}{(x-b)^2}\,dx\frac{n\,dt}{t}=\frac{a-b}{(x-b)^2t^n}\,dx=\frac{a-b}{(x-a)(x-b)}\,dx所以得到原式变为：
-\frac{n}{a-b}\sqrt[n]{\frac{x-b}{x-a}}重要例题偶数次幂分数类型方法是化为平方分之括号内函数的导数即：
\int \frac{f'(x)}{f(x)^2+a}例如：
\int \frac{1}{x^4+1}\,dx=\frac{1}{2}\int\frac{1+\frac{1}{x^2}-1}{x^2+\frac{1}{x^2}}=\frac{1}{2}(\int \frac{d x-\frac{1}{x}}{(x-\frac{1}{x})^2+2}+\int \frac{d x+\frac{1}{x}}{(x+\frac{1}{x})^2+2})=\frac{1}{2\sqrt{2}}\arctan \frac{x-\frac{1}{x}}{\sqrt{2}}-\frac{1}{4\sqrt{2}}\ln|\frac{x^2-\sqrt{2}x+1}{x^2+\sqrt{2}x+1}| 所以类似于$\frac{\text{二次}}{\text{四次}}$的式子，理论上都有可能用这种方式解决
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/ZestfulYK-blog/2026/01/26/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[二分查找是常见的算法,但是我发现我经常无法区分应当使用哪种变形来计算答案,因此这里做一下讲解.
标准写法ll l=___,r=___;while(l&lt;=r)&#123;	ll mid=l+(r-l)&gt;&gt;1;	if(____) l=mid+1;	else r=mid-1;&#125;
判断条件的选择判断条件可以理解为,每次要淘汰哪一部分,并通过l,r指针的移动来确定的
前提条件:假设现在我们有一个升序的数组
比如:我现在要查找第一个大于等于key的值那么我们的条件就应该是每次循环都删去小于key的值,不能删去大于的,因为答案可能在这里面
于是我们的条件就写成:if(a[mid]&lt;key) l=mid+1;为什么是mid+1?因为l表示的是左边界,左边界移动了,就相当于淘汰了左边的小于key的值
同理,我们在写找第一个大于当前值时,只要改成&lt;=即可
那么反过来呢?
没错,把条件和操作全反过来即可.现在我们要找第一个小于等于key的值所以我们每次淘汰的是大于key的值
条件变为:if(a[mid]&gt;key) r=mid-1;
答案的取值弄清楚了怎么写条件,我们还需要弄清楚最后l还是r指向的才是答案.
我的方法是,假设第一次指向的就是正确答案,那么哪个指针指向就是正确答案.所以也是就if对应的变化的指针,就是答案.
比如查找大于等于key时,if条件后面变化的是l,所以答案就是l所对应的值.
其他技巧学习二分主要的目的不是为了二分查找,而是为了二分答案.判断条件有可能会更复杂.但是核心还是上面哪两点,首先知道我要删的是什么,其次答案会等于什么位置
最后,使用二分时不要忘记检查数据是否以及排序,答案是否一定满足升序关系,再加上适量的边界检查,二分就能拿下啦!
C++自带的二分C++中,能使用lower_bound和upper_bound的有set,multi_set(多重集合),数组,vector
前者查找第一个大于等于key的值,后者找第一个大于key的值(先保证数组有序才行)
那么小于或小于等于呢?
小于可以先查大于等于的,再向前一步小于等于可以先查大于的,再向前一步
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列函数的应用</title>
    <url>/ZestfulYK-blog/2025/10/22/%E5%85%A8%E6%8E%92%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[全排列函数什么是全排列？简单来说就是排列组合的所有情况，并按照字典顺序输出例如：123全排列的结果为
123132213231312321
而实际上全排列需要在代码中用复杂的深度搜索来写这实在是太复杂了！！！于是我就发现了全排列函数这个东西^__^现在我们就来学习一下这个高级函数————next_permutation
全排列函数#include &lt;iostream&gt;  #include &lt;algorithm&gt;  using namespace std;  int main()  &#123;      int num[3]=&#123;1,2,3&#125;;      do      &#123;          cout&lt;&lt;num[0]&lt;&lt;&quot; &quot;&lt;&lt;num[1]&lt;&lt;&quot; &quot;&lt;&lt;num[2]&lt;&lt;endl;    &#125;while(next_permutation(num,num+3));      return 0;  &#125;

全排列函数详细定义对于next_permutation函数，其函数原型为：
include   bool next_permutation(iterator start,iterator end)


当当前序列不存在下一个排列时，函数返回false，否则返回true

全排列函数的特性

next_permutation(num,num+n)函数是对数组num中的前n个元素进行全排列，同时并改变num数组的值。
另外，需要强调的是，next_permutation()在使用前需要对欲排列数组按升序排序，否则只能找出该序列之后的全排列数。比如，如果数组num初始化为2,3,1，那么输出就变为了：231312321
全排列函数的应用题目链接
题目要求我们按要求完成5*5数独，且只要填ABC，可以有空格子一种方法是遍历每一个格子，逐个填入，时间复杂度(4^25)，显然不行不过我的朋友使用了大量剪枝，最后还是过了%%%大佬 qinye_leaf
代码链接
但是我们刚学了全排列函数，就不能使用一下吗？你别说，还真能使用！我们只要先填写每一行，然后就只用40^5就能计算完了因为可以加上一个判断，看看每一行是否符合标准(也算剪枝吧)
vector&lt;string&gt; eachrow(int row) &#123;    vector&lt;string&gt; result;    string h=string(n-3,&#x27;.&#x27;)+&quot;ABC&quot;;    do&#123; for(int i=0;i&lt;n;i++)&#123;        if(h[i]!=&#x27;.&#x27;)&#123;            if(h[i]==r[row]) result.push_back(h);            break;        &#125;    &#125;    &#125;while(next_permutation(h.begin(),h.end()));    return result;&#125;
那么这样我们就能得到每一行的可能情况，每行40种之后就可以正常的DFS了
个人AC代码链接
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二阶差分</title>
    <url>/ZestfulYK-blog/2025/02/24/%E4%BA%8C%E9%98%B6%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[用于处理在一个数组的连续区间上进行等差序列的增减
例如:给1-5这个区间增加12345
多次操作后,问数组的最终值
方法就是二阶差分,推导一下就行
              变化值               下标数组 	0 1 2 3 4 5   6 7 8 9 10初始     0 0 0 0 0 0   0 0 0 0 0变化     0 1 3 5 7 9   0 0 0 0 0一阶     0 1 2 2 2 2  -9 0 0 0 0二阶     0 1 1 0 0 0 -11 9 0 0 0
所以规律:
ll d=(e-s)/(r-l);//s第一个位置的值,e最后一个位置的值,r,l是区间范围b[l]=b[l]+s;b[l+1]=b[l+1]+d-s;b[r+1]=b[r+1]-(d+e);b[r+2]=b[r+2]+e;
然后难一点的话就是阶梯型的修改如123454321这种,然后再不保证l,r一定在范围内,自己推导就行
vector&lt;ll&gt; d(n+5,0);for(int i=1;i&lt;=mid;i++)&#123;  ll p=keng[i].fs,f=keng[i].sd;  d[p+1]-=2;  if(p+f+1&lt;=n) d[p+f+1]+=1;  if(p-f+1&gt;=0) d[p-f+1]+=1;  else&#123;    ll s=f-p+1;    d[1]+=s;    d[2]+=1-s;  &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分步积分笔记</title>
    <url>/ZestfulYK-blog/2025/12/07/%E5%88%86%E6%AD%A5%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[核心公式\int u\,dv = uv - \int v\,du选择原则：”反对幂指三”优先级从高到低选择 $u$：

反三角函数（$arcsin$,$arccos$, $arctan$等）
对数函数（$\ln x$, $log x$等）
幂函数（$x^n$, $x^2$, $\sqrt{x}$等）
指数函数（$e^x$, $a^x$等）
三角函数（$\sin x$, $\cos x$等）

口诀解释：越靠前的类型越优先选为 $u$，越靠后的类型越优先放入 $dv$。

经典类型与解法类型1：幂函数 × 三角函数$\int x^n\cos x\,dx$ 或 $\int x^n\sin x\,dx$

将三角函数放入 $dv$（如 $\cos x\,dx = d(\sin x)$）
通过 $n$ 次分部积分逐次降幂

类型2：幂函数 × 指数函数$\int x^n e^{ax}\,dx$

将指数函数放入 $dv$（如 $e^{ax}\,dx = \frac{1}{a}d(e^{ax})$）
逐次降幂至 $x^0$

类型3：幂函数 × 对数函数$\int x^n \ln x\,dx$

将对数函数选为 $u$（$\ln x$ 求导得 $\frac{1}{x}$，可消去 $x$ 幂）
幂函数放入 $dv$

类型4：指数函数 × 三角函数$\int e^{ax}\sin(bx)\,dx$ 或 $\int e^{ax}\cos(bx)\,dx$

任选其一放入 $dv$（通常选三角函数）
两次分部积分后出现循环，解方程求得原积分


高级技巧与注意事项技巧1：隐藏的 $dv$当被积函数为分式时，常将分母或其部分放入 $dv$：
\int \frac{x\arcsin x}{\sqrt{1-x^2}}\,dx令 $u=\arcsin x$，$dv=\frac{x}{\sqrt{1-x^2}}dx$，则 $v=-\sqrt{1-x^2}$
技巧2：凑微分调整对于 $\int \frac{x}{e^{2x}}\,dx$，可改写为 $\int x e^{-2x}\,dx$

令 $u=x$，$dv=e^{-2x}dx$
则 $du=dx$，$v=-\frac{1}{2}e^{-2x}$
代入公式：$-\frac{1}{2}xe^{-2x} + \frac{1}{2}\int e^{-2x}dx$

技巧3：多次分部积分\int x^2 e^x\,dx = x^2 e^x - 2\int x e^x\,dx需连续使用分部积分，直到幂函数降为常数
技巧4：递推关系某些积分可建立递推公式：
\int x^n e^x\,dx = x^n e^x - n\int x^{n-1} e^x\,dx技巧5：组合拆分对于 $\int e^x(\sin x + \cos x)\,dx$，可拆分为两个分部积分，但更简单的方法是观察导数关系：$d(e^x \sin x) = e^x(\sin x + \cos x)dx$

常见易错点
符号错误：公式中的减号易漏写
$v$ 计算错误：求 $v$ 时积分常数可省略（因最后会抵消）
选择不当：违反”反对幂指三”可能导致积分更复杂
循环处理：$\int e^x \sin x\,dx$ 类问题，移项时注意系数


典型例题例1：对数函数\int \ln x\,dx = x\ln x - \int x\cdot\frac{1}{x}dx = x\ln x - x + C例2：反三角函数\int \arcsin x\,dx = x\arcsin x - \int \frac{x}{\sqrt{1-x^2}}dx = x\arcsin x + \sqrt{1-x^2} + C例3：循环积分\int e^x \sin x\,dx
第一次：$u=\sin x$，$dv=e^x dx$，得 $e^x \sin x - \int e^x \cos x\,dx$
第二次：对 $\int e^x \cos x\,dx$ 再分部积分
得方程：$I = e^x \sin x - e^x \cos x - I$
解得：$I = \frac{e^x(\sin x - \cos x)}{2} + C$

例4：含负指数\int \frac{\arctan e^x}{e^{2x}}\,dx = -\frac{1}{2}\int \arctan e^x\,d(e^{-2x})令 $u=\arctan e^x$，$dv=d(e^{-2x})$，需注意 $du=\frac{e^x}{1+e^{2x}}dx$

特殊情形处理
只有一类函数：如 $\int \ln x\,dx$，视为 $1\cdot\ln x\,dx$
乘积含三个因子：先组合两个放入 $dv$，或换元简化
分母复杂：考虑整体代换或分部积分后消去分母
定积分：计算时先求原函数，注意上下限代入

还有更重要的一点是不要被形式迷惑了双眼，$\frac{1}{\cos x^2}$是什么啊？不认识？这就不对了我认为，直接先表示回去就行了，这下认出来了（然后看到对$\sec x$求导时不要忘记公式，还在企图自己推导
商的导数逆运算（反向商法则）在积分中，有时会遇到形如 $\frac{u’v - uv’}{v^2}$ 的被积函数，这正是商函数 $\left( \frac{u}{v} \right)’$ 的导数。因此，可以直接写出原函数 $\frac{u}{v} + C$。

核心识别技巧
分母为平方形式：通常为 $v^2$ 或可化为 $v^2$。
分子为两项之差：且每项均为两个函数的乘积（即 $u’v$ 和 $uv’$）。
找出 $u$ 和 $v$：从分母中猜测 $v$（通常为分母的“一部分”），再根据分子确定 $u$。


一般步骤设被积函数为 $\frac{P(x)}{Q(x)}$：

尝试将 $Q(x)$ 写成 $v^2$ 的形式（或类似）。
观察 $P(x)$ 是否能表示为 $u’v - uv’$。
若可以，则积分结果为 $\frac{u}{v} + C$。例题：\int\frac{xf'(x)-(1+x)f(x)}{x^2e^x}\,dx


分母：$x^2 e^x = (x e^x)^2 \cdot e^{-x}$？实际上，直接考虑函数 $\frac{f(x)}{x e^x}$ 的导数。
设 $v = x e^x$，则 $v’ = (1+x)e^x$。
设 $u = f(x)$，则 $u’ = f’(x)$。
计算 $\left( \frac{u}{v} \right)’ = \frac{u’v - uv’}{v^2} = \frac{f’(x) \cdot x e^x - f(x) \cdot (1+x)e^x}{(x e^x)^2} = \frac{x f’(x) - (1+x)f(x)}{x^2 e^x}$。
因此，原积分 $= \frac{f(x)}{x e^x} + C$。

常用构造
对于 $\int \frac{f’(x)g(x) - f(x)g’(x)}{g(x)^2} dx$，结果为 $\frac{f(x)}{g(x)} + C$。
对于 $\int \frac{f’(x)g(x) - f(x)g’(x)}{[g(x)]^n} dx$（$n \neq 2$），通常需要调整。

]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>几何计算习题笔记</title>
    <url>/ZestfulYK-blog/2025/12/11/%E5%87%A0%E4%BD%95%E8%AE%A1%E7%AE%97%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[凹凸多边形的判断重要知识：叉积几何意义：符号代表了叉积两个向量的转向： > 0 逆时针 &lt; 0 顺时针 = 0 共线
基本原理对于连续三个点A、B、C：叉积 = (B.x - A.x)  (C.y - B.y) - (B.y - A.y)  (C.x - B.x)要是是向量的话是：a.x  b.y- a.y  b.x
这个叉积实际上计算的是向量 AB 到向量 BC 的旋转方向。
实现方法可视化解释考虑四边形$ABCD$，我们按顺序（如逆时针）检查每个顶点：
如果所有顶点的叉积都保持同号（全部为正或全部为负），说明多边形所有顶点都朝同一个方向”拐弯”，这就是凸多边形。
C(2,2) ────── D(0,2)│              ││              │B(2,0) ────── A(0,0)
在顶点A处：

向量DA = A - D = (0-0, 0-2) = (0, -2)
向量AB = B - A = (2-0, 0-0) = (2, 0)
DA × AB = 0 0 - (-2) 2 = 4 &gt; 0（逆时针）

在顶点B处：

向量AB = (2, 0)
向量BC = C - B = (2-2, 2-0) = (0, 2)
AB × BC = 2 2 - 0 0 = 4 &gt; 0（逆时针）

凹四边形的反例对于凹四边形，某个顶点会出现相反的转向：
     D(1,2)    /B(1,1) ← 凹点A(0,0)─-───────C(3,0)  
在凹点B处，转向会与其他顶点相反。
算法实现步骤
计算各个叉积

cp₁ = 叉积(向量AB, 向量BC)  // 在点B处cp₂ = 叉积(向量BC, 向量CD)  // 在点C处cp₃ = 叉积(向量CD, 向量DA)  // 在点D处cp₄ = 叉积(向量DA, 向量AB)  // 在点A处


判断符号一致性：
如果所有$cp_i \geq 0$，则为逆时针排列的凸四边形
如果所有$cp_i\leq 0$，则为顺时针排列的凸四边形
否则为凹四边形





实例代码struct point&#123;double x,y;&#125;;double chaji(const point &amp;a,const point &amp;b,const point &amp;c&#123;  point v1,v2;//计算向量  v1.x=b.x-a.x; v1.y=b.y-a.y;  v2.x=c.x-b.x; v2.y=c.y-b.y;  return v1.x*v2.y-v1.y*v2.x;  //转换成向量以后，x和y交换着乘&#125;void solve()&#123;  point a,b,c,d;  cin&gt;&gt;a.x&gt;&gt;a.y;  cin&gt;&gt;b.x&gt;&gt;b.y;  cin&gt;&gt;c.x&gt;&gt;c.y;  cin&gt;&gt;d.x&gt;&gt;d.y;  double cj1=chaji(a,b,c);  double cj2=chaji(b,c,d);  double cj3=chaji(c,d,a);  double cj4=chaji(d,a,b);  if((cj1&gt;0&amp;&amp;cj2&gt;0&amp;&amp;cj3&gt;0&amp;&amp;cj4&gt;0)||(cj1&lt;0&amp;&amp;cj2&lt;0&amp;&amp;cj3&lt;0&amp;&amp;cj4&lt;0))&#123;    cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;//要同号才行  &#125;  else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125;signed main()&#123;    solve();    return 0;&#125;
直线的计算写在前面的话傻逼C++的double的精度不高所以表示直线建议使用$Ax+By+C=0$
然后就变简单了喵~
计算公式\begin{cases}
A=p2_y-p1_y \\
B=p1_x-p2_x \\
C=p2_x*p1_y-p1_x*p2_y
\end{cases}之后不要忘记除以他们的最大公约数，用来去重，这点非常重要，因为可能产生倍数
例题K-colinear Line
这一题要求我们计算经过k个点的直线数量，这里最重要的是理解怎么消去除法。这题的做法还是蛮多样的，好友qinye_leaf的解法是：
(x_1-x_0)(y-y_0)==(y_1-y_0)(x-x_0)->\frac{x_1-x_0}{x-x_0}=\frac{y_1-y_0}{y-y_0}此外上面的做法也是可行的，总之消去除法，然后防止重复(这是一个好问题)
圆的计算$\pi$的取值建议
如果有了规定值，那么直接使用
没有的话，处于精度考虑，可以使用$\arccos (1.0)$来代替、多边形的计算

几何图形面积计算例一例题：P. Area of a Star需要我们计算多角形的面积这一题的话有两种做法，一种是直接分成$2*n$个小三角形，而每一个三角形的三个内角都是已知的，因此可以直接计算。另外一种做法是发现可以整体减空白，稍微复杂一点，但也可行。
补充知识复习一下正弦定理：
\frac{a}{\sin \alpha}=\frac{b}{\sin \beta}=\frac{c}{\sin \gamma}=2R因此这一题只知道三个角和一条边是可以直接计算的。
例二例题：B. Mister B and Angle in Polygon需要我们在多边形上找到三个点，使得构成的角度和给定角度最接近。
重要观察：在正n边形中，从一个顶点出发，连接所有其他不相邻的顶点（即除相邻两个顶点外的所有顶点），这些连线会将这个顶点的内角等分成$n−2$个相等的角，每个角的度数为 $\frac{180}{n}$。

证明：把多边形放到一个圆里面，然后发现相同弦所对的角相等，所以原命题是成立的

推论：那么在这个多边形上任取三个点构成的角也必然是$\frac{180}{n}$.

证明：和刚才一样，只要证明每个条角所对的弦都能在同一个顶点上构造出来

所以解出这题的步骤是：

先看是否大于等于最大角，如果是，那么输出1 2 3
否则计算中间值用$\frac{180}{n}$的倍数代替。

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和笔记</title>
    <url>/ZestfulYK-blog/2025/12/08/%E5%89%8D%E7%BC%80%E5%92%8C%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[前缀和定义
前缀和（Prefix Sum）是一种重要的预处理技术，能在O(1)时间内查询区间和，在算法竞赛和面试中应用广泛。以下是前缀和的主要应用场景和变种：
1. 基本前缀和
计算$\Sigma_{i=1}^n a_i$的值，用来求区间和


例如：// 一维前缀和vector&lt;int&gt; pre(n+1, 0);for (int i = 1; i &lt;= n; i++) &#123;    pre[i] = pre[i-1] + a[i];&#125;// 查询区间[l, r]的和int sum = pre[r] - pre[l-1];
2. 二维前缀和用于计算矩阵的和$\Sigma{i=1}^n\Sigma{j=1}^na_{ij}$
vector&lt;vector&lt;int&gt;&gt; pre(m+1, vector&lt;int&gt;(n+1, 0));for (int i = 1; i &lt;= m; i++) &#123;    for (int j = 1; j &lt;= n; j++) &#123;        pre[i][j] = a[i][j] + pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1];    &#125;&#125;// 查询子矩阵(x1,y1)-(x2,y2)的和int sum = pre[x2][y2] - pre[x1-1][y2] - pre[x2][y1-1] + pre[x1-1][y1-1];
前面两个的例题比较多，则行里就不举例了。

3. 前缀和与哈希表结合这是最常用的变种，用于解决”区间和为k的区间个数”问题：
int countSubarrays(vector&lt;int&gt;&amp; nums,int k) &#123;    unordered_map&lt;int,int&gt; mp; // 前缀和 -&gt; 出现次数    mp[0] = 1; // 空数组的前缀和为0    int sum=0,count=0;    // sum拿来求前缀和，count求和为k的次数    for(int num:nums)&#123;        sum+=num;        // sum - target = pre[j]  =&gt; pre[j] = sum - k        if(mp.find(sum-k)!=mp.end())            count+=mp[sum-k];        mp[sum]++;    &#125;    return count;&#125;
上面的代码思路解释，首先，先计算前缀和的值，然后加到map里面，之后看有没有出现过sum-k这种前缀和，如果有，那么这一段的和就是k了，且有$mp[sum-k]$个，这样就计算出了答案
例如：K-大师和他的领域这一题要我们找存在几个区间满足既含有k又满足k是这个区间的中位数。那么步骤：1.令小于k的为-1，大于k的为1，等于k的为02.计算前缀和，统计前缀和一样的区间，这样区间内的和为0，说明k是这个区间的中位数，再使用$\Sigma{i=1}^{map.size()}C{m_i}^2$计算总数就行了，这样得到可能的区间。3.但是还要保证区间内包含k，所以找到k位置，在两个k间的需要再用相同方法计算一次，4.最后减去即可
就是说，要统计合法区间时，都可以把题目的要求变形一下，然后就可以使用这个思路了
4. 前缀和与差分数组差分数组用于区间修改，单点查询：这一个没什么好说的，就是差分和前缀的互逆关系
// 初始化差分数组vector&lt;int&gt; diff(n+2, 0);diff[1] = a[1];for (int i = 2; i &lt;= n; i++) &#123;    diff[i] = a[i] - a[i-1];&#125;// 区间[l, r]增加valvoid rangeAdd(int l, int r, int val) &#123;    diff[l] += val;    diff[r+1] -= val;&#125;// 恢复原数组for (int i = 1; i &lt;= n; i++) &#123;    a[i] = a[i-1] + diff[i];&#125;
5. 前缀最大/最小值// 前缀最大值vector&lt;int&gt; preMax(n+1, INT_MIN);for (int i = 1; i &lt;= n; i++) &#123;    preMax[i] = max(preMax[i-1], a[i]);&#125;// 后缀最小值vector&lt;int&gt; sufMin(n+2, INT_MAX);for (int i = n; i &gt;= 1; i--) &#123;    sufMin[i] = min(sufMin[i+1], a[i]);&#125;
6. 前缀异或和用于处理区间异或问题：
vector&lt;int&gt; xorPre(n+1, 0);for (int i = 1; i &lt;= n; i++) &#123;    xorPre[i] = xorPre[i-1] ^ a[i];&#125;// 区间[l, r]的异或和int xorsum = xorPre[r] ^ xorPre[l-1];
7.二维差分数组// 初始化二维差分vector&lt;vector&lt;int&gt;&gt; diff(m+2, vector&lt;int&gt;(n+2, 0));// 子矩阵(x1,y1)-(x2,y2)增加valvoid rangeAdd2D(int x1, int y1, int x2, int y2, int val) &#123;    diff[x1][y1] += val;    diff[x2+1][y1] -= val;    diff[x1][y2+1] -= val;    diff[x2+1][y2+1] += val;&#125;// 恢复原矩阵vector&lt;vector&lt;int&gt;&gt; res(m+1, vector&lt;int&gt;(n+1, 0));for (int i = 1; i &lt;= m; i++) &#123;    for (int j = 1; j &lt;= n; j++) &#123;        res[i][j] = res[i-1][j] + res[i][j-1] - res[i-1][j-1] + diff[i][j];    &#125;&#125;
然后很重要的一点是，有时可能是假设前缀和数组，最后再反推原数组来进行构造。
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>华中农业达大学迎新赛题解与反思</title>
    <url>/ZestfulYK-blog/2025/12/07/%E5%8D%8E%E4%B8%AD%E5%86%9C%E4%B8%9A%E8%BE%BE%E5%A4%A7%E5%AD%A6%E8%BF%8E%E6%96%B0%E8%B5%9B%E9%A2%98%E8%A7%A3%E4%B8%8E%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[M-终极考验
这题的大致思路是对的，但是最后处理差分时，直接选择了min(i+x,n)，这个就不对了，因为我们要的不是二选1，而是只有在满足要求时才处理。所以把min改成if判断就行了，下次需要注意这个逻辑问题。
H-对决
这个题目是纯暴力的搜索题，那么只要一个一个判断就好了，但是此处注意循环范围是$\leq n-4$而不是$&lt;n-4$.最好自己先之上推导一下再提交
B-爱的魔法
这一题一开始的错误原因是没有注意到交换最接近的会导致得到的不是最大的数字，例如1999，交换以后是9199是不对的，所以要倒遍历。建议自己先多造几组数据再提交，包括一些边界情况等等。随机数也不错（较小范围能手推的）
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>压行技巧</title>
    <url>/ZestfulYK-blog/2025/10/24/%E5%8E%8B%E8%A1%8C%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[如何给你的代码压行？如果不会压行，你的代码看起来会是这样的：
int ml(vector&lt;int&gt; s, int n)&#123;    int m = s[0];    for (int i = 0; i &lt;= n; i++)    &#123;        if (s[i] &gt; m)            m = s[i];    &#125;    return m;&#125;
整整用了9行！实际上其实根本不需用那么多行：int ml(vector&lt;int&gt; s,int n)&#123;    int m=s[0];    for(int i=0;i&lt;=n;i++)&#123;        if(s[i]&gt;m)m=s[i];    &#125;    return m;&#125;
当然也可以更短：int ml(vector&lt;int&gt; s,int n)&#123;    int m=s[0];    for(int i=0;i&lt;=n;i++) if(s[i]&gt;m) m=s[i];    return m;&#125;那么问题来了，怎么在不影响代码运行的情况下合理的压行呢？
判断类循环类的压行技巧判断类如果判断语句仅一行，可以考虑压行：
if(a==1) sum++;else sum--;//或者这样if(a==1)    sum++;//可以通过缩进来方便区分
两句的话，压行可以考虑用大括号包起来压行前提是你觉得看着没影响
if(a==1) &#123;sum++;a=2;&#125;
注意在大括号里的每一句都是要加上封号的，因为这一段代码实际上等价于：
if(a==1)&#123;    sum++;    a=2;&#125;
循环类压行也和判断的一样，可以这么压行：
for(int i=1;i&lt;=n;i++) cout&lt;&lt;1&lt;&lt;endl;//或者这样：for(int i=1;i&lt;=n;i++)    cout&lt;&lt;1&lt;&lt;endl;
如果是输出的话，其实可以这么写：
for(int i=1;i&lt;=n;i++) cout&lt;&lt;i&lt;&lt;&quot; &quot;; cout&lt;&lt;endl;
因为C++cout&lt;&lt;endl;其实是在循环之外的，所以这么写是正确的
头文件压行下面送给大家万能头文件：
#include&lt;bits/stdc++.h&gt;
其他技巧#define ll long long#define rep(1,n) for(int i=1;i&lt;=(n);i++)ll n;int main()&#123;    rep(1,n) cout&lt;&lt;&quot;*&quot;; cout&lt;&lt;endl;&#125;
通过define来减少代码长度，增加可读性
一些非常有用的C++自带函数sort(a,a+n);//a为数组，n为a的大小__gcd(x,y);//x，y的最大公约数x=1&lt;&lt;n;//2的n次方
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM集训队训练,同构图挑战</title>
    <url>/ZestfulYK-blog/2025/02/24/%E5%90%8C%E6%9E%84%E5%9B%BE%E6%8C%91%E6%88%98/</url>
    <content><![CDATA[定义路径的权值为路径上最大的边权,两点的距离定义为所有路径中权值的最小值
给定两张图,判断两张图之间每两个点的距离是否对应相等
思路自环对距离的影响为:增大路径的权值,所以自环没有作用,可以删去图上的环对距离的影响为:因为我们最后总是会选择较短的路,因此所有环上的最大边可以删去重边相当于一种特殊的环,选择最小的那一个留下就行
那么经过处理以后,这个无向图貌似变成了一颗最小生成树?
不用怀疑,这就是最小生成树森林!
那么怎么证明呢?
我发现一个类似的算法:反向删除构建最小生成树构建过程具体如下:按边权从大到小依次删去边,要是不影响连通性则删去,最后得到最小生成树
应用在这一题,我们破环相当于删去了不影响连接性的一条边权较大的边,所以最后得到的就是最小生成树
而我们需要判断距离是否一样,那么只要其最小生成森林一样就行
因为此处已经得出结论,只要算出最小生成树,问题就解决了一半,所以接下来正向考虑每一条边加入图中对距离的影响
在两张图中同时进行最小生成树算法,要是这两条边的边权一样,连起的区块相同,那么所有点在两张图的距离仍对应相等
证明(DeepSeek):

这是因为在按权值从小到大逐步添加边的过程中，每一步合并相同的连通分量（区块），使得任意两点首次连通时的边权值相同。而两点间的最小瓶颈距离正是它们首次连通时的边权值（若始终不连通则为无穷）。因此，对于任意两点，它们在两张图中的距离相等。

但是在算法实现中,这是比较困难的,因为可能构建顺序不完全一致.
方法是把距离相同的边同时操作,每一次操作观察图的连通情况,由此来判断得到的生成树是否一样
按照之前的结论,重边和自环对答案没有影响,因为最后算的反正是连通性,所以不需要特殊处理,这样就简化了操作
比赛中和赛后补题中出现的思路问题在比赛时,我们想到了构建生成树来简化计算,但是停留在每一步相等才行,并没有想到只需要判断连通性就行
最后是计算区块信息的问题,我赛时的想法是通过计算异或和区分每个区块,每个点给予随机值作为初始哈希值,这是对的,但是在赛后计算总连通性时出问题.方法是结合加法,每个区块的和为总哈希
所以最后代码上除了还要学习一下dsu标准写法外没有大问题
总之是一道好题,已严肃补完
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>定积分笔记</title>
    <url>/ZestfulYK-blog/2025/12/10/%E5%AE%9A%E7%A7%AF%E5%88%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[定义式\Sigma_{i=1}^nf(\xi_i)\Delta x_i几何意义曲线和x轴，直线$x=a$,$x=b$围成的面积
用定义式写简单积分例题：\int_0^1x^2\,dx首先先把$[0,1]$分成n等份，每份是$\frac{1}{n}$然后按照定义式，取$x_i=\frac{i}{n},\xi_i=\frac{i}{n}$所以：
\int_0^1x^2\,dx=\Sigma_{i=1}^nf(\xi_i)\Delta x_i=\Sigma_{i=1}^n(\frac{i}{n})^2·\frac{1}{n}=\frac{1}{n^3}\Sigma_{i=1}^ni^2=\frac{1}{n^3}\frac{1}{6}(n+1)(2n+1)=\frac{n(n+1)(2n+1)}{6n^3}=\frac{1}{3}最后记得对n取一下极限就行了
把极限改写成积分形式由于积分是可以转化为极限的，那么同样也可以反过来计算。
例题：这里需要弄清改把什么看作是$\xi_i$,什么又看做是$\Delta x_i$不过通常是取相同的数
1.
\lim_{n\to \infty}\frac{1}{n}\Sigma_{i=1}^n\sqrt{1+\frac{i}{n}}然后会有一个非常重要的观察点，必然会有$\frac{i^a}{n^a}$和$\frac{a}{n}$出现，这就说明了你划分为n份的范围和每个区间的取值情况。
所以对上面这个式子进行变形得到：
\lim_{n\to \infty}\Sigma_{i=1}^n\frac{1}{n}\sqrt{1+\frac{i}{n}}所以每一份是$\frac{1}{n}$,每个区间的取值是$\frac{i}{n}$.答案为：
\int_0^1\sqrt{1+x}但是就一定要这么理解吗？实际上，我们也可以把1-2的区间分成n份，那么每一份还是$\frac{1}{n}$,但是每份的取值变成了$1+\frac{i}{n}$。因此答案也可以是：
\int_1^2\sqrt{x}定积分的性质：性质1\int_a^bf(x)\,dx=-\int_b^af(x)推论\int_a^af(x)=0解释
代数角度$\Delta x_i=\frac{b-a}{n}$所以在上下反转时会变号
几何角度：理解为有向的面积性质2

\int_a^b\,dx=b-a解释
相当于一个矩形的面积，宽是1，长是b-a。性质3 线性性

此性质又称作不定积分的线性性即满足数乘和加减法数乘：
\int_a^bkf(x)\,dx=k\int_a^bf(x)\,dx加减法：
\int_a^bf(x)\pm g(x)\,dx=\int_a^bf(x)\,dx\pm\int_a^bg(x)\,dx实际上，这个性质可以转换为极限的线性性
性质4 拆分定理\int_a^bf(x)\,dx=\int_a^cf(x)\,dx+\int_c^bf(x)\,dx实际上，这个公式就是把要计算的面积拆成多个部分当位置不一样的时候，也可以看成是减去一部分
性质5 保号性不定积分的保号性如果有在$[a,b]$上$f(x)\geq0$那么
\int_a^bf(x)\,dx\geq0其实这又是极限的保号性
然后就有：如果$f(x)\geq g(x)$
\int_a^bf(x)\,dx\geq\int_a^bg(x)\,dx性质6\int_a^bf(x)\,dx\leq ∫_a^b|f(x)|\,dx\,(a]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>多源dfs</title>
    <url>/ZestfulYK-blog/2025/02/12/%E5%A4%9A%E6%BA%90dfs/</url>
    <content><![CDATA[正常的广搜就是一个起点,像树一样按层先法遍历今天我们要学习的是多源广搜.
什么是多源dfs顾名思义,从多个起点开始搜索,也是求最短路的一种方法.
什么时候适用?个人认为是起点不确定,而且终点有多个的情况,
此时终点是确定的,因此只要同时计算,最后每个起点都会被遍历到,得到的就是最短路了
例题1:
给定01矩阵,求每个0到最近的1的距离.
例题2:
有 n 个城市，编号为 1 到 n，城市之间通过 m条无向道路连接，每条道路的边权为 1，对于一个城市的繁华度是该城市所连接的道路数量。我们将每个城市的繁华度列出并去重后，从小到大排序得到 $a_1​,a_2​,…,a_k$​，现在将所有繁华度为 $a_i$(1≤i≤k) 的城市称作 i 级城市。Bingbong 现在需要你帮助他回答对于任意编号为 x(1≤x≤n) 的城市，从该城市出发，前往比该城市级别更高的城市的最短路径长度，或报告无法到达。  
注意：此处 k 级城市为最高级城市。
例题2实现起来可能会有一些麻烦,但是发现一个事情是不存在跨过大繁华度城市达到终点的情况,因此,只要每次从大到小,在路径变短时才需要入队,简化了实现.
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>容斥原理笔记</title>
    <url>/ZestfulYK-blog/2025/12/09/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[容斥原理的定义以及计算方式
容斥原理是十分有用的一种计算方法，通常用于子集统计中
该原理通过交替加减不同层次交集的大小，确保每个元素在并集中只被计算一次。虽然描述中的“只被两个集合重复的”可能指恰好属于两个集合的元素，但容斥原理实际处理的是所有交集（包含属于更多集合的元素），并通过后续的加减进行修正。
原理：整体减空白的思想，不过也有韦恩图的一点思想，当子集数量大于3时，就有些抽象了，这时我们就需要总结一下规律。基本公式

|A_1\cup A_2\cup ··· \cup A_n|=\Sigma|A_i|-\Sigma|A_i\cap A_j|+\Sigma|A_i\cap A_j\cap A_k|+(-1)^{n+1}|A_1\cap A_2 \cap ···\cap A_n|
先加上所有子集，再减去每两个子集的重叠部分，再加上每三个子集的重叠部分···最后再是所有子集的交集。重要观察：每一个求和前面的符号只和选择了几个集合有关，所以在写代码的时候就会变得简单了。代码实现

以题目Count Good Numbers为例：题目要求我们统计因子里不含2,3,5,7的所有在区间$[l,r]$里的数字总量(翻译成人话)那么这不就是容斥原理吗？
ll count_divisible(ll l, ll r, ll d) &#123;    ll first= (l%d==0) ? l : l+d-l%d;  // 第一个能被 d 整除的数    ll last=r-r%d;                         // 最后一个能被 d 整除的数    if (first&gt;last) return 0;                 // 如果没有这样的数    return (last-first)/d+1;&#125;void solve()&#123;    ll l,r;    cin&gt;&gt;l&gt;&gt;r;    int primes[]=&#123;2,3,5,7&#125;;               // 质数数组    ll ans=0;    // 枚举所有子集（包括空集），共 2^4 = 16 个    for(int mask=0;mask&lt;(1&lt;&lt;4);mask++) &#123;        ll d=1;        int cnt=0;                           // 子集中质数的个数        for(int i=0;i&lt;4;i++)&#123;            if(mask&amp;(1&lt;&lt;i))&#123;                d*=primes[i];                cnt++;            &#125;        &#125;        // 根据子集大小的奇偶性决定符号        int sign=(cnt%2==0)?1:-1;        ans+=sign*count_divisible(l,r,d);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;

主要思想：用二进制模拟是否要取得这一个集合，然后统计二进制中1出现的次数，即选择的集合数，来决定要加还是减。这样就大大减少了代码量，简单可维护性高。

备注：整体减空白的思想可以看华农的K题来学习，这里就不再列举了
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>广工月赛</title>
    <url>/ZestfulYK-blog/2025/10/20/%E5%B9%BF%E5%B7%A5%E6%9C%88%E8%B5%9B/</url>
    <content><![CDATA[ZestfulYK的战绩
比赛难度中等，以基础题为主，拼尽全力战胜少量难题
部分代码F
分析很不错的博弈题目，使我的大脑旋转，最后打表做出来了

题目链接

代码:#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123;    ll n,m;    cin&gt;&gt;n&gt;&gt;m;    if(n==0&amp;&amp;m==0) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==1&amp;m==0) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl;    else if(n==2&amp;m==0) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==3&amp;m==0) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==0&amp;m==1) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl;    else if(n==0&amp;m==2) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==0&amp;m==3) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl;//    else if(n==1&amp;m==1) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==1&amp;m==2) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==1&amp;m==3) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl;//    else if(n==2&amp;m==1) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==2&amp;m==2) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==2&amp;m==3) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl;//    else if(n==3&amp;m==1) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==3&amp;m==2) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==3&amp;m==3) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl;&#125;
J
分析这题目也不错，但其实看代码找规律就行了

题目链接

代码:
#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123;    ll n; cin&gt;&gt;n;    ll s=sqrt(n);    if(s*s!=n) s++;    ll last=n%s;    for(int i=last;i&gt;=1;i--) cout&lt;&lt;i&lt;&lt;&quot; &quot;;    for(int j=1;j&lt;=n/s;j++)&#123;        for(int i=last+j*s;i&gt;last+(j-1)*s;i--) cout&lt;&lt;i&lt;&lt;&quot; &quot;;    &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>广度优先搜索变形(dp)</title>
    <url>/ZestfulYK-blog/2025/02/24/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dp)/</url>
    <content><![CDATA[用途:查询最短路,计算答案值范围较小的dp题目
最短路就不解释了,讲讲第二种是怎么回事
题目:给定两个数组a,b($a_i,b_i&lt;2048$),长度为n$(1&lt;n&lt;2048)$,x初始为0,每次允许操作
\begin{cases}
x=max(0,x-a_i)\\ \\
x=x\oplus b[i]
\end{cases}求最后x的最大值
因为a对x的影响是减小,b是增大,异或b以后也不会超过2048,也就是最多2048个答案,那么可以用类似广搜的做法来计算每一步能取到的所有答案,这样就不需要dfs了
所以代码:
void solve()&#123;  ll n; cin&gt;&gt;n;  vector&lt;ll&gt; a(n+1),b(n+1);  for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];  for(int i=1;i&lt;=n;i++) cin&gt;&gt;b[i];  set&lt;ll&gt; last; last.insert(0);  for(int i=1;i&lt;=n;i++)&#123;    set&lt;ll&gt; now;    for(int j:last)&#123;      now.insert(max(0ll,j-a[i]));      now.insert((j^b[i]));    &#125;    last=now;  &#125;  ll maxn=-1;  for(int i:last) maxn=max(maxn,i);  cout&lt;&lt;maxn&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>广搜变形</title>
    <url>/ZestfulYK-blog/2025/02/24/%E5%B9%BF%E6%90%9C%E5%8F%98%E5%BD%A2/</url>
    <content><![CDATA[题目描述:在正常的广搜上加一个条件:每个点有开放时间,在开放之前禁止更新
方法:实际上,当开放后,第一个来更新他的点,是他周围第一个被更新过的点,所以距离直接标为min(dist[nowx][nowy]+1,open[nowx][nowy]+1)
然后加上一个优先队列就行了这里提一下二维的优先队列写法:
priority_queue&lt;pair&lt;ll,pair&lt;ll,ll&gt;&gt;,vector&lt;pair&lt;ll,pair&lt;ll,ll&gt;&gt;&gt;,greater&lt;&gt;&gt; q;
这样就不用依赖tuple了
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>异或笔记</title>
    <url>/ZestfulYK-blog/2025/12/07/%E5%BC%82%E6%88%96%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[一、 异或的基本性质（基石）记住这四条，其他大多可以推导：

归零律：a ⊕ a = 0
恒等律：a ⊕ 0 = a
自反性（交换律与结合律的推论）：a ⊕ b ⊕ a = b
交换律与结合律：运算顺序和分组不影响结果。这使得前缀异或成为可能。

二、 前缀异或：子数组问题的利器这是处理子数组异或和查询最核心的技巧，类似于前缀和。

定义：设 pre[i] = a[1] ⊕ a[2] ⊕ ... ⊕ a[i]，并约定 pre[0] = 0。
核心公式：a[l] ⊕ a[l+1] ⊕ ... ⊕ a[r] = pre[r] ⊕ pre[l-1]
原理：pre[r] ⊕ pre[l-1] = (前缀到r) ⊕ (前缀到l-1)，根据结合律和归零律，相同的部分（前l-1项）抵消，剩下就是区间 [l, r] 的异或和。


应用场景：
快速求任意子数组异或和。
将“子数组异或和为0”的条件转化为 pre[r] == pre[l-1]。这是解题的关键一步！
问题转化为对前缀异或数组 pre 的分析，常结合哈希表（unordered_map）来统计次数、寻找配对。



三、 位运算的独特性质（解题突破口）
不进位加法/减法：异或在每一位上独立操作。a ⊕ b 在二进制下，每一位的规则是“相同为0，不同为1”。这暗示我们可以按位考虑问题。
判断奇偶性（结合律的妙用）：
多个数异或，结果的最低位 等于 所有数最低位的异或。
而一个数二进制最低位为 1 代表奇数，为 0 代表偶数。
推论：在一堆数中，异或结果的奇偶性 等于 所有数奇偶性的异或。这在一些博弈或奇偶分类问题中有用。


与加法的关系：a ⊕ b &lt;= a + b。等号成立当且仅当 a 和 b 的二进制表示没有同时为1的位（即 a &amp; b == 0）。这个性质在涉及“最大异或和”与“和”的比较时常用。
构造互补对：对于任意数 x，存在唯一的数 y，使得 x ⊕ y = (全1的二进制串)，这个 y 等于 ~x（在限定位数下）。在构造题中，常用 (1&lt;&lt;k)-1 - x 来得到与 x 在 k 位下每一位都相反的数。四、 经典题型与技巧
寻找唯一出现奇数次的数：利用 a⊕a=0，将所有数异或，出现偶数次的会两两抵消，结果就是那个出现奇数次的数。
寻找两个只出现一次的数（其他出现两次）：
第一步：将所有数异或，得到 x = a ⊕ b（a, b 为所求）。
第二步：找到 x 的任意一个为 1 的二进制位。这一位意味着 a 和 b 在这一位上不同。
第三步：根据这一位将原数组分成两组，分别异或，得到的两个结果就是 a 和 b。


最大/最小异或对问题：
暴力：O(n^2) 对于大数据不行。
优化（O(n*logC)）：使用01-Trie（字典树）。将数字按二进制从高位到低位插入Trie，查询时尽量“走相反位”可以得到最大异或值，“走相同位”可以得到最小异或值。这是必须掌握的高级数据结构。


异或相关的构造题（如你刚才遇到的）：
核心目标：控制前缀异或数组 pre 的值。
常用手段：
让 pre 数组的值是 0 到 n 的一个排列，然后微调（例如交换两个值）来满足特定区间异或为0的条件。
利用性质：如果 pre[l-1] = pre[r]，则区间 [l, r] 异或为0。要保证其他区间不为0，就要保证其他任意 pre[i] 与 pre[j] 都不相等（除了我们特意制造的那一对相等）。
注意题目对 a[i] 取值范围的限制（如 1 &lt;= a[i] &lt;= 1e9），这要求 pre[i] ⊕ pre[i-1] 的结果必须在这个范围内。通常用连续整数构造 pre 可以满足。





五、 做题时的注意事项（避坑指南）
注意数据范围和溢出：你刚才遇到的问题就是典型。当使用2的幂构造时，2^30 ≈ 1e9，所以区间长度不能超过30。必须时刻检查构造值是否在允许范围内。
小心 0：异或中 0 是单位元，非常特殊。在构造时，如果允许元素为 0，可能会意外产生多个异或为0的子数组（例如单个元素为0）。题目常要求正整数来避免这种情况。
前缀异或的初始化：务必定义 pre[0] = 0，这样才能正确表示从 a[1] 开始的子数组。
调试方法：对于小数据，可以暴力计算所有子数组的异或和来验证你的构造是否正确。
思维转化：遇到“所有子数组异或和不为0”这类强条件，要立刻想到它等价于“前缀异或数组 pre 中所有元素两两不同（且 pre[0]=0 也不与其他重复）”。这大大简化了问题。
六、 推荐的巩固练习方向
基础：LeetCode 136（只出现一次的数字）、LeetCode 268（缺失数字）。

进阶：LeetCode 260（只出现一次的数字 III）、LeetCode 421（数组中两个数的最大异或值）（必做，练习01-Trie）。
综合与构造：Codeforces 上的许多构造题（难度 1500-1800），比如你刚才做的这道题的原型。多观察题解中是如何利用前缀异或性质进行构造的。

总结一下，异或问题的核心思路是：利用前缀异或转化区间问题，利用归零律和结合律进行抵消与配对，利用位独立性进行按位处理或使用Trie。多练习，你会对这种“魔力”运算越来越有感觉。
因为异或可以逆运算，所以此处直接先算1-n的异或和再和现在的异或和异或一下就行了。这样就找到了那个没有出现过的数字。找出现奇数次的数字时，可以直接异或，因为只有一个数字满足这个要求，那么最后剩下的那个就是无法完成匹配的数字，就是答案了。找两个只出现一次的数字时，也是先异或得到$x=x_1\oplus x_2$，然后看不一样的那一位来分开数组。解释：就是看这一位是否是1，然后就和只出现一次的数那题一样了。出现两次的数，分组一定在一起，那么就相互异或抵消了。
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>时空间复杂度笔记</title>
    <url>/ZestfulYK-blog/2025/12/09/%E6%97%B6%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[2秒时间限制下的可执行操作数一般经验估算
保守估计：C++在2秒内可执行约 $210^8-410^8$ 次基本操作（加减、比较、赋值等）
实际表现：
简单循环操作：约$110^8-210^8$
复杂操作（除法、取模、函数调用）：约$0.510^8-110^8$
浮点运算：约$0.310^8-0.510^8$不同复杂度对应的最大数据规模O(1)        -&gt; 几乎无限（&gt;10^9）O(logn)     -&gt; 几乎无限（&gt;10^9）O(n)        -&gt; 约 2×10^8O(nlogn)    -&gt; 约 2×10^7（2000万）O(n√n)      -&gt; 约 2×10^6（200万）O(n²)       -&gt; 约 2×10^4（2万）O(n³)       -&gt; 约 2×10^3（2000）O(2ⁿ)       -&gt; 约 n ≤ 25O(n!)       -&gt; 约 n ≤ 11




实战参考表



数据规模
可接受的复杂度
常见算法




n ≤ 10
任意（包括O(n!)）
全排列、暴力搜索


n ≤ 20
O(2ⁿ)
子集枚举、状态压缩DP


n ≤ 100
O(n³)
Floyd、简单DP


n ≤ 1000
O(n²)
二维DP、Dijkstra朴素版


n ≤ 10^4
O(n√n)
数论分块


n ≤ 10^5
O(nlogn)
线段树、树状数组、堆


n ≤ 10^6
O(n) 或 O(nlogn)
前缀和、KMP、单调栈


n ≤ 10^7
O(n)
筛法、线性DP


n ≤ 10^8
O(n)（必须常数小）
位运算、简单遍历




256MB内存限制下的数组大小不同数据类型可开数组大小



数据类型
字节大小
最大元素数
备注




bool
1字节
约 2.68亿
实际比赛中常设为 bool 数组


char
1字节
约 2.68亿



int
4字节
约 6700万
常用


long long
8字节
约 3300万



double
8字节
约 3300万



结构体（16字节）
16字节
约 1600万
视具体结构而定




// 安全范围（考虑程序其他部分占用）int arr1[10000000];     // 4000万字节 ≈ 38MB ✅int arr2[50000000];     // 2亿字节 ≈ 190MB ✅（接近极限）int matrix1[5000][5000]; // 1亿字节 ≈ 95MB ✅int matrix2[10000][10000]; // 4亿字节 ≈ 381MB ❌（超限）// 多个数组时需累加int arrA[30000000];  // 114MBint arrB[30000000];  // 114MB// 总计228MB ✅（但接近极限）// 危险情况vector&lt;vector&lt;int&gt;&gt; graph(100000);  // 每个vector开销// 虽可能未立即超限，但动态扩展时可能意外超限
实用安全上限表



数组类型
推荐最大规模
实际内存占用
安全系数




一维int数组
≤ 5×10⁷
≤ 200MB
留有余地


一维long long数组
≤ 2.5×10⁷
≤ 200MB



二维int数组[n][m]
n×m ≤ 3×10⁷
≤ 120MB
常用


邻接表（图）
边数 ≤ 2×10⁶
变长，通常安全



位集bitset
≤ 2×10⁸位
≤ 25MB
非常节省





快速判断方法时间判断口诀n=10⁵ → 想想O(nlogn)n=10⁶ → 必须O(n)或优化常数n≤5000 → O(n²)或许可行n≤20 → 可能是状压
空间判断口诀int数组：百万级安全，千万级要小心二维数组：相乘别超千万结构体：注意对齐开销STL容器：额外开销约50%
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>构造操作类题目</title>
    <url>/ZestfulYK-blog/2025/12/16/%E6%9E%84%E9%80%A0%E6%93%8D%E4%BD%9C%E7%B1%BB%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[定义
构造一些操作，使得数据满足操作要求，通常还会有次数限制

方法此类题目现在遇到过三种做法：

一种是直接操作，不关心部分值，直接对全局操作，使得再让全局满足要求的同时，使得部分也满足要求
另一种是进行操作，最后只改变一个量，每次用多步做一步（和魔方有点像？）

例题1.B. Siga ta Kymata

题目描述：给你一个排列 $^{\text{∗}}$ 。从 $1$ 到 $n$ 的每个整数的排列 $p$ 。您还拥有一个大小为 $n$ 的二进制 $^{\text{†}}$ 字符串 $s$ ，其中 $s_i = \mathtt{0}$ 代表所有 $1 \le i \le n$ 。您最多可以执行以下操作 $5$ 次：选择任意两个整数 $l$ 和 $r$ ，使得 $1 \le l \le r \le n$ .然后，对于每一个 $i$ 使得 $l&lt; i&lt; q$ 和 $\min(p_l, p_r) &lt; p_i &lt; \max(p_l, p_r)$ 同时成立，你将把 $s_i$设为 $\mathtt{1}$ 。您还会得到一个大小为 $n$ 的二进制字符串 $x$ 。执行运算后，对于每一个 $1 \le i \le n$ 都必须成立：如果 $x_i = \mathtt{1}$ ，则 $s_i = \mathtt{1}$ 。注意，如果 $x_i = \mathtt{0}$ ，那么 $s_i$ 可以有任意值。找出最多5个运算序列，使上述条件得到满足，或者报告不可能做到这一点。请注意，您不必尽量减少操作次数。

解法：|----------------|-------------------n------------|                |                   |           ||----------------|-------------------|——————————a[n]|                |                   |           |a[1]----------------------------------------------|                |                   |           ||                |                   |           ||----------------1--------------------------------

一共画了5个框，也就是5次操作的范围
这里实际上是把所有能改变的全改变了，然后也就满足了要求
所以5次也是合理的，证明了做法的正确

2.西安之泪 - 洛谷

题目描述：给定一颗无根树,共有n个顶点。每个顶点 i 都具有一个点权$a_i$，初始所有点权都为0。你可以进行如下的操作最多不超过$3n$次：指定顶点的编号 r,u (1≤r,u≤n)，使得这棵树暂时以顶点 r 为根，随后对于顶点 u 的子树中的每一个顶点 v，将其点权修改为 av​⊕u。此处的 ⊕ 表示按位异或。

这一题就是尝试操作每一个顶点，分步完成。让每个顶点的邻居给这个顶点发一次，那么最终剩下的节点就被⊕了出度数-1次。如果是偶数，不变；但是奇数时，为了保持不变，那么我们在自己给自己发一次就行了。
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子段和</title>
    <url>/ZestfulYK-blog/2025/02/12/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/</url>
    <content><![CDATA[
方法1:处理当前位置之前的前缀和的最小值,每次计算当前位置到这个位置的子段和即可代码:const ll inf=1e9+1;void solve()&#123;  ll n; cin&gt;&gt;n;  vector&lt;ll&gt; a(n+1);  for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];  ll minn=0,now=0,ans=-inf;  for(int i=1;i&lt;=n;i++)&#123;    now+=a[i];    ans=max(ans,now-minn);    minn=min(minn,now);  &#125;  cout&lt;&lt;ans&lt;&lt;endl;&#125;


注意几个细节,首先minn存储的是到目前为止的最小值,应该默认为0,在所有数字全为正数的情况下,表示空串的前缀和为0.先计算ans再计算minn,这是因为不能产生空串,保证取的是前面的前缀和.

方法2:传统dp法:

代码:#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    long long a,maxn=LONG_LONG_MIN,sum=0,n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;a; sum+=a;        if(sum&lt;a) sum=a;        if(sum&gt;maxn) maxn=sum;    &#125;    cout&lt;&lt;maxn&lt;&lt;endl;&#125;
思路:如果当前值比前面求的和还要大,那么放弃前面的求和,直接新开一段
变形:求子段%p意义下的最大子段和
依旧先计算前缀和(在%p意义下),前面的前缀和更小,可能是两个和还没相差p,要是当前的更小,大概率是超过了p,翻上去了,所以要考虑两个位置,前缀最小值和第一个比当前数字大的前缀和值.
代码略,自己写去,up懒
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>我这学期犯过的唐</title>
    <url>/ZestfulYK-blog/2025/12/16/%E6%88%91%E8%BF%99%E5%AD%A6%E6%9C%9F%E7%8A%AF%E8%BF%87%E7%9A%84%E5%94%90/</url>
    <content><![CDATA[不知道vector的size是size_t类型
因为是size_t所以直接加减会出错，比如减成负数的时候。

内层循环变量写错
这个会导致外层循环少了几次

sort里面的数据范围没开正确
例如要对’n*m’的数据排序，却只写了n

不看清读入顺序
看清读入的是有序的还是乱序的，不要被样例蒙蔽了双眼

位运算不写ll
区分以下代码的区别:

(1&lt;&lt;i) //得到int(1ll&lt;&lt;i) //得到ll
冷知识,最后一个问题这个sb已经错了两次了
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM数字类题目</title>
    <url>/ZestfulYK-blog/2025/12/07/%E6%95%B0%E5%AD%97%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[数字类题目
定义：通常有乘除法，或者时分解质因数之类的

重要观察
$2^{30} &gt;= 10^9$所以一般不需要几个数就能乘到上界，除法的话同理，分解质因数实际上也算乘法。因此这类题目往往可以比较暴力的解决。因为只要枚举这几个位置即可。
重要例题：
1.题目传送门Strange Machine

重要观察：$log_2(10^9)=30$,所以除去全是1的情况，每次除2最多30次循环就结束了，因此可以暴力解决。除了有1的情况，因为n最大为20，所以最多$20*30$每个数据。

2.题目传送门Even Modulo Pair

重要观察，要塞大量数据来导致超时的话是不可能的，因为在30个数内必然能找到。理由：首先如果只有偶数，那么一定有解。（因为严格递增）  当只有奇数时：  因为当$y&lt;2x$时，必然有$y \mod x \ = \ y-x \ = \text{偶数}$,因此要构造较大的数据的话，只能让$y \geq x 2$  要让$y \mod x \ !=  \text{偶数}$，那么最小只能构造$y=x*2$那么和上一题就一样了。

3.题目传送门Add 0 or K

题目理解，首先要求吧原数组每个元素加上K的若干倍，构成含有相同因子的数组。
重要观察：加完以后，因为含有相同的因子，所以考虑把每个加完以后的数字拆分，得到一串质数，而前29个质数的乘积已经大于$10^9$了，所以直接可以算出最终的共同因子。接下来对最后结果化简$a_i+c_ik \equiv 0  (mod\ g)$,所以$c_i=(-a_i)inv_k$而k存在$mod \ g$下有逆元，需要g和k互质，所以可以简单完成。

4.题目传送门C-区间乘_2025年广东工业大学新生赛（同步赛）

希望我们计算一个区间的乘积，判断是否可能达到给定的输出。
数据规模n和查询规模q都是$2*10^5$所以不能直接查询。
重要观察：如果把1去掉算法就能变简单，而如果不是全为1的话，查询数据$x \leq 10^9$，所以当不是1的时候，只要30个2就能超过数据范围了，每个位置计算一下，可以直接提取计算可能出现的数字，故最多$30210^5$次计算，查询$q\log_2(x)$次就行了所以最终时间复杂度是$O(Tcountq\log_2(q))$dirt=（总提交次数-过题数量）/总提交次数

然后注意，只有质因数时可以用，其他的如因子就不行出现奇偶判断的也不要用这个方法，用奇偶性分析特判
GCD二级结论结论1lcm(a,b)*gcd(a,b)=ab结论2gcd(a,b) = gcd(a,|b-a|)结论3gcd(a,b,c)=1等价于存在ax+by+cz =1结论4gcd(a,b) = g * gcd(a >> k,b >> k)\,(g = 2 ^ k)结论5gcd(a^{n-1},a^{m-1})=a^{gcd(n,m)-1}结论6gcd(f_n,f_m)=f_{gcd(n,m)}斐波那契数列
数论题目例题
题目描述：求N个数，相乘等于M
题目转化，因为相乘等于M，那么得到的每一个数必然都是由M的质因数转化而来的，那么考虑每一个质因数在排列中出现的位置，就得到实际上是求把m个球放到n个不同的盒子里的方案数，每一个质因数都要计算一次，相乘得到答案。那么怎么计算把m个球放到n个不同的盒子里的方案数呢？引用一下某大佬的解释：
我们回头看看2(球同，盒不同，不允许空盒)。在2的条件下，我们可以给出另一个处理方案：如果我们给每个盒子都放上1个球，那么剩下的n-m个球放入m个盒子里，就不需要管是否有空盒了（因为已经事先给每个盒子都放了一个球）。如果用T(n-m, m)表示加粗部分的方案数量，那么2的答案 = 1（先每个盒子一个球，只有1种放法） * T(n-m, m)。那么显然，T(n-m, m)就是情况3，只不过是n-m个球入m个盒，而不是我们要求的n个球入m个盒。那么我们只需要把2情况里，球的总数量变成n+m个，在上述方案里，就会变成“如果我们给每个盒子都放上1个球，那么剩下的n + m - m = n个球放入m个盒子里，就不需要管是否有空盒了”因此，方案数量在数值上是等于2里，把n替换成n+m的：方案数量 = C(n + m - 1, m - 1)



那么接下来我们计算阶乘和逆元就能解答了（（怎么这么麻烦，没招了）
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>根号分治</title>
    <url>/ZestfulYK-blog/2025/02/12/%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[常见于含有两数相乘的题目中,或者数据范围在根号上下时可采用不同复杂度的算法平衡总复杂度
例题1:D. Another Problem about Beautiful Pairs
求i,j对,满足$a_ia_j==i-j(i&gt;j)$,n最大是$210^5$注意到,在$a_i$较大时,适合直接暴力枚举,因为没枚举几次就超过边界了,在$a_i$较小时,不适枚举,
所以划分一个界限,大于$\sqrt{n}$的枚举,小于$\sqrt{n}$的只计算$\sqrt{n}$次,这么划分的作用是两边刚好全部包括在内如果$a_i$小的话$a_j$可能大,但是这部分被大于$\sqrt{n}$的部分枚举到了,减少了无效枚举所以代码:
void solve()&#123;  ll n,ans=0; cin&gt;&gt;n;  vector&lt;ll&gt; a(n+1);  for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i];  ll fj=sqrt(n);  for(int i=1;i&lt;=n;i++)&#123;    if(a[i]&gt;n) continue;    if(a[i]&lt;=fj) 	    for(int x=1,j=i+a[i];x&lt;=fj&amp;&amp;j&lt;=n;x++,j+=a[i]) if(j-i==a[i]*a[j]) ans++;    else&#123;      for(int j=i-a[i];j&gt;=1;j-=a[i]) if(i-j==a[i]*a[j]) ans++;      for(int j=i+a[i];j&lt;=n;j+=a[i]) if(j-i==a[i]*a[j]) ans++;    &#125;  &#125;  cout&lt;&lt;ans&lt;&lt;endl;&#125;
例题2:F. Remainder Problem
操作: 给x位置加上y查询: 求$\sum_{i=1}^n a_i(i \mod x==y)$n为$5*10^5$
查询时,如果是x较大,查询时暴力也能计算,但是x较小时,查询起来会很麻烦,但是可以预处理一下,开一个数组,sum[x][y]表示i mod x == y的所有数字之和所以依旧分开计算,当x小于$\sqrt{n}$时,采用方法2预处理,x大于$\sqrt{n}$时采用方法1,暴力计算对于每个输入的x,在数组中计算一次,再去预处理数组中加一下,两者合起来都只需要700左右的循环次数,执行比较快,注意别被卡常即可,用C的输入输出方法
代码:
#include&lt;bits/stdc++.h&gt;using namespace std;int sum[710][710],a[500010];int main()&#123;  int q; scanf(&quot;%d&quot;,&amp;q);  for(int j=1;j&lt;=q;j++)&#123;    int op,x,y; scanf(&quot;%d%d%d&quot;,&amp;op,&amp;x,&amp;y);    if(op==1)&#123;      for(int i=1;i&lt;700;++i) sum[i][x%i]+=y;      a[x]+=y;    &#125;    else&#123;      if(x&lt;700) cout&lt;&lt;sum[x][y]&lt;&lt;endl;      else&#123;        int ans=0;        for(int i=y;i&lt;=500000;i+=x) ans+=a[i];        printf(&quot;%d\n&quot;,ans);      &#125;    &#125;  &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>程C指针学习笔记</title>
    <url>/ZestfulYK-blog/2026/01/06/%E7%A8%8BC%E6%8C%87%E9%92%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[单纯的指针最简单的指针带*的：野指针(确信)
int *p; //一只快乐的野指针，未初始化的指针，指向随机地址(野指针)
这个表示定义了指针，不过注意，前面的类型是要自己设定的，不能乱写但是提到指针，就不得不提到&amp;(取地址符)了
&amp;的用法：&amp;表示取地址符，比如这样：
int a=1;cout&lt;&lt;&amp;a&lt;&lt;endl;//输出a的地址
这一句表示输出a变量对应的地址位置，详细见书上的解释，获取地址的开头方便输出
然后指针所能存储的恰好是地址，所以可以这么写：int *p=&amp;a;
表示p指向a对应的地址
指针的初始化可以把指针设定为NULL，这里表示p不指向任何一个地址要是没有初始化，p可能指向任何一个位置，可能导致代码错误，所以被称作野指针
int *p = NULL;  // 未初始化指针（野指针）*p = 10;        // 段错误// 解引用前应检查if(p != NULL) &#123;    *p = 10;&#125;
指针的多种含义在实际程序中，*p，可能有多种含义：

表示p所指的变量，即*p=a
表示p对指的变量的值，即a的值

下面是例子：
int a=1;int *p=&amp;a;*p=1;          //表示将p指向的变量(即a)赋值为1cout&lt;&lt;*p&lt;&lt;endl;//表示输出p指向的变量(即a)的值
这里两种情况怎么理解呢？首先加上*表示对指针解引用，即访问指针指向的内存位置

case 1：这里指把p所指的位置修改为1，所以表示p所指的变量
case 2：这里因为表示的是p所指的位置，所以我们在输出时就是从这个位置开始逐个输出，表示的就是所指对应变量对应的值了。

更详细的解释：在C++里有两种值叫做左值(Location Value) 和 右值(Read Value)

左值表示一个内存位置，可以被赋值
右值表示一个数据值，只能被读取

前者表示的是地址，被写入数据的那个变量，所以表示地址后者只是获取其内部数据，表示的就是对应的值了
所以，当*p出现在赋值号左边时，它是左值，表示一个内存位置（即p指向的变量）；当*p出现在其他表达式中（如赋值号右边、函数参数等），它是右值，表示该位置存储的值
这样基本用法就能理解了
指针表示一维数组指针指向的是一个元素的位置，要是指向的是一个数组的开头呢？
指针指向一个元素的位置，如果指向一个数组的开头，就可以通过指针来访问数组
那么问题来了，我们该怎么获取中间元素的值呢？
这里我们就需要知道一下数组下标的工作原理了：
实际上程序会计算要往后访问几个位置，根据数据类型来决定往后跳几步。所以我们可以这么理解a[3]：a开头位置加上3×步长，得到这个元素的地址开头，就能正常访问了，这个过程相当于是一种规则，表示我们要往后几步
对于指针也是如此，首先我们已经保证了指针p所指向的变量类型和数组a的元素类型一致，所以我们知道了p的开头以后，我们只要往后加上对应的步长就能找到我们要访问的元素了
那么C++中规定了，指针+1表示往后一个步长，[n]表示往后n个步长，所以我们从这里理解了，为什么数组的下表是从0开始的，以及怎么利用指针来访问数组
诶那我们是不是发现了数组a怎么和p这么类似啊，都能通过[n]来访问元素确实，实际上数组名在大多数情况下可以看作指向数组首元素的指针，我们用a+1也能访问元素，a表示的是a数组的开头地址，所以要用p遍历a的时候，我们只要p=a就能完成初始化，因为p存储的不正是地址吗？
所以我们在代码里一般可以这么写：
int a[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;int *p=a;cout&lt;&lt;p&lt;&lt;endl;                   //a[0]的地址cout&lt;&lt;p[1]&lt;&lt;endl;                //a[1]的值cout&lt;&lt;p+2&lt;&lt;endl;                 //a[2]的地址for(int i=0;i&lt;10;i++)&#123;           //遍历a数组	cout&lt;&lt;p+1&lt;&lt;&quot; &quot;&lt;&lt;p[i]&lt;&lt;endl;  //两者等价&#125;
注意：数组名a在大多数情况下可以转换为指针，但数组名不是指针，它是整个数组的标识符。在sizeof(a)时，它返回整个数组的大小，而不是指针大小
值得注意的是，因为我们这里只是规定了向后移动几步，没有规定范围，所以理论上可能超出数组规定的范围访问，但是这会导致段错误，因为程序理论上没有权限访问这个位置的值错误示例：
// 指针越界访问int arr[5];int *p = arr;p[10] = 5;      //未定义行为
理解了指针和数组的关系，也就理解了指针的本质，我们接下来就可以理解指针运算了。
指针运算要是直接加减常数，表示的是移动多少个位置，要是是两个指针相减，表示的是中间差了几个单位，当然，我们也可以进行大小比较，表示指针在一个数组中的前后位置关系
// 指针与整数的加减int arr[10];int *p = arr;p = p + 3;      // 移动3个int位置p = p - 2;      // 移动回去2个位置// 指针之间的减法（得到元素个数）int *p1 = &amp;arr[2];int *p2 = &amp;arr[5];printf(&quot;%ld\n&quot;, p2 - p1);  // 3// 指针比较if(p1 &lt; p2) &#123;   // 同一数组内比较有意义    // ...&#125;
二级指针int **p;int *p1;int a=1;p1=&amp;a;p=&amp;p1;cout&lt;&lt;**p1&lt;&lt;endl;
表示指向存储指针位置的指针，分析时一层一层去掉就行了
要是等级更高也是类似的理解，比如实际上可以创建一个三级的指针
int ***p;int **p1;int *p2;int a=1;p2=&amp;a;p1=&amp;p2;p=&amp;p1;cout&lt;&lt;***p&lt;&lt;endl;
指针与函数首先函数中可以直接传入指针变量，这里可以理解为直接把对应的开头地址传过来了
比如我们写一个swap函数：
void swap(int *p1,int *p2)&#123;	int temp;	temp=*p1;	*p1=*p2;	*p2=temp;&#125;int main()&#123;	int a=1,b=2;	int *p1=&amp;a,*p2=&amp;b;	swap(&amp;a,&amp;b);	//也可以写swap(p1,p2);	cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;&#125;
这里操作完后，主函数里a，b的值也会互换，因为我们传入的是地址，在函数内我们又对这个地址对应的位置进行了操作，那么就能修改这个位置的值了，然后注意在函数调用时要传入的是地址，因为要和函数所需参数(指针)相对应。
注意，以下几种写法都是错误的：
void swap_w1(int *p1,int *p2)&#123;	int *temp;	*temp=*p1;          //错误，temp是野指针，未初始化，不能解引用	*p1=*p2;	*p2=*temp;&#125;void swap_w2(int *p1,int *p2)&#123;	int *temp;	temp=p1;           //错误，只交换了p1和p2对应的地址，但是函数结束这两个就被删除了	p1=p2;             //只交换了p1和p2这两个指针变量本身（局部变量）	p2=temp;           //没有交换它们指向的值&#125;int main()&#123;	int a=1,b=2;	int *p1=&amp;a,*p2=&amp;b;	swap(*p1,*p2);     //错误：*p1表示的是对应的地址对应的值	cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;&#125;
最后这个为什么是错的？因为不是赋值语句，表示的是右值，是对应的值*p1表示的是a的值，即1，类型是int，而函数需要int*，类型不匹配
那么中间的函数为什么是错误的？我们来详细分析一下：
函数开始时          函数结束时          回到主函数(删除了作为形参的p1,p2)p1-&gt;a=1                p1-&gt;b=2          a=1p2-&gt;b=2                p2-&gt;a=1          b=2
所以没有任何变化，这个函数既没有修改p1,p2对应的位置的值，也法修改a和b对应的地址位置，所以没有产生任何变化。
传入数组也是类似的：
void f(int a[],int n)&#123;	//指定a是指针即可，反正传入首个元素的地址就行了，遍历方法见上面&#125;
然后因为数组传入都是传入首位置的，所以在函数内对数组操作是会改变原数组的
我知道大家一直有一个问题，为什么要这么大费周折的学习指针呢？其实在这一块就给出了一个答案：可以让函数有多个返回值
注意一下函数的返回值，不能返回指针形参的地址，因为正如前面所说，函数结束后，这个位置就被删除了
int* bad_func() &#123;    int x = 10;  // 局部变量    return &amp;x;   // 函数结束x被删除&#125;
指针与二维数组遍历方法类似，因为二维数组一般是连续的，所以可以p+i一直加下去来遍历，不过我们这里要讲解一下一个新的概念——行指针
行指针写法：
int (*p)[4];
根据之前的学习我们知道，这其实也是规定了一种遍历规则，*p指向的是一个长度为4的一维数组的开头位置，要是+1的话表示跳过4个长度，然后加上括号表示是p指向数组，如果写成int *p[4],则表示一个长度为4的指针数组。
那么我们就可以通过p来访问这个二维数组了，
首先p表示的是对应哪一行，*p是这一个数组对应的开头，就变成一维数组的访问了例如：
int a[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;int (*p)[4];p=a;cout&lt;&lt;*(*(p+1)+1)&lt;&lt;endl;
和前面一位数组的理解类似二维数组名a也可以看作指向第一行(整个一维数组)的指针，指向的是第一行这个一维数组，这里的调用相当于进行了两次一维数组的查询操作，先确定行再确定列。
在行上，我们有：
int a[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;int (*p)[4];p=a;cout&lt;&lt;p[0]&lt;&lt;endl;   // 第一行的首地址，即&amp;a[0][0]cout&lt;&lt;p+1&lt;&lt;endl;    // 第二行的首地址，即&amp;a[1][0]
再加上列，我们就有四种组合了，本质上是等价的
cout&lt;&lt;p[1][1]&lt;&lt;endl;cout&lt;&lt;(*(p+1))[1]&lt;&lt;endl;cout&lt;&lt;*(p[1]+1)&lt;&lt;endl;cout&lt;&lt;*(*(p+1)+1)&lt;&lt;endl;
行指针和函数因为在行指针里，每次+1跳过几个位置的规则是十分重要的，所以在把行指针传入函数时，两者的第二给参数，即规则，得完全一致，不然程序会报错
void f(int arr[][4])&#123;	//&#125;
或者：
void f(int (*arr)[4])&#123;	//&#125;
只有规则相同才能调用
动态分配数组空间一维数组int *p=new int[n];delete[] p;
或者
int *p=(int*)malloc(sizeof(int)*n);free(p);
相当于每个位置都给了一个int的空间注意：malloc返回void*，需要强制类型转换。
例如，下面这段代码是错误的：
int *p = malloc(sizeof(int) * 100);
二维数组在C语言中，动态分配二维数组(不连续)
int **matrix = new int *[ROW];for (int i = 0; i &lt; ROW; ++i) &#123;	matrix[i] = new int[COL];&#125;for (i = 0; i &lt; m; i++) &#123;	delete[] matrix[i];&#125;delete[] matrix;
或者
int **matrix = (int**) malloc ( ROW * sizeof( int* ));for int(i = 0 ; i &lt; COL ; ++i) &#123;	matrix[i] = (int*) malloc ( COl * sizeof( int ));&#125;for (i = 0; i &lt; m; i++) &#123;	free(matrix[i]);&#125;free(matrix);
这里的二级指针存储的是(每一行开头的元素的地址)的地址为什么要这么麻烦呢？但是逐个分配的好处是方便删除，也可以实现各行长度不同（锯齿数组）在这种情况下，我们就不能+1来查询了（因为行之间不连续），但可以通过行指针数组来访问每一行。
如果希望分配连续的二维数组，可以使用以下方法：
int (*p)[COL] = (int(*)[COL])malloc(ROW * COL * sizeof(int));// 使用...free(p);
或者
// 方法一：一次分配所有内存（连续）int rows = 3, cols = 4;int *data = malloc(rows * cols * sizeof(int));int **matrix = malloc(rows * sizeof(int*));for(int i = 0; i &lt; rows; i++) &#123;    matrix[i] = data + i * cols;&#125;// 释放free(matrix);free(data);// 方法二：用行指针（更接近静态数组）int (*p)[cols] = malloc(rows * cols * sizeof(int));// 可以直接用 p[i][j] 访问free(p);
这样分配的内存是连续的，可以用p[i][j]访问，且p是一个行指针,p+1会跳过一行(COL个int)
指针与字符串C++语言中字符串常以字符数组表示，也可以用指针
char str[] = &quot;Hello&quot;;char *p = str;printf(&quot;%s\n&quot;, p); // 输出Hello
字符串常量可以用指针指向：
char *p = &quot;Hello&quot;; // p指向字符串常量，注意字符串常量不可修改
const与指针这里介绍基本的const用法，以及基本的const指针
const表示的是常量，表示后面的是不可修改的
首先const int *p1表示p1的类型是const int，所以是指向常量的指针第二个int *const p2表示p2的类型是const，p2 的值是不变的，指向同一个位置，但是他所指向的地址的值却是可以改变的第三个表示指向不变，且指向的是常量
// 四种const指针const int *p1;        // 指向常量的指针，值不能改int const *p2;        // 同上int * const p3;       // 常量指针，指向不能改const int * const p4; // 指向常量的常量指针// 示例int a = 5, b = 10;const int *p = &amp;a;// *p = 6;  // ❌ 错误p = &amp;b;     // ✅ 正确int * const q = &amp;a;*q = 6;     // ✅ 正确// q = &amp;b;  // ❌ 错误
指针数组与行指针区分指针数组，每一个位置都是一个指针，指向一个位置在指针数组，+1表示移动到指针数组的下一个位置，比如names+1表示name[1]的首地址，再加上*表示一维数组，有相似之处，但是和行指针在访问规则上还是有区别的
// 指针数组：数组的每个元素都是指针char *names[] = &#123;&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;&#125;;// names[0] 指向 &quot;Alice&quot;// names[1] 指向 &quot;Bob&quot;// 数组指针：指向整个数组的指针int arr[3][4];int (*p)[4] = arr;  // 指向含有4个int的数组
指针相关题目下面是程C课上提到的题目，我们来检测一下你有没有理解
例1：
int a=10,b=20,c=30;void fun(int* x,int* y,int* z)&#123;  cout&lt;&lt;++*x&lt;&lt;&#x27;,&#x27;&lt;&lt;*y++&lt;&lt;&quot;,&quot;&lt;&lt;*(z++)&lt;&lt;endl;&#125;signed main()&#123;  for(int i=0;i&lt;3;i++)&#123;    fun(&amp;a,&amp;b,&amp;c);  &#125;  cout&lt;&lt;a&lt;&lt;&quot;,&quot;&lt;&lt;b&lt;&lt;&quot;,&quot;&lt;&lt;c&lt;&lt;endl;&#125;
这一题我们需要学习一下C++中的运算符的优先级，从高到低可以理解为：
后缀运算&gt;前缀运算=单目运算&gt;双目运算
双目运算的规则还是比较清晰的，这里就不解释了详细解释可以看这个网站C++ 运算符优先级
所以函数中的*y++表示的就是*(y++)，先将地址使用，再后移一格，相当于没有对原先位置产生变化，所以得到答案：
11,20,3012,20,3013,20,3013,20,30
例2：
void fun(int* x,int* y,int* z)&#123;  *z=*x+*y;&#125;signed main()&#123;  int a[3][3]=&#123;1,1&#125;;  int *p1,*p2,*p3;  p1=a[0];  p2=a[0]+1;  p3=a[0]+2;  for(int i=2;i&lt;=9;i++)&#123;    fun(p1++,p2++,p3++);  &#125;  for(int i=0;i&lt;3;++i)&#123;    for(int j=0;j&lt;3;j++)&#123;      cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;endl;  &#125;&#125;
这道题的意图还是比较明确的，即利用二维数组空间的连续性，计算斐波那契数列注意主函数中的用法，取的是a[0]的地址，因为p1不是行指针，只能指向一个一位数组的开头，所以写成p1=a[0]
答案：
1 1 2 3 5 813 21 34
例3:
int a[5] = &#123;1, 2, 3, 4, 5&#125;;int *ptr = (int *)(&amp;a + 1); printf(&quot;%d&quot;, *(ptr - 1));
答案:输出5
此题需要注意的是’(&amp;a + 1)’这里是指向a这个一维数组的地址,那么就是行指针了,所以+1要按照行指针的规则来执行,接下来再强制转化为正常指针,所以-1按照正常指针的规则
如果你对上面的解释还不是很清楚,也欢迎来私信我和我交流
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>程C笔记2</title>
    <url>/ZestfulYK-blog/2025/12/16/%E7%A8%8BC%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[递归函数的定义注意一下在命名函时，可以不写参数的名称，比如：void fun(int,int)
结构体排序void mySwap(Data *p1,Data *p2)&#123;//交换函数    Data t=*p1;    *p1=*p2;    *p2=t;&#125;for(int i=0;i&lt;n-1;i++)&#123;    for(int j=0;j&lt;n-i-1;j++)&#123;       if(a[j].num&gt;a[j+1].num ||        (a[j].num==a[j+1].num &amp;&amp; a[j].value&gt;a[j+1].value))&#123;           mySwap(&amp;a[j],&amp;a[j+1]);        &#125;    &#125;&#125;

传入时注意，要加上&amp;，传入地址，使得函数可以交换地址。

数组的定义
使用new和delete一起运算。

基本方法// 创建一维动态数组数据类型* 指针名 = new 数据类型[元素个数];// 释放内存delete[] 指针名;
一维数组示例// 方法1：创建基本类型的一维数组int n = 5;int* arr1 = new int[n];  // 创建包含5个整数的数组delete[] arr1;
二维数组
比一维数组多了一个*

内存连续 // 分配连续内存int** arr = new int*[rows];  // 创建行指针数组arr[0] = new int[rows * cols];  // 分配所有元素的空间// 设置行指针for (int i = 1; i &lt; rows; i++) &#123;    arr[i] = arr[i-1] + cols;&#125;
内存不连续// 创建二维数组int** arr = new int*[rows];  // 创建行指针数组for (int i = 0; i &lt; rows; i++) &#123;    arr[i] = new int[cols];  // 为每一行分配内存&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机18讲题解</title>
    <url>/ZestfulYK-blog/2025/12/07/%E8%AE%A1%E7%AE%97%E6%9C%BA18%E8%AE%B2%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[小技巧
在网页前面加上read有奇效例如：
raed:https://www.reach-top.cn.com
这个是阅读器模式，开启以后就能获取里面原先不让复制的内容了
A题
题目描述每个整数都应输出一个各位数字和，并独占一行。

解题思路拿之前上课的程序自然是能解决的，直接一个循环算到底每一位的值是n%10，要取得下一位就n/=10再算就彳亍了但是注意到这节课的标题是函数，那么我们就编写一个递归程序来计算每一位的和边界条件：n&lt;=10递推式子：n %10+solve(n/10)
参考代码
ll solve(ll n)&#123;  if(n&lt;10) return n;  return n%10+solve(n/10);&#125;signed main()&#123;  ll T;  while(cin&gt;&gt;T)	cout&lt;&lt;solve(T)&lt;&lt;endl;  return 0;&#125;//此处#define ll long long
B题
题目描述给定若干个正整数，请你从这些整数中找到最小值和第二小的值，计算一下第二小的数值减去最小值的结果是不是素数，如果是则输出Yes，否则输出No”o。 

解题思路直接写一个循环计算最小值和次小值，然后判断差是不是素数就行了计算最小值和次小值的思路，如果输入值x比最小值小，那么把次小值改成原先的最小值，再把最小值修改为输入值x，如果只是比次小值小，那么把次小值改成输入值x
参考代码void isprime(int n)&#123;  if(n==1)&#123;    cout&lt;&lt;&quot;No\&quot;o&quot;&lt;&lt;endl;    return;  &#125;  for(int i=2;i&lt;=sqrt(n);i++)&#123;    if(n%i==0)&#123;      cout&lt;&lt;&quot;No\&quot;o&quot;&lt;&lt;endl;      return;    &#125;  &#125;  cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;&#125;signed main()  ll minn1=1e18,minn2=1e18,x;  while(cin&gt;&gt;x)&#123;    if(x&lt;minn1)&#123;      minn2=minn1;      minn1=x;    &#125;    else if(x&lt;minn2)      minn2=x;  &#125;  isprime(minn2-minn1);  return 0;&#125;


C题
题目描述哥德巴赫猜想大家都知道一点吧。我们现在不是想证明这个结论，而是想在程序语言内部能够表示的数集中，任意取出一个偶数，来寻找两个素数，使得其和等于该偶数。  做好了这件实事，就能说明这个猜想是成立的。由于可以有不同的素数对来表示同一个偶数，所以专门要求所寻找的素数对是两个值最相近的。
解题思路直接暴力求解从中间开始计算，设两个数分别是x，y，然后x—，y++，判断是否是合法的，如果合法那么输出，这样得到的第一组解必然是最小的一组解。判断是否是素数的代码可以用上一题的代码。
参考代码bool isprime(ll n)&#123;  if(n==1) return false;  for(int i=2;i&lt;=sqrt(n);i++)&#123;    if(n%i==0)      return false;  &#125;  return true;&#125;signed main()&#123;  ll x;  while(cin&gt;&gt;x&amp;&amp;x)&#123;    ll a1=x/2,a2=x/2;    while(1)&#123;      if(isprime(a1)&amp;&amp;isprime(a2))&#123;        cout&lt;&lt;a1&lt;&lt;&#x27; &#x27;&lt;&lt;a2&lt;&lt;endl;        break;      &#125;      a1--; a2++;    &#125;  &#125;  return 0;&#125;


D题
题目描述求给定n个正整数的最大公约数
解题思路计算每个数和现在得到的最大公约数的最大公约数首先先默认最大公约数为第一个正数，然后计算即可。计算最大公约数其实有两种方式，要是你用万能头的话，可以使用自带函数直接计算。这里采用的是标准的辗转相除法。
参考代码ll gcd(ll n,ll m)&#123;  if(n%m==0) return m;  else return gcd(m,n%m);&#125;signed main()&#123;  ll n,x; cin&gt;&gt;n;  ll m=n,maxgcd;  while(cin&gt;&gt;x&amp;&amp;n)&#123;    if(x&lt;=0) continue;    if(n==m) maxgcd=x;    n--;    maxgcd=gcd(maxgcd,x);    //maxgcd=__gcd(x,maxgcd);这个是自带的函数，也是可以的  &#125;  cout&lt;&lt;maxgcd&lt;&lt;endl;&#125;


E题
题目描述找比x大的第一个回文数
解题思路每次加1，直到找到回文数为止。判断回文数的话，直接先一位一位取出来，然后计算，一个正向遍历，一个反向遍历，结果一样就是回文。
参考代码bool hws(ll x)&#123;  ll a[2000],id=1;  while(x)&#123;    a[id++]=x%10;    x/=10;  &#125;  for(int i=1;i&lt;id;i++)    if(a[i]!=a[id-i])      return false;  return true;&#125;signed main()&#123;  ll x;  while(cin&gt;&gt;x)&#123;    x++;    while(!hws(x++));    cout&lt;&lt;x-1&lt;&lt;endl;  &#125;&#125;
这里因为要求要比x大，所以先x++，最后输出x-1的原因是循环里写的是x++最后会多1。

F题
题目描述如果一个数从左到右和从右到左读都一样，那么这个数就叫做“回文数”。如果一个数的十进制和二进制表示都是回文数，则把这个数叫做“双重回文数”。例如，十进制33是回文数，将其转化为二进制表示100001也是回文数，所以33是双重回文数。编写程序，查找1~1000的所有双重回文数。
解题思路和上一题一样，只不过要多出力一个二进制的而已。
参考代码bool hws(ll x)&#123;  ll a[2000],id=1;  ll y=x;  while(x)&#123;    a[id++]=x%10;    x/=10;  &#125;  for(int i=1;i&lt;id;i++)    if(a[i]!=a[id-i])      return false;    id=1;  while(y)&#123;    a[id++]=y%2;    y/=2;  &#125;  for(int i=1;i&lt;id;i++)    if(a[i]!=a[id-i])      return false;  return true;&#125;signed main()&#123;  for(int i=1;i&lt;=1000;i++)    if(hws(i)) cout&lt;&lt;i&lt;&lt;&quot;为双重回文数&quot;&lt;&lt;endl;&#125;


]]></content>
      <tags>
        <tag>程C课程题解</tag>
      </tags>
  </entry>
  <entry>
    <title>程C笔记</title>
    <url>/ZestfulYK-blog/2025/12/11/%E7%A8%8BC%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[1. 头文件和命名空间C++ 中的 string 类定义在头文件 string 中，通常使用 std 命名空间。
s3=strcat(s1,s2);//加在后面int x=strcmp(s1,s2)//返回三种情况,见下面cout&lt;&lt;strlen(s1)&lt;&lt;endl;//输出的是长度，等同于s1.length()strcpy(s1+x1,s2+x2);//把前面的对应部分添加到前面去，完全覆盖之前的内容memcpy(a+x1,b+x2,sizeof(int)*8);//也是把后面的放到前面，只不过需要规定放入的内容sizeof(s1);//考虑后面的&#x27;\0&#x27;，比strlen大1.
x=strcmp(s1,s2)= 
\begin{cases}
 -1  \ \ \ \ \ s1 \leq s2\\
0\ \ \ \ s1=s2\\
1\ \ \ \ s1 \geq s2
\end{cases}memcpy例子：int a[8]=&#123;1,2,3,4,5,6,7,8&#125;;int b[10]=&#123;10,9,8,7,6,5,4,3,2,1&#125;;memcpy(b,a,sizeof(int)*8);for(int i=0;i&lt;10;i++)    cout&lt;&lt;b[i];输出：1234567821
2.函数int maxGap(int* p, int n)//传入p[0]的地址，能改变在主函数里的值static int t;//静态局部变量，下次还是调用上次的值//例如：int cnm(int p,int q)&#123;	static int t=0;	t+=p+q;	return t;&#125;signed main()&#123;	cout&lt;&lt;cnm(1,2)&lt;&lt;cnm(2,3)&lt;&lt;endl;&#125;

局部变量，全局变量，如果多个声明，那么优先使用内部的数据
int a=5;int main()&#123;	int a=10,b=20;	for(int i=1;i&lt;=3;i++)&#123;		cout&lt;&lt;a++&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;		&#123;			static a=0;			for(int j=1;j&lt;=5;j++)&#123;				a+=j;			&#125;			b+=a;		&#125;	&#125;&#125;

要根据函数返回的类型来决定函数的类型

要根据函数内的使用变量来决定函数使用的参数值//例如：char* fun(int c)&#123;//程C一般不用string，自己写都行	return &quot;yes&quot;;&#125;int* fun1(int c)&#123;	int a[]=&#123;1,2,3&#125;;	return a;&#125;
C++变量初始化

int a=10;bool b=1;//b=true;char c=&#x27;c&#x27;;int a[10]=&#123;1,2,3,4&#125;;int a[]=&#123;1,2,3,4&#125;;int a[3][3]=&#123;1,2,3,5,6&#125;;int a[3][3]=&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125;;int solve(int a,int b=10)&#123;//有时可能定义在mian函数前面	return a+b;//有值用值，反之用默认值&#125;
C++ 插入排序void insertSort(int arr[],int n)&#123;	for(int i=1;i&lt;n;i++)&#123;		int key=arr[i];		int j=i-1;		while(j&gt;=0&amp;&amp;key&lt;arr[j])&#123;//注意不是和相邻元素比较			arr[j+1]=arr[j];			j--;		&#125;		arr[j+1]=key;	&#125;&#125;
C++斐波那契数列int climbStair(int n)&#123;	if(n&lt;=2) return n;	int prev2=1;	int prev1=2;//注意此处的定义是反过来的，上课被坑到了（	int current;	for(int i=3;i&lt;=n;i++)&#123;		current=prev1+prev2;		prev2=prev1;		prev1=current;	&#125;	return current;&#125;
汉诺塔问题void digui(int n,char start,char temp,char target)&#123;	if(n==1)&#123;		printf(&quot;%d:%c--&gt;%c\n&quot;,n,start,target);//只有一个直接移动		return;	&#125;	digui(n-1,start,target,temp);//前n-1个到转移柱子上	printf(&quot;%d:%c--&gt;%c\n&quot;,n,start,target);//把第n个移动到目标柱子上	digui(n-1,temp,start,target);//前n-1个到目标柱子上&#125;
最大公约数函数#defien ll long longll gcd(ll a,ll b)&#123;	if(b==0) return a;	//if(a%b==0) return b;	return gcd(b,a%b);&#125;//pow返回的是浮点型，注意类型的转换
上机课J题算法原理
这是$Stern–Brocot$ 树,用于生成全部有理数的一种函数OI wiki 链接：Stern–Brocot 树与 Farey 序列 - OI Wiki
首先规定$\frac{0}{1}$是0,$\frac{1}{0}$是$\infty$，接下来每次在他们中间插入它们的中位分数，即$\frac{a+c}{b+d}$.
其次也可以用三元组来计算这些有理分数，先设定\left(\frac{0}{1},\frac{1}{1},\frac{1}{0}\right) 为初始状态，然后每一个节点设\left(\frac{a}{b},\frac{p}{q},\frac{c}{d}\right)计算\left(\frac{a}{b},\frac{a+p}{b+q},\frac{c}{d}\right),\left(\frac{a}{b},\frac{p+c}{q+d},\frac{c}{d}\right)作为左右节点，有用的部分是计算得到的节点
证明
考虑矩阵A= \begin{pmatrix} b & d \\ a & c \end{pmatrix}

根是单位阵
左边的节点是乘上矩阵L = \begin{pmatrix} 1 & 1 \\ 0 & 1 \end{pmatrix}
右边的节点是乘上R = \begin{pmatrix} 1 & 0 \\ 1 & 1 \end{pmatrix}
当然，加入的节点还是原来的算法

单调性的话自然成立，可以理解为糖水混合，不会比浓度高的浓，也不会比浓度低的淡然后为什么一定是互质即最简呢？


根据裴蜀定理

设 𝑎,𝑏 是不全为零的整数。那么，对于任意整数 𝑥,𝑦，都有 $gcd(𝑎,𝑏) ∣𝑎𝑥 +𝑏𝑦$ 成立；而且，存在整数 𝑥,𝑦，使得 $𝑎𝑥 +𝑏𝑦 =gcd(𝑎,𝑏)$ 成立。

这里我们取x=y=1，那么就有新的分子分母也互质。
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>过关考模拟考题解</title>
    <url>/ZestfulYK-blog/2025/10/23/%E8%BF%87%E5%85%B3%E8%80%83%E6%A8%A1%E6%8B%9F%E8%80%83%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[过关考模拟考题解A签到题
分析:

要是这也不会那学习委员真没招了

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    cout&lt;&lt;&quot;Help others voluntarily but never let them know they owe you a favor.&quot;&lt;&lt;endl;&#125;
B选择结构
分析:

按照要求逐个判断，然后取最小值就行了

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    double x,y,n,p,ans=200;    cin&gt;&gt;x&gt;&gt;y&gt;&gt;n&gt;&gt;p;    if(p&gt;=x) ans=min(ans,p-y);    ans=min(ans,p/10*n);    printf(&quot;%.2lf&quot;,ans);&#125;
C循环
分析:

分三种情况，&lt;10的一定成立，两三四位数自己判断就行了

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n,cnt=0; cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        if(i&lt;10) cnt++;        else if(i&lt;100)&#123;            if(i%10==i/10) cnt++;        &#125;        else if(i&lt;1000)&#123;            if(i%10==i/10%10&amp;&amp;i%10==i/100) cnt++;        &#125;        else if(i%10==i/10%10&amp;&amp;i%10==i/100%10&amp;&amp;i%10==i/1000) cnt++;    &#125;    cout&lt;&lt;cnt&lt;&lt;endl;&#125;

打表的做法

为什么没人想到这题能打表呢？总共也就28个数啊
#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int a[30]=&#123;1,2,3,4,5,6,7,8,9,11,    22,33,44,55,66,77,88,99,111,    222,333,444,555,666,777,888,999,1111,2222&#125;,n;    cin&gt;&gt;n;    for(int i=0;i&lt;=28;i++)&#123;        if(a[i]&gt;n) &#123;cout&lt;&lt;i&lt;&lt;endl;break;&#125;    &#125;&#125;
D菱形
分析:

逐行输出，先上半部分，再是后半部分

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n; cin&gt;&gt;n;    for(int i=0;i&lt;=n/2;i++)&#123;        for(int j=1;j&lt;=n/2-i;j++) cout&lt;&lt;&quot;.&quot;;        cout&lt;&lt;&quot;#&quot;;        for(int j=1;j&lt;=i*2-1;j++) cout&lt;&lt;&quot;.&quot;;        if(i!=0) cout&lt;&lt;&quot;#&quot;;        for(int j=1;j&lt;=n/2-i;j++) cout&lt;&lt;&quot;.&quot;;        cout&lt;&lt;endl;    &#125;    for(int i=n/2-1;i&gt;=0;i--)&#123;        for(int j=1;j&lt;=n/2-i;j++) cout&lt;&lt;&quot;.&quot;;        cout&lt;&lt;&quot;#&quot;;        for(int j=1;j&lt;=i*2-1;j++) cout&lt;&lt;&quot;.&quot;;        if(i!=0) cout&lt;&lt;&quot;#&quot;;        for(int j=1;j&lt;=n/2-i;j++) cout&lt;&lt;&quot;.&quot;;        cout&lt;&lt;endl;    &#125;&#125;
E金字塔
分析:

逐个循环相加就行了

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n,ans=0; cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++) ans+=i*i;    cout&lt;&lt;ans&lt;&lt;endl;&#125;
F假期阅读
分析:

最多k*t页，但不能超过n

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n,k,t; cin&gt;&gt;n&gt;&gt;k&gt;&gt;t;    cout&lt;&lt;min(n,k*t)&lt;&lt;endl;&#125;
G值日
分析:

求最小公倍数

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n,m,i; cin&gt;&gt;n&gt;&gt;m;    for(i=n;i%m!=0;i+=n);    cout&lt;&lt;i&lt;&lt;endl;&#125;
H数三角形
分析:

循环i 1..n，j 1..i即可，每次判断一下是否存在整数解

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n,cnt=0; cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=i;j++)&#123;            if(i*j%2==0) cnt++;        &#125;    &#125;    cout&lt;&lt;cnt&lt;&lt;endl;&#125;
I幂数和
分析:

直接暴力枚举所有数，判断是否能拆就行了遍历每种可能的情况，计算和是否为这个数就行了至于代码中的&lt;&lt;是二进制内左移的意思，用来计算2的n次幂比如1&lt;&lt;1是10，变成了2，同理还有右移，自己学习

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int l,r,cnt=0; cin&gt;&gt;l&gt;&gt;r;    for(int i=l;i&lt;=r;i++)&#123;        bool f=false;        for(int j=0;j&lt;=20;j++)&#123;            for(int k=0;k&lt;=20;k++)&#123;                if((1&lt;&lt;j)+(1&lt;&lt;k)==i) &#123;cnt++;f=true;break;&#125;            &#125;            if(f) break;        &#125;    &#125;    cout&lt;&lt;cnt&lt;&lt;endl;&#125;
J质因数分解
分析:

第一空，先输出n，免得后面n的值变掉了第二空判断是否算一个因子，当然最后一个是需要特判的第三空，既然发现了因子，那么把n减小，变为n/i第四空，找的不对，i自增，寻找下一个位置第五空，输出最后一个质因数

参考代码:

#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123;    ll n,i=2; cin&gt;&gt;n;    cout&lt;&lt;n&lt;&lt;&quot;=&quot;;    for(i=2;i&lt;=n;)&#123;        if(n%i==0&amp;&amp;n/i!=1)&#123;            cout&lt;&lt;i&lt;&lt;&quot;*&quot;;            n/=i;        &#125;        else&#123;            i++;        &#125;    &#125;    cout&lt;&lt;i-1&lt;&lt;endl;&#125;]]></content>
      <tags>
        <tag>程C课程题解</tag>
      </tags>
  </entry>
</search>
