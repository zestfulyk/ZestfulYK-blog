[{"title":"前缀和笔记","url":"/ZestfulYK-blog/2025/12/08/前缀和笔记/","content":"# 前缀和定义\n\n- 前缀和（Prefix Sum）是一种重要的预处理技术，能在**O(1)**时间内查询区间和，在算法竞赛和面试中应用广泛。以下是前缀和的主要应用场景和变种：\n## 1. 基本前缀和\n\n-  计算$\\Sigma_{i=1}^n a_i$的值，用来求区间和\n\n例如：\n```C++\n// 一维前缀和\nvector<int> pre(n+1, 0);\nfor (int i = 1; i <= n; i++) {\n    pre[i] = pre[i-1] + a[i];\n}\n// 查询区间[l, r]的和\nint sum = pre[r] - pre[l-1];\n```\n\n## 2. 二维前缀和\n\n用于计算矩阵的和$\\Sigma_{i=1}^n\\Sigma_{j=1}^na_{ij}$\n\n```C++\nvector<vector<int>> pre(m+1, vector<int>(n+1, 0));\nfor (int i = 1; i <= m; i++) {\n    for (int j = 1; j <= n; j++) {\n        pre[i][j] = a[i][j] + pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1];\n    }\n}\n// 查询子矩阵(x1,y1)-(x2,y2)的和\nint sum = pre[x2][y2] - pre[x1-1][y2] - pre[x2][y1-1] + pre[x1-1][y1-1];\n```\n\n前面两个的例题比较多，则行里就不举例了。\n\n---\n## 3. 前缀和与哈希表结合\n\n这是**最常用的变种**，用于解决\"区间和为k的区间个数\"问题：\n\n```C++\nint countSubarrays(vector<int>& nums,int k) {\n    unordered_map<int,int> mp; // 前缀和 -> 出现次数\n    mp[0] = 1; // 空数组的前缀和为0\n    int sum=0,count=0;\n    // sum拿来求前缀和，count求和为k的次数\n    for(int num:nums){\n        sum+=num;\n        // sum - target = pre[j]  => pre[j] = sum - k\n        if(mp.find(sum-k)!=mp.end())\n            count+=mp[sum-k];\n        mp[sum]++;\n    }\n    return count;\n}\n```\n上面的代码思路解释，首先，先计算前缀和的值，然后加到map里面，之后看有没有出现过sum-k这种前缀和，如果有，那么这一段的和就是k了，且有$mp[sum-k]$个，这样就计算出了答案\n\n例如：[K-大师和他的领域](https://ac.nowcoder.com/acm/contest/123093/K)\n这一题要我们找存在几个区间满足既含有k又满足k是这个区间的中位数。\n那么步骤：\n1.令小于k的为-1，大于k的为1，等于k的为0\n2.计算前缀和，统计前缀和一样的区间，这样区间内的和为0，说明k是这个区间的中位数，再使用$\\Sigma_{i=1}^{map.size()}C_{m_i}^2$计算总数就行了，这样得到可能的区间。\n3.但是还要保证区间内包含k，所以找到k位置，在两个k间的需要再用相同方法计算一次，\n4.最后减去即可\n\n就是说，要统计合法区间时，都可以把题目的要求变形一下，然后就可以使用这个思路了\n\n## 4. 前缀和与差分数组\n\n差分数组用于**区间修改，单点查询**：\n这一个没什么好说的，就是差分和前缀的互逆关系\n\n```C++\n// 初始化差分数组\nvector<int> diff(n+2, 0);\ndiff[1] = a[1];\nfor (int i = 2; i <= n; i++) {\n    diff[i] = a[i] - a[i-1];\n}\n// 区间[l, r]增加val\nvoid rangeAdd(int l, int r, int val) {\n    diff[l] += val;\n    diff[r+1] -= val;\n}\n// 恢复原数组\nfor (int i = 1; i <= n; i++) {\n    a[i] = a[i-1] + diff[i];\n}\n```\n\n## 5. 前缀最大/最小值\n\n```C++\n// 前缀最大值\nvector<int> preMax(n+1, INT_MIN);\nfor (int i = 1; i <= n; i++) {\n    preMax[i] = max(preMax[i-1], a[i]);\n}\n// 后缀最小值\nvector<int> sufMin(n+2, INT_MAX);\nfor (int i = n; i >= 1; i--) {\n    sufMin[i] = min(sufMin[i+1], a[i]);\n}\n```\n\n## 6. 前缀异或和\n\n用于处理区间异或问题：\n\n```C++\nvector<int> xorPre(n+1, 0);\nfor (int i = 1; i <= n; i++) {\n    xorPre[i] = xorPre[i-1] ^ a[i];\n}\n// 区间[l, r]的异或和\nint xorsum = xorPre[r] ^ xorPre[l-1];\n```\n\n## 7.二维差分数组\n\n```C++\n// 初始化二维差分\nvector<vector<int>> diff(m+2, vector<int>(n+2, 0));\n// 子矩阵(x1,y1)-(x2,y2)增加val\nvoid rangeAdd2D(int x1, int y1, int x2, int y2, int val) {\n    diff[x1][y1] += val;\n    diff[x2+1][y1] -= val;\n    diff[x1][y2+1] -= val;\n    diff[x2+1][y2+1] += val;\n}\n// 恢复原矩阵\nvector<vector<int>> res(m+1, vector<int>(n+1, 0));\nfor (int i = 1; i <= m; i++) {\n    for (int j = 1; j <= n; j++) {\n        res[i][j] = res[i-1][j] + res[i][j-1] - res[i-1][j-1] + diff[i][j];\n    }\n}\n```\n\n然后很重要的一点是，有时可能是假设前缀和数组，最后再反推原数组来进行构造。","tags":["算法"]},{"title":"异或笔记","url":"/ZestfulYK-blog/2025/12/08/容斥原理笔记/","content":"# 容斥原理的定义以及计算方式\n\n- 容斥原理是十分有用的一种计算方法，通常用于子集统计中\n- 该原理通过交替加减不同层次交集的大小，确保每个元素在并集中只被计算一次。虽然描述中的“只被两个集合重复的”可能指恰好属于两个集合的元素，但容斥原理实际处理的是所有交集（包含属于更多集合的元素），并通过后续的加减进行修正。\n- 原理：整体减空白的思想，不过也有韦恩图的一点思想，当子集数量大于3时，就有些抽象了，这时我们就需要总结一下规律。\n# 基本公式\n\n$$|A_1\\cup A_2\\cup ··· \\cup A_n|=\\Sigma|A_i|-\\Sigma|A_i\\cap A_j|+\\Sigma|A_i\\cap A_j\\cap A_k|+(-1)^{n+1}|A_1\\cap A_2 \\cap ···\\cap A_n|$$\n- 先加上所有子集，再减去每两个子集的重叠部分，再加上每三个子集的重叠部分···最后再是所有子集的交集。\n**重要观察**：每一个求和前面的符号只和选择了几个集合有关，所以在写代码的时候就会变得简单了。\n# 代码实现\n\n以题目[Count Good Numbers](https://codeforces.com/problemset/problem/2125/C)为例：\n题目要求我们统计因子里不含2,3,5,7的所有在区间$[l,r]$里的数字总量(翻译成人话)\n那么这不就是容斥原理吗？\n\n```C++\nll count_divisible(ll l, ll r, ll d) {\n    ll first= (l%d==0) ? l : l+d-l%d;  // 第一个能被 d 整除的数\n    ll last=r-r%d;                         // 最后一个能被 d 整除的数\n    if (first>last) return 0;                 // 如果没有这样的数\n    return (last-first)/d+1;\n}\nvoid solve(){\n    ll l,r;\n    cin>>l>>r;\n    int primes[]={2,3,5,7};               // 质数数组\n    ll ans=0;\n    // 枚举所有子集（包括空集），共 2^4 = 16 个\n    for(int mask=0;mask<(1<<4);mask++) {\n        ll d=1;\n        int cnt=0;                           // 子集中质数的个数\n        for(int i=0;i<4;i++){\n            if(mask&(1<<i)){\n                d*=primes[i];\n                cnt++;\n            }\n        }\n        // 根据子集大小的奇偶性决定符号\n        int sign=(cnt%2==0)?1:-1;\n        ans+=sign*count_divisible(l,r,d);\n    }\n    cout<<ans<<endl;\n}\n```\n\n- 主要思想：用二进制模拟是否要取得这一个集合，然后统计二进制中1出现的次数，即选择的集合数，来决定要加还是减。这样就大大减少了代码量，简单可维护性高。\n\n**备注：整体减空白的思想可以看华农的K题来学习，这里就不再列举了**","tags":["算法"]},{"title":"ACM训练","url":"/ZestfulYK-blog/2025/12/07/ACM训练题目解析/","content":"# 简单题\n\n- 对于简单题目，最好还是仔细一点，或者使用最暴力的解法，而不是投机取巧，或者构造高级方法，通常样例数据都是片面的，常常会有坑。\n\n[sleeping through classes](https://codeforces.com/contest/2173/problem/A)\n\n比如这一题，数据没有包含i+k中间有1的情况，直接i+=k导致错误。\n\n\n# 中等题目\n\n- 中等题目就需要强观察力和trick技巧了\n\n[Niko's Tactical Cards](https://codeforces.com/contest/2173/problem/B)\n\n这一道题目是动态规划的变种，虽然要求每一步最优，但是可能发生最小值突然转变成最大值的情况，因此，计算最小值也是必要的。只要计算这两个值就行了。\n\n[Kanade's Perfect Multiples](https://codeforces.com/contest/2173/problem/C)\n\n这题希望我们构造一个满足要求的B，这个就有点类似于筛法求素数了，实际上两者的代码几乎是一样的，但是在做的时候要注意区分原始数据和v数组，一个一个遍历就行了，找不到就可以直接退出，因为不然当前确定的最小值就无法被覆盖了。\n\n[Merging the Sets](https://codeforces.com/problemset/problem/2146/B)\n\n你想选择其中的一些集合（可能一个都不选，也可能全部都选），使得 1 和 m 之间的每个整数都包含在**个所选集合中的至少一个**中。\n思维误区，不用一边读入一边判断，因为数据保证$l\\leq 2*10^5$所以先读入再判断就行了，此外，要方法合法需要这个集合不存在也合法，那么只要用桶来看看去掉会不会变0就行了。原先想到的覆盖才合法的思路不对的原因是前后都有可能覆盖。\n\n[Abraham's Great Escape](https://codeforces.com/problemset/problem/2155/B)\n\n要求构造一个方阵，每个位置一个箭头，满足有k个格子能沿箭头出去。\n其实只要管最后一行，前面k个填U，后面的填D，最后一行填$RRR……RL$就行了\n比如：\n```C++\n1\n9 4\nUUU\nUDD\nRRL\n```\n这样在最后一行产生循环，前面的不管。原来的做法是两个两个组合，产生循环，虽然也能做，但是不方便。\n\n[Cake Assignment](https://codeforces.com/problemset/problem/2138/A)\n\n这个题目的重要观察点是，当最后一步确定后，上一步的操作一定是确定的，于是我们就可以倒推\n\n[XOR Array](https://codeforces.com/contest/2175/problem/B)\n\n这题的要求是构造一个数组，满足仅在l到r上的异或和为0，其他位置全非0，\n异或有一个特点，和前缀和一样，可以构建前缀异或和，因为$x\\oplus y \\oplus x==x$\n此外非常容易陷入的一个点是，可能会想到之间填入1-n来构造，但是实际上，这么异或会产生很多的0，所以这个方法是不行的。（比如1，2，3）\n因此，这里我们的操作是构造最终异或的结果，写一个前缀异或数组，最后再反推原数组就行了。\n详细信息可以见异或的笔记部分","tags":["算法"]},{"title":"DP笔记","url":"/ZestfulYK-blog/2025/12/07/DP学习笔记/","content":"# DP题目的特点\n\n- 数据较小，至少有一维是可以接受的，比如每一步的决策小于3，总数小于1000等等\n- 每一步的答案可以由之前的答案得到，比如数字三角形\n\n# DP题目的大致做法\n\n## 设DP数组\n\n- 明确DP数组的含义，保证每次求解的答案都是这个含义，不然就可能出错\n(这也是我之前的一大误区)\n\n## 分类讨论\n\n- 明确有几种决策方案，**明确这一步的答案是怎么推断出来的(非常重要!!!)**\n\n接下来编写代码就行了\n\n## 举例：迎新赛M题\n\n- 题目传送门：\n\n> [ZJUTOJ | 2024ZJUT迎新赛-决赛-M. 三色小屋](http://www.zjutacm.cn/problem/3118)\n\n### 题目理解：\n\n- 首先发现每一步的方案数可以接受，并且这一步的答案只由上一步转移而来，所以可以使用DP\n- 每个位置只能填R/G/B三种颜色，而且之和上一步和相邻的颜色有关，几种方案互不影响，符合动态规划的特点\n### 分类讨论：\n\n- 分为两大类，因为开头要初始化，所以单独讨论\n\n\n\n$$\ndp[i][j] = \n\\begin{cases}\ni==1\\begin{cases}\n\tc[i]==\\ '0' & \\text{可以用的颜色为1} \\\\\n\tc[i]\\ !=\\ \\ '0' & \\text{这个颜色为1}\n\\end{cases}\\\\ \\\\\ni\\ !=1\\begin{cases}\n\tc[i]==\\ '0' & \\text{可以填入的颜色为前两个的和} \\\\\n\tc[i] \\ !=\\ \\ '0' & \\text{这个颜色为前两个的和}\n\\end{cases}\n\\end{cases}\n$$\n\n## DP概率题\n\n### 求期望的几个重要公式\n\n$$\\begin{aligned}\nE(aX+b)=aE(x)+b \\\\ \\\\\nE(X+Y)=E(X)+E(Y)\\\\ \\\\\nE(XY)=E(X)E(Y)\n\\end{aligned}$$\n- 上面两个说明了期望的线性关系，下面两个说明了期望的独立性","tags":["算法"]},{"title":"第一类换元积分","url":"/ZestfulYK-blog/2025/12/07/不定积分笔记/","content":"\n## 重要公式\n\n#### 基本积分公式：\n\n**不要忘记加C!!!**\n\n$\\xi \\ \\delta \\ \\alpha \\ \\beta \\ \\pi \\  \\theta \\ \\in \\ \\notin$\n$\\Delta$\n\n$\\int k \\, dx = kx + C$\n$\\int x^n \\, dx = \\frac{x^{n+1}}{n+1} + C \\quad (n \\neq -1)$\n$\\int \\frac{1}{x} \\, dx = \\ln|x| + C$\n\n- 指数函数：\n$\\int e^x \\, dx = e^x + C$\n$\\int a^x \\, dx = \\frac{a^x}{\\ln a} + C$\n\n- 三角函数：\n$\\int \\sin x \\, dx = -\\cos x + C$\n$\\int \\cos x \\, dx = \\sin x + C$\n$\\int \\tan x \\, dx = -\\ln|\\cos x| + C$\n$\\int \\cot x \\, dx = \\ln|\\sin x| + C$\n$\\int \\sec^2 x \\, dx = \\tan x + C$\n$\\int \\csc^2 x \\, dx = -\\cot x + C$\n$\\int \\sec x \\tan x \\, dx = \\sec x + C$\n$\\int \\csc x \\cot x \\, dx = -\\csc x + C$\n$\\int secx\\,dx= ln|secx+tanx|+C$\n$\\int cscx\\,dx= ln|cscx-cotx|+C$\n\n\n- 反三角函数：\n$\\int \\frac{1}{\\sqrt{1-x^2}} \\, dx = \\arcsin x + C$\n$\\int \\frac{1}{1+x^2} \\, dx = \\arctan x + C$\n\n- 双曲函数：\n$\\int \\sinh x \\, dx = \\cosh x + C$\n$\\int \\cosh x \\, dx = \\sinh x + C$\n\n- 特殊积分：\n$\\int \\frac{1}{x^2+a^2} \\, dx = \\frac{1}{a}\\arctan\\frac{x}{a} + C$\n$\\int \\frac{1}{\\sqrt{a^2-x^2}} \\, dx = \\arcsin\\frac{x}{a} + C$\n$\\int \\frac{1}{x^2-a^2} \\, dx = \\frac{1}{2a}\\ln\\left|\\frac{x-a}{x+a}\\right| + C$\n\n- 和差化积公式：\n$\\sin A + \\sin B = 2 \\sin\\left(\\frac{A+B}{2}\\right) \\cos\\left(\\frac{A-B}{2}\\right)$\n$\\sin A - \\sin B = 2 \\cos\\left(\\frac{A+B}{2}\\right) \\sin\\left(\\frac{A-B}{2}\\right)$\n$\\cos A + \\cos B = 2 \\cos\\left(\\frac{A+B}{2}\\right) \\cos\\left(\\frac{A-B}{2}\\right)$\n$\\cos A - \\cos B = -2 \\sin\\left(\\frac{A+B}{2}\\right) \\sin\\left(\\frac{A-B}{2}\\right)$\n\n- 积化和差公式：\n$\\sin A \\cos B = \\frac{1}{2}[\\sin(A+B) + \\sin(A-B)]$\n$\\cos A \\sin B = \\frac{1}{2}[\\sin(A+B) - \\sin(A-B)]$\n$\\cos A \\cos B = \\frac{1}{2}[\\cos(A+B) + \\cos(A-B)]$\n$\\sin A \\sin B = -\\frac{1}{2}[\\cos(A+B) - \\cos(A-B)]$\n\n#### 对部分公式的推导：\n\n$\\int \\tan x \\, dx = -\\ln|\\cos x| + C$\n$\\int \\tan x \\, dx = \\int \\frac{sinx}{cosx} \\,dx = - \\int \\frac{dcosx}{sinx} \\, = -ln|cosx|+ C$\n\n- 对于 $\\int cotx$ 同理\n### 小技巧：\n\n- $sinx^m cosx^n$之类的，奇数的话拆一个进去积分，偶数的话用倍角或半角公式\n- 在对$\\int tanx\\,dx$或者$\\int secx\\,dx$等方法一样，可以类比\n\n奇数如$\\int sin^3 \\, dx$或者$\\int sin^3cosx\\,dx$等\n比如$\\int sinx^3\\,dx=-\\int sinx^2\\,dcosx=-\\int(1-cos^2x)\\,dcosx$\n$=-cosx+\\frac{1}{3}cosx^3+C$\n\n偶数如$\\int cosx^4\\,dx$等\n比如$\\int cosx^4\\,dx=\\int(\\frac{1+cos2x}{2})^2\\,dx=\\frac{1}{4}\\int1+cos2x^2+2cos2x\\,dx$\n$=\\frac{1}{4}(x+\\frac{1}{2}\\int cos2x^2\\,d2x+\\int cos2x\\,d2x)+C$\n$=\\frac{1}{4}(x+sin2x+\\frac{1}{2}\\int \\frac{1+cos4x}{2}\\,d2x)+C$\n$=\\frac{1}{4}(x+sin2x+\\frac{1}{8} \\int(1+cos4x)\\,d4x)+C$\n$=\\frac{1}{4}(x+sin2x+\\frac{1}{8}(4x+sin4x))+C$\n$=\\frac{3}{8}x+\\frac{1}{4}sin2x+\\frac{1}{32}sin4x+C$\n\n- 对于$\\frac{...+...}{...}$类的可能是把上面的式子拆成两个分别计算\n例如：$\\int \\frac{1+x}{\\sqrt{2-3x^2}}\\,dx$\n$=\\int \\frac{1}{\\sqrt{2-3x^2}}\\,dx+\\int \\frac{x}{\\sqrt{2-3x^2}}\\,dx$\n\n- 要熟记各种三角函数的导数和公式以及转换关系：\n $secx^2-1=tanx^2$\n $cscx^2-1=cotx^2$\n$$arctan(\\frac{1}{x})=\\begin{cases}\narccot(x)\\ \\ \\ \\ \\ \\ \\ \\ \\ x>0\\\\\narccot(x)-\\pi  \\ \\ x<0\n\\end{cases}$$\n#### 裂项计算积分\n注意，在第一类换元积分中，我们的计算只能处理$\\int \\frac{1}{ax+b}\\,dx$类的积分，所以，要变成分子是分母的导数的倍数的形式，（用$\\ln |x|$）来处理每一个分式。通常分母会是一个能因式分解的式子，然后要根据分母的形式来决定分子被写成什么样。\n例如:$\\int \\frac{x}{x^2-3x-4}\\,dx$\n这里我们首先对下面的式子进行因式分解，得到:$\\int \\frac{x}{(x-4)(x+1)}\\,dx$\n接下来我们来根据分母决定分子，应为分母是一次式子，所以分子应该对应常数，所以经过凑得到如下结果：$$\\frac{1}{5}\\int \\frac{4}{x-4}+\\frac{1}{x+1}\\,dx$$\n那么我们就能计算积分啦~\n\n### \n#### 含有 $\\sin x + \\cos x$ 的分母的积分\n\n对于含有 $\\sin x + \\cos x$ 的分母的积分，有一种类似于部分分式分解的方法。\n对于形如 $\\int \\frac{a\\sin x + b\\cos x}{c\\sin x + d\\cos x} dx$ 的积分，我们可以使用**线性组合法**，其核心思想是：\n\n**将被积函数的分子表示为分母和分母导数的线性组合**。\n**第一类积分实际上就是把前面的放到d里面，再除以对应的倒数即可**\n\n对于一般形式 $\\int \\frac{a\\sin x + b\\cos x}{c\\sin x + d\\cos x} dx$：\n\n1. 设 $D(x) = c\\sin x + d\\cos x$，$D'(x) = c\\cos x - d\\sin x$\n2. 解方程组：\n$$\\begin{cases} a=Ac-Bd \\\\\nb=Ad+Bc\n\n\\end{cases}$$\n求出 $A$ 和 $B$\n 积分变为：$$A\\int1dx+B\\int \\frac{D'(x)}{D(x)}\\,dx=Ax+Bln|D(x)|+C$$\n 对于更复杂的情况，如分母含有 $\\sin^2 x$、$\\cos^2 x$ 或 $\\sin x \\cos x$，可以使用：\n\n- 万能代换 $t = \\tan\\frac{x}{2}$\n- 三角恒等式化简\n- 配对积分法（如本文开始所示）\n\n\n\n- 我的通常做法是看被积函数有什么部分的导数在这里面出现过，然后提取这个部分\n\n例子：$\\int \\frac{1+lnx}{(xlnx)^3}\\,dx$\n\n下面的导数就是上面那一部分，所以直接提取就行了，按照我的逻辑来看，就是除去这个导数\n这两种理解方式实际上是一样的\n\n---\n## 第二类换元积分\n\n**第二类换元积分实际上就是把下换成t的代数式子再乘上这个式子的导数**\n**不要忘记乘以对应的倒数!!!**\n \n### 第二类换元积分法常用公式：\n\n- 三角代换：\n1. 含有 $\\sqrt{a^2-x^2}$，令 $x = a\\sin t$，则 $dx = a\\cos t\\, dt$\n   $\\int \\frac{1}{\\sqrt{a^2-x^2}} dx = \\arcsin\\frac{x}{a} + C$\n\n2. 含有 $\\sqrt{a^2+x^2}$，令 $x = a\\tan t$，则 $dx = a\\sec^2 t\\, dt$\n   $\\int \\frac{1}{\\sqrt{a^2+x^2}} dx = \\ln|x+\\sqrt{x^2+a^2}| + C$\n\n3. 含有 $\\sqrt{x^2-a^2}$，令 $x = a\\sec t$，则 $dx = a\\sec t\\tan t\\, dt$\n   $\\int \\frac{1}{\\sqrt{x^2-a^2}} dx = \\ln|x+\\sqrt{x^2-a^2}| + C$\n\n- 根式代换：\n1. 含有 $\\sqrt{ax+b}$，令 $t = \\sqrt{ax+b}$，则 $x = \\frac{t^2-b}{a}$，$dx = \\frac{2t}{a} dt$\n\n2. 含有 $\\sqrt[n]{ax+b}$，令 $t = \\sqrt[n]{ax+b}$，则 $x = \\frac{t^n-b}{a}$，$dx = \\frac{nt^{n-1}}{a} dt$\n\n- 倒代换：\n对于形如 $\\int \\frac{1}{x\\sqrt{ax^2+bx+c}} dx$ 等积分，可令 $x = \\frac{1}{t}$，则 $dx = -\\frac{1}{t^2} dt$\n\n- 欧拉代换：\n1. 对于 $\\sqrt{ax^2+bx+c}$，当 $a>0$ 时，令 $\\sqrt{ax^2+bx+c} = t-\\sqrt{a}x$\n2. 当 $c>0$ 时，令 $\\sqrt{ax^2+bx+c} = tx+\\sqrt{c}$\n\n- 万能代换：\n对于三角有理式 $\\int R(\\sin x, \\cos x) dx$，令 $t = \\tan\\frac{x}{2}$，则\n$\\sin x = \\frac{2t}{1+t^2}$，$\\cos x = \\frac{1-t^2}{1+t^2}$，$dx = \\frac{2}{1+t^2} dt$\n\n- 双曲代换：\n1. 含有 $\\sqrt{x^2+a^2}$，令 $x = a\\sinh t$，则 $dx = a\\cosh t\\, dt$\n2. 含有 $\\sqrt{x^2-a^2}$，令 $x = a\\cosh t$，则 $dx = a\\sinh t\\, dt$\n\n- 常用结论：\n$\\int \\sqrt{a^2-x^2} dx = \\frac{x}{2}\\sqrt{a^2-x^2} + \\frac{a^2}{2}\\arcsin\\frac{x}{a} + C$\n$\\int \\sqrt{a^2+x^2} dx = \\frac{x}{2}\\sqrt{a^2+x^2} + \\frac{a^2}{2}\\ln|x+\\sqrt{x^2+a^2}| + C$\n$\\int \\sqrt{x^2-a^2} dx = \\frac{x}{2}\\sqrt{x^2-a^2} - \\frac{a^2}{2}\\ln|x+\\sqrt{x^2-a^2}| + C$\n\n\n---\n\n### 重要例题\n#### 积分 $\\int \\frac{1}{x\\sqrt{x^2+1}} dx$ 的两种解法\n\n###### 方法一：三角代换\n\n令 $x = \\tan t$，则：\n- $dx = \\sec^2 t\\, dt$\n- $\\sqrt{x^2+1} = \\sqrt{\\tan^2 t + 1} = \\sec t$\n\n代入原积分：\n$$\\int \\frac{1}{x\\sqrt{x^2+1}} dx = \\int \\frac{1}{\\tan t \\cdot \\sec t} \\cdot \\sec^2 t\\, dt = \\int \\frac{\\sec t}{\\tan t} dt$$\n\n化简：\n$$\\int \\frac{\\sec t}{\\tan t} dt = \\int \\frac{\\frac{1}{\\cos t}}{\\frac{\\sin t}{\\cos t}} dt = \\int \\frac{1}{\\sin t} dt = \\int \\csc t\\, dt$$\n\n利用公式：\n$$\\int \\csc t\\, dt = \\ln|\\csc t - \\cot t| + C$$\n\n将变量换回 $x$：\n- $\\csc t = \\frac{\\sqrt{x^2+1}}{x}$\n- $\\cot t = \\frac{1}{x}$\n\n最终结果：\n$$\\int \\frac{1}{x\\sqrt{x^2+1}} dx = \\ln\\left|\\frac{\\sqrt{x^2+1}-1}{x}\\right| + C$$\n\n##### 方法二：倒代换\n\n令 $x = \\frac{1}{t}$，则：\n- $dx = -\\frac{1}{t^2} dt$\n- $\\sqrt{x^2+1} = \\sqrt{\\frac{1}{t^2}+1} = \\frac{\\sqrt{1+t^2}}{|t|}$\n\n代入原积分（假设 $t>0$，即 $x>0$）：\n$$\\int \\frac{1}{x\\sqrt{x^2+1}} dx = \\int \\frac{1}{\\frac{1}{t} \\cdot \\frac{\\sqrt{1+t^2}}{t}} \\cdot \\left(-\\frac{1}{t^2}\\right) dt = -\\int \\frac{1}{\\sqrt{1+t^2}} dt$$\n\n利用公式：\n$$\\int \\frac{1}{\\sqrt{1+t^2}} dt = \\ln|t+\\sqrt{1+t^2}| + C$$\n\n代入 $t = \\frac{1}{x}$：\n$$-\\ln\\left|\\frac{1}{x}+\\sqrt{1+\\frac{1}{x^2}}\\right| + C = -\\ln\\left|\\frac{1+\\sqrt{x^2+1}}{x}\\right| + C$$\n\n化简：\n$$-\\ln\\left|\\frac{1+\\sqrt{x^2+1}}{x}\\right| = \\ln\\left|\\frac{x}{1+\\sqrt{x^2+1}}\\right| = \\ln\\left|\\frac{x(\\sqrt{x^2+1}-1)}{x^2}\\right| = \\ln\\left|\\frac{\\sqrt{x^2+1}-1}{x}\\right|$$\n\n最终结果：\n$$\\int \\frac{1}{x\\sqrt{x^2+1}} dx = \\ln\\left|\\frac{\\sqrt{x^2+1}-1}{x}\\right| + C$$\n\n###### 结论\n\n两种方法得到相同的结果：\n$$\\int \\frac{1}{x\\sqrt{x^2+1}} dx = \\ln\\left|\\frac{\\sqrt{x^2+1}-1}{x}\\right| + C$$\n\n三角代换思路直接，倒代换计算简洁，两种方法都有效解决此类积分问题。\n\n#### 积分$\\int x^2(2x-3)^{10}\\,dx$的计算\n\n- 直接换元，这里不适合分步积分\n令$t=2x-3$来简化计算。然后就发现可以展开这个式子了。\n\n\n\n---\n### 什么时候可以统一结果？\n\n**在以下情况下，可以将负号放到三角函数中统一结果：**\n\n1. **当三角函数在某个区间内保持相同符号时**\n    \n    - 对于 $\\sqrt{x^2 - a^2}$，使用 $x = a\\sec\\theta$\n        \n    - 对于 $\\sqrt{a^2 - x^2}$，使用 $x = a\\sin\\theta$ 或 $x = a\\cos\\theta$\n        \n    - 对于 $\\sqrt{x^2 + a^2}$，使用 $x = a\\tan\\theta$\n        \n2. **选择的角范围要保证：**\n    \n    - 代换函数是单调的（便于反函数存在）\n        \n    - 根号内的表达式化简后不产生绝对值\n        \n3. **常见的选择：**\n    \n    - $\\sqrt{x^2 - a^2}$：$\\theta \\in (0, \\pi/2) \\cup (\\pi, 3\\pi/2)$\n        \n    - $\\sqrt{a^2 - x^2}$：$\\theta \\in (-\\pi/2, \\pi/2)$\n        \n    - $\\sqrt{x^2 + a^2}$：$\\theta \\in (-\\pi/2, \\pi/2)$\n\n此外含有$e^x$式子有特殊的计算技巧。\n例如：$$\\int \\frac{1}{e^x+1}\\,dx=\\int \\frac{e^{-x}}{e^{-x}+1}\\,dx$$\n从而实现第一类换元积分。","tags":["数学"]},{"title":"有理函数积分","url":"/ZestfulYK-blog/2025/12/07/不定积分笔记2（有理函数和部分积分）/","content":"# 基本方法\n\n- 凑成能第一类换元积分的式子\n\t例如$\\frac{1}{...}$类的\n部分分式分解\n## 有理函数积分适用条件\n- 1. 有理函数积分\n当被积函数是**有理函数**（两个多项式的商）时：$\\int \\frac{Q(x)}{P(x)}\\,​dx$\n其中 $P(x)$ 和 $Q(x)$ 都是多项式。\n- 2. 分母可因式分解\n\n部分分式分解是处理**有理函数积分**的**系统方法**，特别适用于：\n- 分母可明确因式分解\n- 没有更简单的特殊技巧\n- 需要精确解析表达式\n\n当分母 $Q(x)$ 可以分解为**一次因式**和**不可约二次因式**的乘积时：\n- **一次因式**：$(x-a)$\n- **不可约二次因式**：$(x^2+px+q)$，其中 $p^2-4q<0$\n#### 具体分解规则\n##### 对于一次因式 $(x-a)^k$：\n\n对应部分为：\n$$\\frac{A_1}{x-a}+\\frac{A_2}{(x-a)^2}+···+\\frac{A_k}{(x-a)^k}$$\n##### 对于二次因式 $(x^2+px+q)^m$：\n\n$$\\frac{B_1x+C_1}{x^2+px+q}+\\frac{B_2x+C_2}{(x^2+px+q)^2}+···+\\frac{B_mx+C_m}{(x^2+px+q)^k}$$\n\n但是，在这个部分有一种特殊情况，就是二次式:\n$$\\int \\frac{P(x)}{Q(x)^2}$$\n>在这里，可以把函数看成$\\frac{d}{dx}\\frac{Ax+B}{Q(x)}+\\frac{C}{Q(x)}$两种方法实际上是等价的，因为最后必然化成一个简单的倒数积分和简单的分数积分$\\frac{1}{Q(x)}$。\n\n### 例子：\n- 计算$\\int \\frac{x^2+1}{(x^2+x+1)^2}\\,dx$有两种方式，都能得到答案。\n1.用标准公式计算\n得到:\n$$\\int \\frac{x}{(x^2+x+1)^2}\\,dx-\\int \\frac{1}{x^2+x+1}\\,dx$$\n\n接着再分别计算前后的积分，前面得到的是一个分式加上一个含$\\arctan x$的式子\n比较麻烦，不过对于这类题目，我们知道一定能得到第二种简单的方法的式子，所以经过计算\n得到:\n$$\\frac{1}{3}\\frac{d}{dx}\\frac{x+2}{x^2+x+1}-\\frac{4}{3}\\int · \\frac{1}{x^2+x+1}\\,dx$$\n这种解法的好处是，得到前半段以后可以直接当作积分结果，不需要额外的处理。\n#### 判断步骤\n##### 第一步：检查是否为真分式\n- 如果 $\\deg P(x) \\geq \\deg Q(x)$：先进行**多项式除法**（大除法）\n- 如果 $\\deg P(x) < \\deg Q(x)$：直接进行部分分式分解\n 就是说最高项次数小就能用这个方法\n##### 第二步：因式分解分母\n将分母 $Q(x)$ 完全分解为：\n- 一次因式 $(x-a_i)^{k_i}$\n- 不可约二次因式 $(x^2+p_jx+q_j)^{m_j}$\n##### 第三步：确定分解形式\n根据因式分解结果，写出部分分式的**一般形式**。\n在计算过程中，可以通过给x赋值来快速计算带定值\n\n#### 具体例子分析\n\n##### 例1：$\\int \\frac{x^3+1}{(x^2+1)^2} dx$\n\n- 分母：$(x^2+1)^2$（二次因式的平方）\n- 分解形式：$\\frac{Ax+B}{x^2+1} + \\frac{Cx+D}{(x^2+1)^2}$\n\n##### 例2：$\\int \\frac{1}{x(x-1)^2} dx$\n\n- 分母：$x(x-1)^2$（一次因式及其平方）\n- 分解形式：$\\frac{A}{x} + \\frac{B}{x-1} + \\frac{C}{(x-1)^2}$\n\n##### 例3：$\\int \\frac{x^2+1}{x(x^2+4)} dx$\n\n- 分母：$x(x^2+4)$（一次因式 + 二次因式）\n- 分解形式：$\\frac{A}{x} + \\frac{Bx+C}{x^2+4}$\n\n**例4：**$\\int \\frac{x+1}{x^2+4x+6}\\,dx$\n这个题目看起来和裂项十分相似，但是分母无法因式分解，所以这个方法是不对的。\n注意到这里上方的次数正好是分母求导结束后的次数，所以游客能采取分开计算的方法。\n这里首先先把上面的分析翻倍，（因为分母的导数是$2x+4$），接下来在加一个2，减一个2外面再配上$\\frac{1}{2}$即可。\n所以式子变为:$\\frac{1}{2} \\int \\frac{2x+4-2}{x^2+4x+6}\\,dx$然后两个部分正好都是我们能计算的第一类换元积分，完成！\n\n- $\\int \\frac{f'(x)}{f(x)} dx$：直接得到 $\\ln|f(x)|$\n- $\\int \\frac{1}{x^2+a^2} dx$：直接得到 $\\frac{1}{a}\\arctan\\frac{x}{a}$\n\n## 个人技巧\n\n- 对于一般的式子，通常是去凑积分，先对其1次项，再分离常数项，这样就能直接得到一个ln积分和一个形如$\\frac{p}{t^2+a^2}$的式子了，这个是很好积分的($\\arctan x$)\n- 遇到三次式子，可能配凑一个$\\pm 1$来计算\n- 遇到分母次数很高的，考虑倒代换\n- 其余的式子，直接展开就行了\n\n## 三角代换部分\n\n### 重要公式\n当取$\\tan x=u$时\n$$\\begin{cases}\n\\sin x=\\frac{u}{\\sqrt{1+u^2}} \\\\\n\\cos x=\\sqrt{1+u^2}\n\\end{cases}\n$$\n\n当取$\\tan \\frac{x}{2}=u$时\n$$\\begin{cases}\n\\sin x=\\frac{2u}{1+u^2} \\\\\n\\cos x=\\frac{1-u^2}{1+u^2}\n\\end{cases}\n$$\n\n然后不要忘记，第二类换元积分是需要乘上对应的导数的，**这个导数是t关于x的函数**，乘上的是含有t的导数\n之后像前面一样计算就行了。\n\n#### 题型分类\n- 只含有一种三角函数的，用第一类换元积分，例如：$\\int \\frac{1}{\\sin x^4}\\,dx$\n- 上下均有且为一次式的，用上节课的方法代换，例如$\\int \\frac{\\sin x}{\\sin x+\\cos x}\\,dx$\n- 同名三角函数相加，和差化积，例如$\\int \\frac{1}{\\sin x+\\sin 3x}\\,dx$\n- 正常幂(不含分母的)，按奇偶正常拆分\n- 分母含有高次项的，拆解1，例如$\\int \\frac{1}{\\sin x\\cos x^2}$\n主要是把$\\cos x$化成$\\tan x$来计算。\n例如：1$$\\int \\frac{dx}{a^2+\\sin x^2+b^2+\\cos x^2}=\\int \\frac{\\frac{1}{\\cos x^2}}{a^2\\tan x^2+b^2}\\,dx=\\int \\frac{1+\\tan x^2}{a^2\\tan x^2+b^2}\\,dx$$\n## 根式的代换\n\n### 重要公式\n\n令$$t=\\sqrt[n]{ax+b}$$\n令$$t=\\sqrt[n]{\\frac{ax+b}{cx+d}}$$\n令$$t=\\sqrt[mn]{ax+b}$$\n看含有什么来决定怎么设t\n最后反解出x带入其余部分即可。\n\n### 重要例题根式代换类型\n\n求下面这个函数的积分\n$$\\int \\frac{dx}{\\sqrt[n]{(x-a)^{n+1}(x-b)^{n-1}}}\\,dx$$\n方法：先提取部分，构造类似上面2的一个式子，然后再考虑代换。\n$$\\text{原式}=\\int\\frac{1}{(x-a)(x-b)\\sqrt[n]{\\frac{x-a}{x-b}}}\\,dx$$\n不过接下来直接解出x再带回比较麻烦，所以考虑直接算出$\\frac{dx}{(x-a)(x-b)}$这个部分\n$$t^n=\\frac{a-b}{(x-b)^2}$$\n$$\\frac{nt^n\\,dt}{t}=\\frac{a-b}{(x-b)^2}\\,dx$$\n$$\\frac{n\\,dt}{t}=\\frac{a-b}{(x-b)^2t^n}\\,dx=\\frac{a-b}{(x-a)(x-b)}\\,dx$$\n所以得到原式变为：\n$$-\\frac{n}{a-b}\\sqrt[n]{\\frac{x-b}{x-a}}$$\n## 重要例题偶数次幂分数类型\n\n方法是化为平方分之括号内函数的导数\n即：\n$$\\int \\frac{f'(x)}{f(x)^2+a}$$\n例如：\n$$\\int \\frac{1}{x^4+1}\\,dx=\\frac{1}{2}\\int\\frac{1+\\frac{1}{x^2}-1}{x^2+\\frac{1}{x^2}}=\\frac{1}{2}(\\int \\frac{d x-\\frac{1}{x}}{(x-\\frac{1}{x})^2+2}+\\int \\frac{d x+\\frac{1}{x}}{(x+\\frac{1}{x})^2+2})$$$$=\\frac{1}{2\\sqrt{2}}\\arctan \\frac{x-\\frac{1}{x}}{\\sqrt{2}}-\\frac{1}{4\\sqrt{2}}\\ln|\\frac{x^2-\\sqrt{2}x+1}{x^2+\\sqrt{2}x+1}|$$\n 所以类似于$\\frac{\\text{二次}}{\\text{四次}}$的式子，理论上都有可能用这种方式解决","tags":["数学"]},{"title":"分步积分笔记","url":"/ZestfulYK-blog/2025/12/07/分步积分/","content":"\n## 核心公式\n$$\\int u\\,dv = uv - \\int v\\,du$$\n\n## 选择原则：\"反对幂指三\"\n优先级从高到低选择 $u$：\n- **反**三角函数（$arcsin$,$arccos$, $arctan$等）\n- **对**数函数（$\\ln x$, $log x$等）\n- **幂**函数（$x^n$, $x^2$, $\\sqrt{x}$等）\n- **指**数函数（$e^x$, $a^x$等）\n- **三**角函数（$\\sin x$, $\\cos x$等）\n\n**口诀解释**：越靠前的类型越优先选为 $u$，越靠后的类型越优先放入 $dv$。\n\n---\n\n## 经典类型与解法\n\n### 类型1：幂函数 × 三角函数\n$\\int x^n\\cos x\\,dx$ 或 $\\int x^n\\sin x\\,dx$\n- 将三角函数放入 $dv$（如 $\\cos x\\,dx = d(\\sin x)$）\n- 通过 $n$ 次分部积分逐次降幂\n\n### 类型2：幂函数 × 指数函数\n$\\int x^n e^{ax}\\,dx$\n- 将指数函数放入 $dv$（如 $e^{ax}\\,dx = \\frac{1}{a}d(e^{ax})$）\n- 逐次降幂至 $x^0$\n\n### 类型3：幂函数 × 对数函数\n$\\int x^n \\ln x\\,dx$\n- 将对数函数选为 $u$（$\\ln x$ 求导得 $\\frac{1}{x}$，可消去 $x$ 幂）\n- 幂函数放入 $dv$\n\n### 类型4：指数函数 × 三角函数\n$\\int e^{ax}\\sin(bx)\\,dx$ 或 $\\int e^{ax}\\cos(bx)\\,dx$\n- 任选其一放入 $dv$（通常选三角函数）\n- 两次分部积分后出现循环，解方程求得原积分\n\n---\n\n## 高级技巧与注意事项\n\n### 技巧1：隐藏的 $dv$\n当被积函数为分式时，常将分母或其部分放入 $dv$：\n$$\\int \\frac{x\\arcsin x}{\\sqrt{1-x^2}}\\,dx$$\n令 $u=\\arcsin x$，$dv=\\frac{x}{\\sqrt{1-x^2}}dx$，则 $v=-\\sqrt{1-x^2}$\n\n### 技巧2：凑微分调整\n对于 $\\int \\frac{x}{e^{2x}}\\,dx$，可改写为 $\\int x e^{-2x}\\,dx$\n- 令 $u=x$，$dv=e^{-2x}dx$\n- 则 $du=dx$，$v=-\\frac{1}{2}e^{-2x}$\n- 代入公式：$-\\frac{1}{2}xe^{-2x} + \\frac{1}{2}\\int e^{-2x}dx$\n\n### 技巧3：多次分部积分\n$$\\int x^2 e^x\\,dx = x^2 e^x - 2\\int x e^x\\,dx$$\n需连续使用分部积分，直到幂函数降为常数\n\n### 技巧4：递推关系\n某些积分可建立递推公式：\n$$\\int x^n e^x\\,dx = x^n e^x - n\\int x^{n-1} e^x\\,dx$$\n\n### 技巧5：组合拆分\n对于 $\\int e^x(\\sin x + \\cos x)\\,dx$，可拆分为两个分部积分，但更简单的方法是观察导数关系：\n$d(e^x \\sin x) = e^x(\\sin x + \\cos x)dx$\n\n---\n\n## 常见易错点\n1. **符号错误**：公式中的减号易漏写\n2. **$v$ 计算错误**：求 $v$ 时积分常数可省略（因最后会抵消）\n3. **选择不当**：违反\"反对幂指三\"可能导致积分更复杂\n4. **循环处理**：$\\int e^x \\sin x\\,dx$ 类问题，移项时注意系数\n\n---\n\n## 典型例题\n\n### 例1：对数函数\n$$\\int \\ln x\\,dx = x\\ln x - \\int x\\cdot\\frac{1}{x}dx = x\\ln x - x + C$$\n\n### 例2：反三角函数\n$$\\int \\arcsin x\\,dx = x\\arcsin x - \\int \\frac{x}{\\sqrt{1-x^2}}dx = x\\arcsin x + \\sqrt{1-x^2} + C$$\n\n### 例3：循环积分\n$$\\int e^x \\sin x\\,dx$$\n- 第一次：$u=\\sin x$，$dv=e^x dx$，得 $e^x \\sin x - \\int e^x \\cos x\\,dx$\n- 第二次：对 $\\int e^x \\cos x\\,dx$ 再分部积分\n- 得方程：$I = e^x \\sin x - e^x \\cos x - I$\n- 解得：$I = \\frac{e^x(\\sin x - \\cos x)}{2} + C$\n\n### 例4：含负指数\n$$\\int \\frac{\\arctan e^x}{e^{2x}}\\,dx = -\\frac{1}{2}\\int \\arctan e^x\\,d(e^{-2x})$$\n令 $u=\\arctan e^x$，$dv=d(e^{-2x})$，需注意 $du=\\frac{e^x}{1+e^{2x}}dx$\n\n---\n\n## 特殊情形处理\n1. **只有一类函数**：如 $\\int \\ln x\\,dx$，视为 $1\\cdot\\ln x\\,dx$\n2. **乘积含三个因子**：先组合两个放入 $dv$，或换元简化\n3. **分母复杂**：考虑整体代换或分部积分后消去分母\n4. **定积分**：计算时先求原函数，注意上下限代入\n\n**还有更重要的一点是**\n不要被形式迷惑了双眼，$\\frac{1}{\\cos x^2}$是什么啊？不认识？这就不对了\n我认为，直接先表示回去就行了，这下认出来了（\n然后看到对$\\sec x$求导时不要忘记公式，还在企图自己推导\n\n## 商的导数逆运算（反向商法则）\n\n在积分中，有时会遇到形如 $\\frac{u'v - uv'}{v^2}$ 的被积函数，这正是商函数 $\\left( \\frac{u}{v} \\right)'$ 的导数。因此，可以直接写出原函数 $\\frac{u}{v} + C$。\n\n---\n\n### 核心识别技巧\n\n1. **分母为平方形式**：通常为 $v^2$ 或可化为 $v^2$。\n2. **分子为两项之差**：且每项均为两个函数的乘积（即 $u'v$ 和 $uv'$）。\n3. **找出 $u$ 和 $v$**：从分母中猜测 $v$（通常为分母的“一部分”），再根据分子确定 $u$。\n\n---\n\n### 一般步骤\n\n设被积函数为 $\\frac{P(x)}{Q(x)}$：\n1. 尝试将 $Q(x)$ 写成 $v^2$ 的形式（或类似）。\n2. 观察 $P(x)$ 是否能表示为 $u'v - uv'$。\n3. 若可以，则积分结果为 $\\frac{u}{v} + C$。\n例题：\n$$\\int\\frac{xf'(x)-(1+x)f(x)}{x^2e^x}\\,dx$$\n- **分母**：$x^2 e^x = (x e^x)^2 \\cdot e^{-x}$？实际上，直接考虑函数 $\\frac{f(x)}{x e^x}$ 的导数。\n- 设 $v = x e^x$，则 $v' = (1+x)e^x$。\n- 设 $u = f(x)$，则 $u' = f'(x)$。\n- 计算 $\\left( \\frac{u}{v} \\right)' = \\frac{u'v - uv'}{v^2} = \\frac{f'(x) \\cdot x e^x - f(x) \\cdot (1+x)e^x}{(x e^x)^2} = \\frac{x f'(x) - (1+x)f(x)}{x^2 e^x}$。\n- 因此，原积分 $= \\frac{f(x)}{x e^x} + C$。\n\n### 常用构造\n\n1. **对于 $\\int \\frac{f'(x)g(x) - f(x)g'(x)}{g(x)^2} dx$**，结果为 $\\frac{f(x)}{g(x)} + C$。\n2. **对于 $\\int \\frac{f'(x)g(x) - f(x)g'(x)}{[g(x)]^n} dx$**（$n \\neq 2$），通常需要调整。","tags":["数学"]},{"title":"华中农业达大学迎新赛题解与反思","url":"/ZestfulYK-blog/2025/12/07/华中农业达大学迎新赛题解与反思/","content":"\n[M-终极考验](https://ac.nowcoder.com/acm/contest/123093/M)\n\n这题的大致思路是对的，但是最后处理差分时，直接选择了min(i+x,n)，这个就不对了，因为我们要的不是二选1，而是只有在满足要求时才处理。所以把min改成if判断就行了，下次需要注意这个逻辑问题。\n\n[H-对决](https://ac.nowcoder.com/acm/contest/123093/H)\n\n这个题目是纯暴力的搜索题，那么只要一个一个判断就好了，但是此处注意循环范围是$\\leq n-4$而不是$<n-4$.最好自己先之上推导一下再提交\n\n[B-爱的魔法](https://ac.nowcoder.com/acm/contest/123093/B)\n\n这一题一开始的错误原因是没有注意到交换最接近的会导致得到的不是最大的数字，例如1999，交换以后是9199是不对的，所以要倒遍历。建议自己先多造几组数据再提交，包括一些边界情况等等。随机数也不错（较小范围能手推的）\n\n","tags":["算法"]},{"title":"ACM数字类题目","url":"/ZestfulYK-blog/2025/12/07/数字类算法/","content":"# 数字类题目\n\n- 定义：通常有乘除法，或者时分解质因数之类的\n\n**重要观察**\n\n$2^{30} >= 10^9$所以一般不需要几个数就能乘到上界，除法的话同理，分解质因数实际上也算乘法。\n因此这类题目往往可以比较暴力的解决。因为只要枚举这几个位置即可。\n\n重要例题：\n\n1.题目传送门[Strange Machine](https://codeforces.com/contest/2156/problem/B)\n- 重要观察：$log_2(10^9)=30$,所以除去全是1的情况，每次除2最多30次循环就结束了，因此可以暴力解决。除了有1的情况，因为n最大为20，所以最多$20*30$每个数据。\n\n2.题目传送门[Even Modulo Pair](https://codeforces.com/contest/2164/problem/B)\n- 重要观察，要塞大量数据来导致超时的话是不可能的，因为在30个数内必然能找到。\n理由：首先如果只有偶数，那么一定有解。（因为严格递增）\n\t当只有奇数时：\n\t因为当$y<2*x$时，必然有$y \\mod x \\ = \\ y-x \\ = \\text{偶数}$,因此要构造较大的数据的话，只能让$y \\geq x *2$\n\t要让$y \\mod x \\ !=  \\text{偶数}$，那么最小只能构造$y=x*2$那么和上一题就一样了。\n\n3.题目传送门[Add 0 or K](https://codeforces.com/problemset/problem/2134/B)\n- 题目理解，首先要求吧原数组每个元素加上K的若干倍，构成含有相同因子的数组。\n- 重要观察：加完以后，因为含有相同的因子，所以考虑把每个加完以后的数字拆分，得到一串质数，而前29个质数的乘积已经大于$10^9$了，所以直接可以算出最终的共同因子。\n接下来对最后结果化简$a_i+c_i*k \\equiv 0  (mod\\ g)$,所以$c_i=(-a_i)*inv_k$\n而k存在$mod \\ g$下有逆元，需要g和k互质，所以可以简单完成。\n\n4.题目传送门[C-区间乘_2025年广东工业大学新生赛（同步赛）](https://ac.nowcoder.com/acm/contest/123428/C)\n- 希望我们计算一个区间的乘积，判断是否可能达到给定的输出。\n- 数据规模n和查询规模q都是$2*10^5$所以不能直接查询。\n- 重要观察：如果把1去掉算法就能变简单，而如果不是全为1的话，查询数据$x \\leq 10^9$，所以当不是1的时候，只要30个2就能超过数据范围了，每个位置计算一下，可以直接提取计算可能出现的数字，故最多$30*2*10^5$次计算，查询$q\\log_2(x)$次就行了\n所以最终时间复杂度是$O(T*count*q\\log_2(q))$ \ndirt=（总提交次数-过题数量）/总提交次数\n\n然后注意，只有质因数时可以用，其他的如因子就不行\n出现奇偶判断的也不要用这个方法，用奇偶性分析特判","tags":["算法"]},{"title":"异或笔记","url":"/ZestfulYK-blog/2025/12/07/异或笔记/","content":"### 一、 异或的基本性质（基石）\n\n记住这四条，其他大多可以推导：\n\n1. **归零律**：`a ⊕ a = 0`\n2. **恒等律**：`a ⊕ 0 = a`\n3. **自反性**（交换律与结合律的推论）：`a ⊕ b ⊕ a = b`\n4. **交换律**与**结合律**：运算顺序和分组不影响结果。这使得前缀异或成为可能。\n\n### 二、 前缀异或：子数组问题的利器\n\n这是处理**子数组异或和查询**最核心的技巧，类似于前缀和。\n\n- **定义**：设 `pre[i] = a[1] ⊕ a[2] ⊕ ... ⊕ a[i]`，并约定 `pre[0] = 0`。\n- **核心公式**：`a[l] ⊕ a[l+1] ⊕ ... ⊕ a[r] = pre[r] ⊕ pre[l-1]`\n    - **原理**：`pre[r] ⊕ pre[l-1] = (前缀到r) ⊕ (前缀到l-1)`，根据结合律和归零律，相同的部分（前l-1项）抵消，剩下就是区间 `[l, r]` 的异或和。\n- **应用场景**：\n    - 快速求任意子数组异或和。\n    - 将“子数组异或和为0”的条件转化为 `pre[r] == pre[l-1]`。**这是解题的关键一步！**\n    - 问题转化为对前缀异或数组 `pre` 的分析，常结合哈希表（`unordered_map`）来统计次数、寻找配对。\n\n### 三、 位运算的独特性质（解题突破口）\n\n1. **不进位加法/减法**：异或在每一位上独立操作。`a ⊕ b` 在二进制下，每一位的规则是“相同为0，不同为1”。这暗示我们可以**按位考虑问题**。\n2. **判断奇偶性**（结合律的妙用）：\n    - 多个数异或，结果的**最低位** 等于 所有数最低位的异或。\n    - 而一个数二进制最低位为 `1` 代表奇数，为 `0` 代表偶数。\n    - **推论**：在一堆数中，异或结果的奇偶性 等于 所有数奇偶性的异或。这在一些博弈或奇偶分类问题中有用。\n3. **与加法的关系**：`a ⊕ b <= a + b`。等号成立当且仅当 `a` 和 `b` 的二进制表示没有同时为1的位（即 `a & b == 0`）。这个性质在涉及“最大异或和”与“和”的比较时常用。\n4. **构造互补对**：对于任意数 `x`，存在唯一的数 `y`，使得 `x ⊕ y = (全1的二进制串)`，这个 `y` 等于 `~x`（在限定位数下）。在构造题中，常用 `(1<<k)-1 - x` 来得到与 `x` 在 `k` 位下每一位都相反的数。\n### 四、 经典题型与技巧\n1. **寻找唯一出现奇数次的数**：利用 `a⊕a=0`，将所有数异或，出现偶数次的会两两抵消，结果就是那个出现奇数次的数。\n2. **寻找两个只出现一次的数**（其他出现两次）：\n    - 第一步：将所有数异或，得到 `x = a ⊕ b`（`a`, `b` 为所求）。\n    - 第二步：找到 `x` 的任意一个为 `1` 的二进制位。这一位意味着 `a` 和 `b` 在这一位上不同。\n    - 第三步：根据这一位将原数组分成两组，分别异或，得到的两个结果就是 `a` 和 `b`。\n3. **最大/最小异或对问题**：\n    - **暴力**：`O(n^2)` 对于大数据不行。\n    - **优化（`O(n*logC)`）**：使用**01-Trie（字典树）**。将数字按二进制从高位到低位插入Trie，查询时尽量“走相反位”可以得到最大异或值，“走相同位”可以得到最小异或值。这是必须掌握的高级数据结构。\n4. **异或相关的构造题**（如你刚才遇到的）：\n    - **核心目标**：控制前缀异或数组 `pre` 的值。\n    - **常用手段**：\n        - 让 `pre` 数组的值是 `0` 到 `n` 的一个排列，然后微调（例如交换两个值）来满足特定区间异或为0的条件。\n        - 利用性质：如果 `pre[l-1] = pre[r]`，则区间 `[l, r]` 异或为0。要保证其他区间不为0，就要保证其他任意 `pre[i]` 与 `pre[j]` 都不相等（除了我们特意制造的那一对相等）。\n        - 注意题目对 `a[i]` 取值范围的限制（如 `1 <= a[i] <= 1e9`），这要求 `pre[i] ⊕ pre[i-1]` 的结果必须在这个范围内。通常用连续整数构造 `pre` 可以满足。\n\n### 五、 做题时的注意事项（避坑指南）\n\n1. **注意数据范围和溢出**：你刚才遇到的问题就是典型。当使用2的幂构造时，`2^30 ≈ 1e9`，所以区间长度不能超过30。必须时刻检查构造值是否在允许范围内。\n2. **小心 `0`**：异或中 `0` 是单位元，非常特殊。在构造时，如果允许元素为 `0`，可能会意外产生多个异或为0的子数组（例如单个元素为0）。题目常要求**正整数**来避免这种情况。\n3. **前缀异或的初始化**：务必定义 `pre[0] = 0`，这样才能正确表示从 `a[1]` 开始的子数组。\n4. **调试方法**：对于小数据，可以暴力计算所有子数组的异或和来验证你的构造是否正确。\n5. **思维转化**：遇到“所有子数组异或和不为0”这类强条件，要立刻想到它等价于“前缀异或数组 `pre` 中所有元素两两不同（且 `pre[0]=0` 也不与其他重复）”。这大大简化了问题。\n### 六、 推荐的巩固练习方向\n\n1. **基础**：LeetCode 136（只出现一次的数字）、LeetCode 268（缺失数字）。\n2. **进阶**：LeetCode 260（只出现一次的数字 III）、LeetCode 421（数组中两个数的最大异或值）**（必做，练习01-Trie）**。\n3. **综合与构造**：Codeforces 上的许多构造题（难度 1500-1800），比如你刚才做的这道题的原型。多观察题解中是如何利用前缀异或性质进行构造的。\n\n总结一下，异或问题的核心思路是：**利用前缀异或转化区间问题，利用归零律和结合律进行抵消与配对，利用位独立性进行按位处理或使用Trie**。多练习，你会对这种“魔力”运算越来越有感觉。\n\n因为异或可以逆运算，所以此处直接先算1-n的异或和再和现在的异或和异或一下就行了。\n这样就找到了那个没有出现过的数字。\n找出现奇数次的数字时，可以直接异或，因为只有一个数字满足这个要求，那么最后剩下的那个就是无法完成匹配的数字，就是答案了。\n找两个只出现一次的数字时，也是先异或得到$x=x_1\\oplus x_2$，然后看不一样的那一位来分开数组。\n解释：就是看这一位是否是1，然后就和只出现一次的数那题一样了。出现两次的数，分组一定在一起，那么就相互异或抵消了。","tags":["算法"]},{"title":"程C笔记","url":"/ZestfulYK-blog/2025/12/07/程C笔记/","content":"## 1. 头文件和命名空间\nC++ 中的 string 类定义在头文件 string 中，通常使用 std 命名空间。\n\n```c++\ns3=strcat(s1,s2);//加在后面\nint x=strcmp(s1,s2)//返回三种情况,见下面\ncout<<strlen(s1)<<endl;//输出的是长度，等同于s1.length()\nstrcpy(s1+x1,s2+x2);//把前面的对应部分添加到前面去，完全覆盖之前的内容\nmemcpy(a+x1,b+x2,sizeof(int)*8);//也是把后面的放到前面，只不过需要规定放入的内容\nsizeof(s1);//考虑后面的'\\0'，比strlen大1.\n```\n$$ x=strcmp(s1,s2)= \n\\begin{cases}\n -1  \\ \\ \\ \\ \\ s1 \\leq s2\\\\\n0\\ \\ \\ \\ s1=s2\\\\\n1\\ \\ \\ \\ s1 \\geq s2\n\\end{cases}\n$$\nmemcpy例子：\n```C++\nint a[8]={1,2,3,4,5,6,7,8};\nint b[10]={10,9,8,7,6,5,4,3,2,1};\nmemcpy(b,a,sizeof(int)*8);\nfor(int i=0;i<10;i++)\n    cout<<b[i];\n```\n输出：\n```C++\n1234567821\n```\n\n## 2.函数\n```C++\nint maxGap(int* p, int n)//传入p[0]的地址，能改变在主函数里的值\nstatic int t;//静态局部变量，下次还是调用上次的值\n//例如：\nint cnm(int p,int q){\n\tstatic int t=0;\n\tt+=p+q;\n\treturn t;\n}\nsigned main(){\n\tcout<<cnm(1,2)<<cnm(2,3)<<endl;\n}\n```\n\n- 局部变量，全局变量，如果多个声明，那么优先使用内部的数据\n```C++\nint a=5;\nint main(){\n\tint a=10,b=20;\n\tfor(int i=1;i<=3;i++){\n\t\tcout<<a++<<\" \"<<b<<endl;\n\t\t{\n\t\t\tstatic a=0;\n\t\t\tfor(int j=1;j<=5;j++){\n\t\t\t\ta+=j;\n\t\t\t}\n\t\t\tb+=a;\n\t\t}\n\t}\n}\n```\n\n- 要根据函数返回的类型来决定函数的类型\n- 要根据函数内的使用变量来决定函数使用的参数值\n```C++\n//例如：\nchar* fun(int c){//程C一般不用string，自己写都行\n\treturn \"yes\";\n}\nint* fun1(int c){\n\tint a[]={1,2,3};\n\treturn a;\n}\n```\n\n","tags":["数学"]},{"title":"计算机18讲题解","url":"/ZestfulYK-blog/2025/12/07/计算机18讲题解/","content":"\n#### 小技巧\n- 在网页前面加上read有奇效\n例如：\n```html\nraed:https://www.reach-top.cn.com\n```\n这个是阅读器模式，开启以后就能获取里面原先不让复制的内容了\n## A题\n\n-  题目描述\n每个整数都应输出一个各位数字和，并独占一行。\n- 解题思路\n拿之前上课的程序自然是能解决的，直接一个循环算到底\n每一位的值是n%10，要取得下一位就n/=10再算就彳亍了\n但是注意到这节课的标题是函数，那么我们就编写一个递归程序来计算每一位的和\n边界条件：n<=10\n递推式子：n %10+solve(n/10)\n- 参考代码\n```C++\nll solve(ll n){\n  if(n<10) return n;\n  return n%10+solve(n/10);\n}\nsigned main(){\n  ll T;\n  while(cin>>T)\n\tcout<<solve(T)<<endl;\n  return 0;\n}//此处#define ll long long\n```\n## B题\n\n- 题目描述\n给定若干个正整数，请你从这些整数中找到最小值和第二小的值，计算一下第二小的数值减去最小值的结果是不是素数，如果是则输出Yes，否则输出No\"o。 \n- 解题思路\n直接写一个循环计算最小值和次小值，然后判断差是不是素数就行了\n计算最小值和次小值的思路，如果输入值x比最小值小，那么把次小值改成原先的最小值，再把最小值修改为输入值x，如果只是比次小值小，那么把次小值改成输入值x\n- 参考代码\n```C++\nvoid isprime(int n){\n  if(n==1){\n    cout<<\"No\\\"o\"<<endl;\n    return;\n  }\n  for(int i=2;i<=sqrt(n);i++){\n    if(n%i==0){\n      cout<<\"No\\\"o\"<<endl;\n      return;\n    }\n  }\n  cout<<\"Yes\"<<endl;\n}\nsigned main()\n  ll minn1=1e18,minn2=1e18,x;\n  while(cin>>x){\n    if(x<minn1){\n      minn2=minn1;\n      minn1=x;\n    }\n    else if(x<minn2)\n      minn2=x;\n  }\n  isprime(minn2-minn1);\n  return 0;\n}\n```\n\n\n## C题\n\n- 题目描述\n哥德巴赫猜想大家都知道一点吧。我们现在不是想证明这个结论，而是想在程序语言内部能够表示的数集中，任意取出一个偶数，来寻找两个素数，使得其和等于该偶数。  做好了这件实事，就能说明这个猜想是成立的。由于可以有不同的素数对来表示同一个偶数，所以专门要求所寻找的素数对是两个值最相近的。\n- 解题思路\n直接暴力求解从中间开始计算，设两个数分别是x，y，然后x--，y++，判断是否是合法的，如果合法那么输出，这样得到的第一组解必然是最小的一组解。\n判断是否是素数的代码可以用上一题的代码。\n- 参考代码\n```C++\nbool isprime(ll n){\n  if(n==1) return false;\n  for(int i=2;i<=sqrt(n);i++){\n    if(n%i==0)\n      return false;\n  }\n  return true;\n}\nsigned main(){\n  ll x;\n  while(cin>>x&&x){\n    ll a1=x/2,a2=x/2;\n    while(1){\n      if(isprime(a1)&&isprime(a2)){\n        cout<<a1<<' '<<a2<<endl;\n        break;\n      }\n      a1--; a2++;\n    }\n  }\n  return 0;\n}\n```\n\n## D题\n\n- 题目描述\n求给定n个正整数的最大公约数\n- 解题思路\n计算每个数和现在得到的最大公约数的最大公约数\n首先先默认最大公约数为第一个正数，然后计算即可。\n计算最大公约数其实有两种方式，要是你用万能头的话，可以使用自带函数直接计算。\n这里采用的是标准的辗转相除法。\n- 参考代码\n```C++\nll gcd(ll n,ll m){\n  if(n%m==0) return m;\n  else return gcd(m,n%m);\n}\nsigned main(){\n  ll n,x; cin>>n;\n  ll m=n,maxgcd;\n  while(cin>>x&&n){\n    if(x<=0) continue;\n    if(n==m) maxgcd=x;\n    n--;\n    maxgcd=gcd(maxgcd,x);\n    //maxgcd=__gcd(x,maxgcd);这个是自带的函数，也是可以的\n  }\n  cout<<maxgcd<<endl;\n}\n```\n\n## E题\n- 题目描述\n找比x大的第一个回文数\n- 解题思路\n每次加1，直到找到回文数为止。\n判断回文数的话，直接先一位一位取出来，然后计算，一个正向遍历，一个反向遍历，结果一样就是回文。\n- 参考代码\n```C++\nbool hws(ll x){\n  ll a[2000],id=1;\n  while(x){\n    a[id++]=x%10;\n    x/=10;\n  }\n  for(int i=1;i<id;i++)\n    if(a[i]!=a[id-i])\n      return false;\n  return true;\n}\nsigned main(){\n  ll x;\n  while(cin>>x){\n    x++;\n    while(!hws(x++));\n    cout<<x-1<<endl;\n  }\n}\n```\n这里因为要求要比x大，所以先x++，最后输出x-1的原因是循环里写的是x++最后会多1。\n\n## F题\n- 题目描述\n如果一个数从左到右和从右到左读都一样，那么这个数就叫做“回文数”。如果一个数的十进制和二进制表示都是回文数，则把这个数叫做“双重回文数”。例如，十进制33是回文数，将其转化为二进制表示100001也是回文数，所以33是双重回文数。编写程序，查找1~1000的所有双重回文数。\n- 解题思路\n和上一题一样，只不过要多出力一个二进制的而已。\n- 参考代码\n```C++\nbool hws(ll x){\n  ll a[2000],id=1;\n  ll y=x;\n  while(x){\n    a[id++]=x%10;\n    x/=10;\n  }\n  for(int i=1;i<id;i++)\n    if(a[i]!=a[id-i])\n      return false;\n  \n  id=1;\n  while(y){\n    a[id++]=y%2;\n    y/=2;\n  }\n  for(int i=1;i<id;i++)\n    if(a[i]!=a[id-i])\n      return false;\n  return true;\n}\nsigned main(){\n  for(int i=1;i<=1000;i++)\n    if(hws(i)) cout<<i<<\"为双重回文数\"<<endl;\n}\n```\n\n\n\n\n\n\n","tags":["算法"]},{"title":"模运算性质总结","url":"/ZestfulYK-blog/2025/11/25/mod/","content":"# 模运算（Mod）性质总结\n\n## 定义\n\n对于任意实数 $( x, y )$，有：\n\n$$x \\mod y = x - y \\left\\lfloor \\frac{x}{y} \\right\\rfloor, \\quad y \\neq 0$$\n\n模运算（在一些场合使用符号 % 表示）是一个二元运算。$( x \\mod y )$ 的值范围如下：\n\n- 当 $( y > 0 )$ 时：$( 0 \\leq x \\mod y < y )$\n- 当 $( y < 0 )$ 时：$( 0 \\geq x \\mod y > y )$\n- 当 $( y = 0 )$ 时：为避免除以零，定义 $( x \\mod 0 = x )$\n\n## 基本运算规则\n\n模运算与基本四则运算类似（除法除外）：\n\n1. **加法规则**：$((a + b) \\mod p = (a \\mod p + b \\mod p) \\mod p)$\n2. **减法规则**：$((a - b) \\mod p = (a \\mod p - b \\mod p) \\mod p)$\n3. **乘法规则**：$((a \\times b) \\mod p = (a \\mod p \\times b \\mod p) \\mod p)$\n4. **幂运算规则**：$(a^b \\mod p = ((a \\mod p)^b) \\mod p)$\n5. **求和规则**：由第1个公式可推导出 $(\\left(\\sum_{i=1}^{n} x_i\\right) \\mod p = \\left(\\sum_{i=1}^{n} (x_i \\mod p)\\right) \\mod p)$\n\n## 运算律\n\n### A. 结合律\n\n$$((a + b) \\mod p + c) \\mod p = (a + (b + c) \\mod p) \\mod p$$\n\n$$((a \\times b) \\mod p \\times c) \\mod p = (a \\times (b \\times c) \\mod p) \\mod p$$\n\n### B. 交换律\n\n$$(a + b) \\mod p = (b + a) \\mod p$$\n\n$$(a \\times b) \\mod p = (b \\times a) \\mod p$$\n\n### C. 分配律\n\n$$(a + b) \\mod p = (a \\mod p + b \\mod p) \\mod p$$\n\n$$((a + b) \\mod p \\times c) \\mod p = ((a \\times c) \\mod p + (b \\times c) \\mod p) \\mod p$$\n\n## 补充性质\n\n### 同余性质\n\n- **反身性**：$(a \\equiv a \\pmod{m})$\n- **对称性**：如果 $(a \\equiv b \\pmod{m})$，则 $(b \\equiv a \\pmod{m})$\n- **传递性**：如果 $(a \\equiv b \\pmod{m})$ 且 $(b \\equiv c \\pmod{m})$，则 $(a \\equiv c \\pmod{m})$\n\n### 模运算与除法\n\n模运算与除法不直接兼容，但有以下性质：\n\n- 如果 $(ac \\equiv bc \\pmod{m})$ 且 $(\\gcd(c, m) = 1)$，则 $(a \\equiv b \\pmod{m})$\n    \n- **模逆元**：如果 $(\\gcd(a, m) = 1)$，则存在整数 $(b)$ 使得 $(ab \\equiv 1 \\pmod{m})$，称 $(b)$ 为 $(a)$ 模 $(m)$ 的逆元\n    \n- **核心性质**：在模运算里除以一个数等于乘以这个数的逆元，即：$$c/a≡c×a^{−1} (modm)$$其中 $a^{-1}$ 是 $a$ 在模 $m$ 下的逆元。\n\n**重要前提**：模逆元存在的**充分必要条件**是 $\\gcd(a, m) = 1$（即 $a$ 与 $m$ 互质）。如果 $a$ 与 $m$ 不互质，则 $a$ 在模 $m$ 下没有逆元，除法操作无法进行。\n\n---\n#### 计算模逆元的方法\n\n常用的计算模逆元的方法是**扩展欧几里得算法**，它不仅能求最大公约数，还能找到满足贝祖等式的系数。\n\n示例代码;\n```C++\n#include <iostream>\nusing namespace std;\n\n// 扩展欧几里得算法求逆元\nlong long mod_inverse(long long a, long long m) {\n    long long m0 = m;\n    long long y = 0, x = 1;\n    \n    if (m == 1) return 0;\n    \n    while (a > 1) {\n        long long q = a / m;\n        long long t = m;\n        \n        m = a % m;\n        a = t;\n        t = y;\n        \n        y = x - q * y;\n        x = t;\n    }\n    \n    if (x < 0) x += m0;\n    \n    return (a == 1) ? x : -1; // 如果逆元不存在返回 -1\n}\n\n// 使用示例\nint main() {\n    long long a = 3, m = 7;\n    long long inv = mod_inverse(a, m);\n    if (inv != -1) {\n        cout << a << \" 在模 \" << m << \" 下的逆元是: \" << inv << endl;\n    } else {\n        cout << a << \" 在模 \" << m << \" 下没有逆元\" << endl;\n    }\n    return 0;\n}\n```\n\n#### 应用示例\n\n计算 $6 / 3 \\pmod{7}$：\n\n1. 先求 $3^{-1} \\pmod{7}$：$3 \\times 5 = 15 \\equiv 1 \\pmod{7}$，所以逆元为 5\n    \n2. $6 / 3 \\equiv 6 \\times 5 = 30 \\equiv 2 \\pmod{7}$\n    \n3. 验证：$2 \\times 3 = 6 \\equiv 6 \\pmod{7}$ ✓\n    \n\n这个性质在密码学、组合数学和算法竞赛中都有广泛应用。\n### 模运算的周期性质\n\n- 对于任意整数 $(k)$，有 $(a \\mod m = (a + km) \\mod m)$\n- 模运算的结果具有周期性，周期为模数 $(m)$\n","tags":["算法"]},{"title":"算法挑战赛题解","url":"/ZestfulYK-blog/2025/11/20/2/","content":"\n### 算法挑战赛第二期题解\n\n## 题目\n\n- 二进制小数的乘积~HC哥哥说这个很困！难！\n\n- Description\n\n> HC哥哥今天又突发奇想，它依然定义一个数字为二进制小数，如果它是一个正整数，并且其十进制表示中的所有数字都是0或1。例如，110 是一个二进制小数，而 102 和 787 不是。\n\n> 现在HC哥哥给定你一个数 n，你被要求判断是否可能将 n 表示为一些（不一定是不同的）二进制小数的乘积。\n\n\n- Input\n\n> 第一行包含一个整数 t（1≤t≤5⋅10^4）— 测试用例的数量。\n\n> 每个测试用例的唯一一行包含一个整数 n（1≤n≤10^5）。\n\n\n- Output\n\n> 对于每个测试用例，如果 n 可以表示为一些二进制小数的乘积，则输出 \"YES\"（不带引号），否则输出 \"NO\"（不带引号）。\n\n- 题目解释 （~~翻译成人话~~）\n\n计算把01串强制转换为整数，再相乘得到的数就是合法的数字，其余都是不合法的。\n那么直接**打表**就行了，总共1e5个数，打表还是很容易实现的\n\n接下来我们来学习一下该怎么打表\n\n## 打表\n\n- 定义 : 计算出所有情况，然后直接判断。\n\n比如问你100以内的数是否是质数，你肯定能直接回答，因为你已经把100以内的质数全部背下来了。这其实就是打表的一种体现，你提前计算前100内的数是否是质数，然后直接调用答案。\n\n但是我们的计算机实际上并不知道一个问题的所有解，那么你自己提前算好告诉它不就彳亍了吗。\n\n这时我们需要两个重要程序：**打表程序**和**判断程序**。\n\n### 打表程序\n\n- 用于计算所有情况的答案，不用关心时间复杂度，反正是提前计算\n\n比如计算素数集，你直接暴力就好了，不会欧拉筛又有什么关系呢？\n\n### 判断程序\n\n- 用于直接获得答案的程序，时间复杂度O(n),n为数据规模，每次查询的时间复杂度为O(1)。\n\n**接下来就该思考怎么写一个无脑的程序来计算这些情况了**\n\n## 做法\n\n- 首先先写一个无脑程序生成所有01组合的数\n```C++\nvector<ll> ans;\nint main(){\n    for(int i=1;i<=100000;i++){\n        ll x=i,cnt=0,w=0;\n        while(x){\n            if(x%10<2) cnt++;\n            w++;\n            x/=10;\n        }\n        if(cnt==w) ans.push_back(i);\n    }\n    for(auto &i:ans)\n        cout<<i<<\",\";\n}\n```\n\n> 此处是对每一位进行判断，如果01的个数和位数一样，那么就是一个合法的数字\n\n- 得到如下结果：\n```C++\n\n1,10,11,100,101,110,111,1000,1001,1010,\n1011,1100,1101,1110,1111,10000,10001,10010,\n10011,10100,10101,10110,10111,11000,11001,\n11010,11011,11100,11101,11110,11111,100000\n```\n\n- 把以上结果复制进下一段生成代码，然后再计算所有合法的数字\n```C++\nll number[1010]={0,1,10,11,100,101,110,111,1000,1001,\n    1010,1011,1100,1101,1110,1111,10000,10001\n    ,10010,10011,10100,10101,10110,10111,11000\n    ,11001,11010,11011,11100,11101,11110,11111,100000};\nset<ll> s;\nll dfs(ll n){\n    s.insert(n);\n    for(int i=2;i<=32;i++){\n        if(n*number[i]<=100000)\n           dfs(n*number[i]);\n    }\n    return 0;\n}\nsigned main(){\n    dfs(1);\n    ll cnt=0;\n    for(auto &i:s){\n        cout<<i<<\",\";\n        cnt++;\n    }\n    cout<<endl<<cnt<<endl;\n    return 0;\n\n}\n```\n\n> 此处使用了dfs(Deep First Search)，文末会有详细介绍\n\n- 得到如下结果：\n```C++\n1,10,11,100,101,110,111,121,1000\n,1001,1010,1011,1100,1101,1110,\n1111,1210,1221,1331,10000,10001,\n10010,10011,10100,10101,10110,10111,\n10201,11000,11001,11010,11011,11100,\n11101,11110,11111,11121,11211,12100,\n12111,12210,12221,12321,13310,13431,\n14641,100000\n```\n\n- 最后再是无脑的判断程序：\n```C++\nvector<string> ans;\nll a[1010]={0,1,10,11,100,101,110,111,121,1000,1001,1010,1011,1100,1101,\n    1110,1111,1210,1221,1331,10000,10001,10010,10011,10100,10101,10110,\n    10111,10201,11000,11001,11010,11011,11100,11101,11110,11111,11121,\n    11211,12100,12111,12210,12221,12321,13310,13431,14641,100000};\nvoid solve(){\n    ll x; cin>>x;\n    for(int i=1;i<=47;i++){\n        if(a[i]==x){\n            ans.push_back(\"YES\");\n            return;\n        }\n    }\n    ans.push_back(\"NO\");\n}\nint main(){\n    ll T; cin>>T;\n    while(T--) solve();\n    for(auto &i:ans)\n        cout<<i<<endl;\n}\n```\n\n不是我说，这种做法在打表题目是真轮椅吧，时间复杂度完全没影响，计算出来总共就47个数字，简单版甚至20个都没到，非常适合不会搜索的蒻蒟(比如我)学习和理解。\n\n\n### 下面是对dfs(Deep First Search)算法的详细介绍：\n\n- 什么是dfs？\ndfs是深度优先搜索的英文缩写，以深度为优先来进行计算\n\n比如，要计算走n级楼梯（每次一到两级台阶）有几种走法，就可以使用dfs，假设第一次先走一步，依次遍历，如果能刚好走到n则方法数加1，如果超过了n则返回到上一步，回头找下一个方法。\n\n- 在本题的应用\n\n那么在这题，我们已经提前计算了所有合法的数字，我们每次乘上可能的数字，看看是否依旧合法，之后在超过1e5时返回，相当于楼梯数为1e5，每次可以走number[1....n]步，但是每一个小于n的位置都合法，并存储答案。\n\n如果想进一步了解dfs，可以访问OIwiki进行学习！\n\n那么本期的题解就到此结束了，感谢阅读！如果想交流算法题，也可以添加我的qq哦(717056060)\n\n#                        关注ZestfulYK，谢谢喵！"},{"title":"算法挑战赛题解（11.2）","url":"/ZestfulYK-blog/2025/11/03/1/","content":"\n# 算法挑战赛题解（11.2）\n\n## 简单版本：\n\n### 题目大意：\n\n给定n个区间，判断这些区间能划分出几种不同的区域\n\n- [性质不同的数字](http://www.zjutacm.cn/problem/3120)\n\n### 题目分析：\n\n实际上是在讨论每个点被哪几个区包含，在样例中，数据是这样的，我们来分析一下这两个样例\n\n```yaml\nSample Input 1 \n\n1\n1 6\n\nSample Output 1\n\n2\n\nSample Input 2\n\n4\n0 12\n4 13\n6 13\n12 13\n\nSample Output 2\n\n6\n\n```\n\n### 样例分析：\n\n```yaml\n样例1: 0 1 1 1 1 1 1 0 0 … …  所以是两种区间\n样例2: 1   2  3   4   5   6   7  8    9   10  11  12  13 … …\n       1   1  1   1   1   1   1  1   1    1   1   1\n                  2   2   2   2  2   2    2   2   2   2\n                          3   3  3   3    3   3   3   3\n                                                  4   4\n       |< ------ >|< ---- >|< ----------------- >|<->|<->|<--\n\n```\n\n所以是6种区间\n这样,我们就弄明白了题目在讲什么,接下来就可以思考怎么实现了\n\n### 题目思路：\n\n实际上有些人会以为我们需要统计的是这个点有几个区间经过，但是这是错误的，在样例二就能发现这一点。\n（这也是我第一次的想法，测试样例二时发现的T_T）\n\n我们需要思考怎么表示这一个点有哪些区间经过，而且每一个区间是互不相同的。这里我们考虑类似**状态压缩**的思想。\n\n什么是状态压缩呢？简而言之就是用一个数来代替这个状态。\n比如说，我们用1表示未进行，2表示正在进行，3表示完成，\n那么一个含有4个任务的任务表可以是这样的：\n\n                1321\n\n（1，4任务未进行，2任务完成，3正在进行）\n\n我们使用了一个4位数表示了这一状态，这样就实现了状态压缩，我们没有用数组存储状态，而是一个数，这样我们在判断两个状态是否相同时就可以直接判断数字是否相同了，节约了时间和判断的复杂度。\n\n那么怎么把这个思想用在这一题呢？我们考虑给每个区间一个标号k，每个区间内的点加上2^k，这样就保证了每一个状态不会重复。\n但是这么写居然WA了！这是因为数据范围n是[0,300]也就是会有2^300，远大于long long的最大范围(2^64-1)这显然是不行的。\n\n实际上这个算法已经十分接近答案了,但我们还需要改进这个算法。\n接着我们想到一个类似的方法，**哈希表(hash)**。\n\n其实哈希表和刚才的思路差不多，不过加入了一些更高级的算法来防止数据溢出。\n\n### 那么什么是hash呢？\n\n实际上也是创建一种对应关系，使得在查询时能快速访问这种情况对应的值。就像上面的例子一样，我们通过我们规定的方式把任务状态和整数一一对应。\n\n### 怎么创建hash表呢？\n\n首先，找到一个质数作为进制数P，通常取131或者13331，模数mod通常取1e9+7或1e9+9，对应关系就是对应的P进制数%mod\n例如这个点上经过了134这三个集合，那么我们就把134转化为131进制，即1 * 131^2+3 * 131+4，在实际操作时，就是每一个集合的下标k作为对应的位数，则每一个点的表示可以是这样的：\n\n![公式](/images/公式.png)\n\n这样我们就计算出了每一个点的唯一标识，含有相同标识的才能算是同一个点。（这里选择质数是为了防止哈希碰撞，即不同状态的得到了相同的标记；选择mod是防止溢出）\n\n最后只要统计一下标识的个数就行了（可以用set实现）\n代码实现：对于简单版本，暴力完全够用了。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define endl '\\n'\nconst ll P=131,mod=1e9+7;\nint main(){\n    ll n,z=1,a[1010]; cin>>n;\n    for(int i=0;i<=1000;i++) a[i]=0;\n    while(n--){\n        ll l,r; cin>>l>>r;\n        for(int i=l;i<=r;i++){\n            a[i]=(a[i]+z)%mod;\n        }\n        z=(z*P)%mod;\n    }\n    set<ll> q;\n    for(int i=0;i<=1000;i++){\n        q.insert(a[i]);\n    }\n    cout<<q.size()<<endl;\n}\n```\n\n\n所以这样我们就解决了简单版本。\n\n## 复杂版本：\n\n那么对于数据量大的**复杂版本**呢？\n\n这里我们依然采用hash，但是由于数据量大，为了防止冲突，我们给每一个区间都分配一个随机hash值，在计算时只考虑起点和终点，在进入起点时加入标记，离开时移除标记。这时我们就想到了具有可逆性质的异或，我们只要给对应的起终点打上相同标记就行了，最后还是用set统计产生的不同标记数\n\n### 参考代码：\n\n```C++\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ULL unsigned long long\n#define endl '\\n'\nint main(){\n    ll n; cin>>n;\n    vector<pair<ll,int>> box;\n    for (int i=0;i<n;i++){\n        ll l,r; cin>>l>>r;\n        box.push_back({l,i});\n        box.push_back({r+1,i});\n    }\n    sort(box.begin(),box.end());\n    vector<unsigned long long> h(n);\n    mt19937_64 rng(time(0));\n    for(int i=0;i<n;i++){\n        h[i]=rng();\n    }\n    set<ULL> s; s.insert(0);\n    ULL cur=0;ll last=-2e9;\n    for(auto& i:box){\n        ll pos=i.first,idx=i.second;\n        if(pos>last&&last!=-2e9) s.insert(cur);\n        cur^=h[idx];\n        last=pos;\n    }\n    s.insert(cur);\n    cout<<s.size()<<endl;\n}\n```\n\n```yaml\n                     感谢观看！关注ZestfulYK喵，谢谢喵！","tags":["算法"]},{"title":"压行技巧","url":"/ZestfulYK-blog/2025/10/24/压行技巧/","content":"\n#   如何给你的代码压行？\n\n如果不会压行，你的代码看起来会是这样的：\n\n```C++\nint ml(vector<int> s, int n)\n{\n    int m = s[0];\n    for (int i = 0; i <= n; i++)\n    {\n        if (s[i] > m)\n            m = s[i];\n    }\n    return m;\n}\n```\n\n整整用了9行！\n实际上其实根本不需用那么多行：\n```C++\nint ml(vector<int> s,int n){\n    int m=s[0];\n    for(int i=0;i<=n;i++){\n        if(s[i]>m)m=s[i];\n    }\n    return m;\n}\n```\n\n当然也可以更短：\n```C++\nint ml(vector<int> s,int n){\n    int m=s[0];\n    for(int i=0;i<=n;i++) if(s[i]>m) m=s[i];\n    return m;\n}\n```\n那么问题来了，怎么在不影响代码运行的情况下合理的压行呢？\n\n# 判断类循环类的压行技巧\n\n## 判断类\n\n如果判断语句仅一行，可以考虑压行：\n\n```C++\nif(a==1) sum++;\nelse sum--;\n\n//或者这样\n\nif(a==1)\n    sum++;//可以通过缩进来方便区分\n```\n\n两句的话，压行可以考虑用大括号包起来压行~~前提是你觉得看着没影响~~\n\n```C++\nif(a==1) {sum++;a=2;}\n```\n\n注意在大括号里的每一句都是要加上封号的，因为这一段代码实际上等价于：\n\n```C++\nif(a==1){\n    sum++;\n    a=2;\n}\n```\n\n## 循环类压行\n\n也和判断的一样，可以这么压行：\n\n```C++\nfor(int i=1;i<=n;i++) cout<<1<<endl;\n\n//或者这样：\n\nfor(int i=1;i<=n;i++)\n    cout<<1<<endl;\n```\n\n如果是输出的话，其实可以这么写：\n\n```C++\nfor(int i=1;i<=n;i++) cout<<i<<\" \"; cout<<endl;\n```\n\n因为```C++cout<<endl;```其实是在循环之外的，所以这么写是正确的\n\n# 头文件压行\n\n下面送给大家万能头文件：\n\n```C++\n#include<bits/stdc++.h>\n```\n\n# 其他技巧\n\n```C++\n#define ll long long\n#define rep(1,n) for(int i=1;i<=(n);i++)\nll n;\nint main(){\n    rep(1,n) cout<<\"*\"; cout<<endl;\n}\n```\n\n通过define来减少代码长度，增加可读性\n\n## 一些非常有用的C++自带函数\n\n```C++\nsort(a,a+n);//a为数组，n为a的大小\n__gcd(x,y);//x，y的最大公约数\nx=1<<n;//2的n次方\n```\n","tags":["算法"]},{"title":"过关考模拟考题解","url":"/ZestfulYK-blog/2025/10/23/过关考模拟考题解/","content":"# 过关考模拟考题解\n\n## A签到题\n\n- 分析:\n\n要是这也不会那学习委员真没招了\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    cout<<\"Help others voluntarily but never let them know they owe you a favor.\"<<endl;\n}\n```\n\n## B选择结构\n\n- 分析:\n\n按照要求逐个判断，然后取最小值就行了\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    double x,y,n,p,ans=200;\n    cin>>x>>y>>n>>p;\n    if(p>=x) ans=min(ans,p-y);\n    ans=min(ans,p/10*n);\n    printf(\"%.2lf\",ans);\n}\n```\n\n## C循环\n\n- 分析:\n\n分三种情况，<10的一定成立，两三四位数自己判断就行了\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,cnt=0; cin>>n;\n    for(int i=1;i<=n;i++){\n        if(i<10) cnt++;\n        else if(i<100){\n            if(i%10==i/10) cnt++;\n        }\n        else if(i<1000){\n            if(i%10==i/10%10&&i%10==i/100) cnt++;\n        }\n        else if(i%10==i/10%10&&i%10==i/100%10&&i%10==i/1000) cnt++;\n    }\n    cout<<cnt<<endl;\n}\n```\n- 打表的做法\n\n为什么没人想到这题能打表呢？总共也就28个数啊\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int a[30]={1,2,3,4,5,6,7,8,9,11,\n    22,33,44,55,66,77,88,99,111,\n    222,333,444,555,666,777,888,999,1111,2222},n;\n    cin>>n;\n    for(int i=0;i<=28;i++){\n        if(a[i]>n) {cout<<i<<endl;break;}\n    }\n}\n```\n\n## D菱形\n\n- 分析:\n\n逐行输出，先上半部分，再是后半部分\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n; cin>>n;\n    for(int i=0;i<=n/2;i++){\n        for(int j=1;j<=n/2-i;j++) cout<<\".\";\n        cout<<\"#\";\n        for(int j=1;j<=i*2-1;j++) cout<<\".\";\n        if(i!=0) cout<<\"#\";\n        for(int j=1;j<=n/2-i;j++) cout<<\".\";\n        cout<<endl;\n    }\n    for(int i=n/2-1;i>=0;i--){\n        for(int j=1;j<=n/2-i;j++) cout<<\".\";\n        cout<<\"#\";\n        for(int j=1;j<=i*2-1;j++) cout<<\".\";\n        if(i!=0) cout<<\"#\";\n        for(int j=1;j<=n/2-i;j++) cout<<\".\";\n        cout<<endl;\n    }\n}\n```\n\n\n## E金字塔\n\n- 分析:\n\n逐个循环相加就行了\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,ans=0; cin>>n;\n    for(int i=1;i<=n;i++) ans+=i*i;\n    cout<<ans<<endl;\n}\n```\n\n## F假期阅读\n\n- 分析:\n\n最多k*t页，但不能超过n\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,k,t; cin>>n>>k>>t;\n    cout<<min(n,k*t)<<endl;\n}\n```\n\n## G值日\n\n- 分析:\n\n求最小公倍数\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,m,i; cin>>n>>m;\n    for(i=n;i%m!=0;i+=n);\n    cout<<i<<endl;\n}\n```\n\n## H数三角形\n\n- 分析:\n\n循环i 1..n，j 1..i即可，每次判断一下是否存在整数解\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,cnt=0; cin>>n;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=i;j++){\n            if(i*j%2==0) cnt++;\n        }\n    }\n    cout<<cnt<<endl;\n}\n```\n\n## I幂数和\n\n- 分析:\n\n直接暴力枚举所有数，判断是否能拆就行了\n遍历每种可能的情况，计算和是否为这个数就行了\n至于代码中的<<是二进制内左移的意思，用来计算2的n次幂\n比如1<<1是10，变成了2，同理还有右移，自己学习\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int l,r,cnt=0; cin>>l>>r;\n    for(int i=l;i<=r;i++){\n        bool f=false;\n        for(int j=0;j<=20;j++){\n            for(int k=0;k<=20;k++){\n                if((1<<j)+(1<<k)==i) {cnt++;f=true;break;}\n            }\n            if(f) break;\n        }\n    }\n    cout<<cnt<<endl;\n}\n```\n\n\n## J质因数分解\n\n- 分析:\n\n第一空，先输出n，免得后面n的值变掉了\n第二空判断是否算一个因子，当然最后一个是需要特判的\n第三空，既然发现了因子，那么把n减小，变为n/i\n第四空，找的不对，i自增，寻找下一个位置\n第五空，输出最后一个质因数\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint main(){\n    ll n,i=2; cin>>n;\n    cout<<n<<\"=\";\n    for(i=2;i<=n;){\n        if(n%i==0&&n/i!=1){\n            cout<<i<<\"*\";\n            n/=i;\n        }\n        else{\n            i++;\n        }\n    }\n    cout<<i-1<<endl;\n}\n```","tags":["算法"]},{"title":"全排列函数的应用","url":"/ZestfulYK-blog/2025/10/22/全排列函数的应用/","content":"# 全排列函数\n\n## 什么是全排列？\n\n简单来说就是排列组合的所有情况，并按照字典顺序输出\n例如：123全排列的结果为\n\n```yaml\n123\n132\n213\n231\n312\n321\n```\n\n而实际上全排列需要在代码中用复杂的深度搜索来写\n这实在是太复杂了！！！\n于是我就发现了全排列函数这个东西^__^\n现在我们就来学习一下这个高级函数————next_permutation\n\n## 全排列函数\n\n```C++\n#include <iostream>  \n#include <algorithm>  \nusing namespace std;  \nint main()  \n{  \n    int num[3]={1,2,3};  \n    do  \n    {  \n        cout<<num[0]<<\" \"<<num[1]<<\" \"<<num[2]<<endl;\n    }while(next_permutation(num,num+3));  \n    return 0;  \n}\n```\n- 全排列函数详细定义\n对于next_permutation函数，其函数原型为：\n\n    #include <algorithm>\n\n    bool next_permutation(iterator start,iterator end)\n\n当当前序列不存在下一个排列时，函数返回false，否则返回true\n\n- 全排列函数的特性\n\nnext_permutation(num,num+n)函数是对数组num中的前n个元素进行全排列，同时并改变num数组的值。\n\n另外，需要强调的是，next_permutation()在使用前需要对欲排列数组按升序排序，否则只能找出该序列之后的全排列数。比如，如果数组num初始化为2,3,1，那么输出就变为了：\n```yaml\n231\n312\n321\n```\n\n# 全排列函数的应用\n\n[题目链接](https://atcoder.jp/contests/abc326/tasks/abc326_d?lang=en)\n\n题目要求我们按要求完成5*5数独，且只要填ABC，可以有空格子\n一种方法是遍历每一个格子，逐个填入，\n时间复杂度(4^25)，显然不行\n不过我的朋友使用了大量剪枝，最后还是过了\n%%%大佬 qinye_leaf\n\n[代码链接](https://atcoder.jp/contests/abc326/submissions/70334070)\n\n但是我们刚学了全排列函数，就不能使用一下吗？\n你别说，还真能使用！\n我们只要先填写每一行，然后就只用40^5就能计算完了\n因为可以加上一个判断，看看每一行是否符合标准(也算剪枝吧)\n\n```C++\n    vector<string> eachrow(int row) {\n        vector<string> result;\n        string h=string(n-3,'.')+\"ABC\";\n        do{ for(int i=0;i<n;i++){\n            if(h[i]!='.'){\n                if(h[i]==r[row]) result.push_back(h);\n                break;\n            }\n        }\n        }while(next_permutation(h.begin(),h.end()));\n        return result;\n    }\n```\n那么这样我们就能得到每一行的可能情况，每行40种\n之后就可以正常的DFS了\n\n[个人AC代码链接](https://atcoder.jp/contests/abc326/submissions/70340782)","tags":["算法"]},{"title":"广工月赛","url":"/ZestfulYK-blog/2025/10/20/广工月赛/","content":"# ZestfulYK的战绩\n![图片](/images/ggys.png)\n\n# 比赛难度\n中等，以基础题为主，拼尽全力战胜少量难题\n\n# 部分代码\n## F\n- 分析\n很不错的博弈题目，使我的大脑旋转，最后打表做出来了\n\n[题目链接](https://ac.nowcoder.com/acm/contest/119605/F)\n\n![代码](/images/image.png)\n\n代码:\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    if(n==0&&m==0) cout<<\"Bob\"<<endl;\n    else if(n==1&m==0) cout<<\"Alice\"<<endl;\n    else if(n==2&m==0) cout<<\"Bob\"<<endl;\n    else if(n==3&m==0) cout<<\"Bob\"<<endl;\n    else if(n==0&m==1) cout<<\"Alice\"<<endl;\n    else if(n==0&m==2) cout<<\"Bob\"<<endl;\n    else if(n==0&m==3) cout<<\"Alice\"<<endl;//\n    else if(n==1&m==1) cout<<\"Bob\"<<endl;\n    else if(n==1&m==2) cout<<\"Bob\"<<endl;\n    else if(n==1&m==3) cout<<\"Alice\"<<endl;//\n    else if(n==2&m==1) cout<<\"Bob\"<<endl;\n    else if(n==2&m==2) cout<<\"Bob\"<<endl;\n    else if(n==2&m==3) cout<<\"Alice\"<<endl;//\n    else if(n==3&m==1) cout<<\"Bob\"<<endl;\n    else if(n==3&m==2) cout<<\"Bob\"<<endl;\n    else if(n==3&m==3) cout<<\"Alice\"<<endl;\n}\n```\n\n## J\n- 分析\n这题目也不错，但其实看代码找规律就行了\n\n[题目链接](https://ac.nowcoder.com/acm/contest/119605/J)\n\n![代码](/images/J.png)\n\n代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint main(){\n    ll n; cin>>n;\n    ll s=sqrt(n);\n    if(s*s!=n) s++;\n    ll last=n%s;\n    for(int i=last;i>=1;i--) cout<<i<<\" \";\n    for(int j=1;j<=n/s;j++){\n        for(int i=last+j*s;i>last+(j-1)*s;i--) cout<<i<<\" \";\n    }\n}\n```","tags":["算法"]},{"title":"markdown使用教程","url":"/ZestfulYK-blog/2025/10/20/markdown使用教程/","content":"### 标题的使用\n```yaml\n# 一级标题\n## 二级标题\n### 三级标题\n```\n### 字体\n\n**粗体** *斜体* ~~删除线~~ `行内代码`\n\n### 小标题的使用\n\n- 无序列表项\n- 另一个项目\n\n1. 有序列表\n2. 第二项\n\n### 链接，图片\n\n```yaml\n[链接文字](https://example.com)\n![图片描述](https://example.com/image.jpg)\n```\n\n### 引用块\n\n```yaml\n> 这是一个引用块\n> 可以多行使用\n```\n> 这是一个引用块\n> 可以多行使用\n\n### 表格\n\n```yaml\n| 姓名 | 年龄 | 城市 |\n|------|------|------|\n| 张三 | 25   | 北京 |\n| 李四 | 30   | 上海 |\n```\n\n| 姓名 | 年龄 | 城市 |\n|------|------|------|\n| 张三 | 25   | 北京 |\n| 李四 | 30   | 上海 |","tags":["技术"]}]