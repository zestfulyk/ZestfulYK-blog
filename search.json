[{"title":"程C指针学习笔记","url":"/ZestfulYK-blog/2026/01/06/程C指针学习笔记/","content":"\n# 单纯的指针\n\n最简单的指针带`*`的：野指针(确信)\n\n```C++\nint *p; //一只快乐的野指针，未初始化的指针，指向随机地址(野指针)\n```\n\n这个表示定义了指针，不过注意，**前面的类型**是要自己设定的，不能乱写\n但是提到指针，就不得不提到&(取地址符)了\n## &的用法：\n\n&表示取地址符，比如这样：\n\n```C++\nint a=1;\ncout<<&a<<endl;//输出a的地址\n```\n\n这一句表示输出a变量对应的地址位置，详细见书上的解释，获取地址的开头方便输出\n\n然后指针所能存储的恰好是地址，所以可以这么写：\n```C++\nint *p=&a;\n```\n\n表示p指向a对应的地址\n## 指针的初始化\n\n可以把指针设定为NULL，这里表示p不指向任何一个地址\n要是没有初始化，p可能指向任何一个位置，可能导致代码错误，所以被称作野指针\n\n```C++\nint *p = NULL;  // 未初始化指针（野指针）\n*p = 10;        // 段错误\n\n// 解引用前应检查\nif(p != NULL) {\n    *p = 10;\n}\n```\n# 指针的多种含义\n\n在实际程序中，`*p`，可能有多种含义：\n\n- 表示p所指的变量，即`*p=a`\n- 表示p对指的变量的值，即a的值\n\n下面是例子：\n\n```C++\nint a=1;\nint *p=&a;\n*p=1;          //表示将p指向的变量(即a)赋值为1\ncout<<*p<<endl;//表示输出p指向的变量(即a)的值\n```\n\n这里两种情况怎么理解呢？\n首先加上`*`表示对指针解引用，即访问指针指向的内存位置\n\n- case 1：这里指把p所指的位置修改为1，所以表示p所指的变量\n- case 2：这里因为表示的是p所指的位置，所以我们在输出时就是从这个位置开始逐个输出，表示的就是所指对应变量对应的值了。\n\n更详细的解释：\n在C++里有两种值叫做**左值(Location Value)** 和 **右值(Read Value)**\n\n- 左值表示一个内存位置，可以被赋值\n- 右值表示一个数据值，只能被读取\n\n前者表示的是地址，被写入数据的那个变量，所以表示地址\n后者只是获取其内部数据，表示的就是对应的值了\n\n所以，当`*p`出现在赋值号左边时，它是左值，表示一个内存位置（即p指向的变量）；当`*p`出现在其他表达式中（如赋值号右边、函数参数等），它是右值，表示该位置存储的值\n\n这样基本用法就能理解了\n## 指针表示一维数组\n\n指针指向的是一个元素的位置，要是指向的是**一个数组的开头**呢？\n\n指针指向一个元素的位置，如果指向一个数组的开头，就可以通过指针来访问数组\n\n那么问题来了，我们该怎么获取中间元素的值呢？\n\n这里我们就需要知道一下**数组下标的工作原理**了：\n\n实际上程序会计算要往后访问几个位置，根据数据类型来决定往后跳几步。\n所以我们可以这么理解`a[3]`：\na开头位置加上3×步长，得到这个元素的地址开头，就能正常访问了，\n这个过程相当于是一种规则，表示我们要往后几步\n\n**对于指针也是如此**，首先我们已经保证了指针p所指向的变量类型和数组a的元素类型一致，所以我们知道了p的开头以后，我们只要往后加上对应的步长就能找到我们要访问的元素了\n\n那么C++中规定了，指针+1表示往后一个步长，`[n]`表示往后n个步长，所以我们从这里理解了，为什么数组的下表是从0开始的，以及怎么利用指针来访问数组\n\n诶那我们是不是发现了数组a怎么和p这么类似啊，都能通过`[n]`来访问元素\n确实，**实际上数组名在大多数情况下可以看作指向数组首元素的指针**，我们用a+1也能访问元素，a表示的是a数组的开头地址，所以要用p遍历a的时候，我们只要`p=a`就能完成初始化，因为p存储的不正是地址吗？\n\n所以我们在代码里一般可以这么写：\n\n```C++\nint a[10]={0,1,2,3,4,5,6,7,8,9};\nint *p=a;\ncout<<p<<endl;                   //a[0]的地址\ncout<<p[1]<<endl;                //a[1]的值\ncout<<p+2<<endl;                 //a[2]的地址\n\nfor(int i=0;i<10;i++){           //遍历a数组\n\tcout<<p+1<<\" \"<<p[i]<<endl;  //两者等价\n}\n```\n\n注意：数组名a在大多数情况下可以转换为指针，**但数组名不是指针**，它是整个数组的标识符。在sizeof(a)时，它返回整个数组的大小，而不是指针大小\n\n值得注意的是，因为我们这里只是规定了向后移动几步，没有规定范围，所以理论上可能超出数组规定的范围访问，但是这会导致段错误，因为程序理论上没有权限访问这个位置的值\n错误示例：\n\n```C++\n// 指针越界访问\nint arr[5];\nint *p = arr;\np[10] = 5;      //未定义行为\n```\n\n理解了指针和数组的关系，也就理解了指针的本质，我们接下来就可以理解指针运算了。\n# 指针运算\n\n要是直接加减常数，表示的是移动多少个位置，要是是两个指针相减，表示的是中间差了几个单位，当然，我们也可以进行大小比较，表示指针在一个数组中的前后位置关系\n\n```C++\n// 指针与整数的加减\nint arr[10];\nint *p = arr;\np = p + 3;      // 移动3个int位置\np = p - 2;      // 移动回去2个位置\n\n// 指针之间的减法（得到元素个数）\nint *p1 = &arr[2];\nint *p2 = &arr[5];\nprintf(\"%ld\\n\", p2 - p1);  // 3\n\n// 指针比较\nif(p1 < p2) {   // 同一数组内比较有意义\n    // ...\n}\n```\n# 二级指针\n\n```C++\nint **p;\nint *p1;\nint a=1;\np1=&a;\np=&p1;\ncout<<**p1<<endl;\n```\n\n表示指向存储指针位置的指针，分析时一层一层去掉就行了\n\n要是等级更高也是类似的理解，比如实际上可以创建一个三级的指针\n\n```C++\nint ***p;\nint **p1;\nint *p2;\nint a=1;\np2=&a;\np1=&p2;\np=&p1;\ncout<<***p<<endl;\n```\n# 指针与函数\n\n首先函数中可以直接传入指针变量，这里可以理解为直接把对应的开头地址传过来了\n\n比如我们写一个swap函数：\n\n```C++\nvoid swap(int *p1,int *p2){\n\tint temp;\n\ttemp=*p1;\n\t*p1=*p2;\n\t*p2=temp;\n}\nint main(){\n\tint a=1,b=2;\n\tint *p1=&a,*p2=&b;\n\tswap(&a,&b);\n\t//也可以写swap(p1,p2);\n\tcout<<a<<\" \"<<b<<endl;\n}\n```\n\n这里操作完后，主函数里a，b的值也会互换，因为我们**传入的是地址**，在函数内我们又**对这个地址对应的位置**进行了操作，那么就能修改这个位置的值了，然后注意在函数调用时要**传入的是地址**，因为要和函数所需参数(指针)相对应。\n\n注意，以下几种写法都是错误的：\n\n```C++\nvoid swap_w1(int *p1,int *p2){\n\tint *temp;\n\t*temp=*p1;          //错误，temp是野指针，未初始化，不能解引用\n\t*p1=*p2;\n\t*p2=*temp;\n}\nvoid swap_w2(int *p1,int *p2){\n\tint *temp;\n\ttemp=p1;           //错误，只交换了p1和p2对应的地址，但是函数结束这两个就被删除了\n\tp1=p2;             //只交换了p1和p2这两个指针变量本身（局部变量）\n\tp2=temp;           //没有交换它们指向的值\n}\nint main(){\n\tint a=1,b=2;\n\tint *p1=&a,*p2=&b;\n\tswap(*p1,*p2);     //错误：*p1表示的是对应的地址对应的值\n\tcout<<a<<\" \"<<b<<endl;\n}\n```\n\n最后这个为什么是错的？因为不是赋值语句，表示的是右值，是对应的值\n`*p1`表示的是a的值，即1，类型是`int`，而函数需要`int*`，类型不匹配\n\n那么中间的函数为什么是错误的？\n我们来详细分析一下：\n\n```txt\n函数开始时          函数结束时          回到主函数(删除了作为形参的p1,p2)\np1->a=1                p1->b=2          a=1\np2->b=2                p2->a=1          b=2\n```\n\n所以没有任何变化，这个函数既没有修改`p1`,`p2`对应的位置的值，也法修改a和b对应的地址位置，所以没有产生任何变化。\n\n传入数组也是类似的：\n\n```C++\nvoid f(int a[],int n){\n\t//指定a是指针即可，反正传入首个元素的地址就行了，遍历方法见上面\n}\n```\n\n然后因为数组传入都是传入首位置的，**所以在函数内对数组操作是会改变原数组的**\n\n我知道大家一直有一个问题，为什么要这么大费周折的学习指针呢？\n其实在这一块就给出了一个答案：**可以让函数有多个返回值**\n\n注意一下函数的返回值，不能返回指针形参的地址，因为正如前面所说，函数结束后，这个位置就被删除了\n\n```C++\nint* bad_func() {\n    int x = 10;  // 局部变量\n    return &x;   // 函数结束x被删除\n}\n```\n# 指针与二维数组\n\n遍历方法类似，因为二维数组一般是连续的，所以可以p+i一直加下去来遍历，不过我们这里要讲解一下一个新的概念——**行指针**\n\n行指针写法：\n\n```C++\nint (*p)[4];\n```\n\n根据之前的学习我们知道，这其实也是规定了一种遍历规则，`*p`指向的是一个长度为4的一维数组的开头位置，要是+1的话表示跳过4个长度，然后加上括号表示是p指向数组，如果写成`int *p[4]`,则表示一个长度为4的指针数组。\n\n那么我们就可以通过p来访问这个二维数组了，\n\n首先p表示的是对应哪一行，`*p`是这一个数组对应的开头，就变成一维数组的访问了\n例如：\n\n```C++\nint a[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}};\nint (*p)[4];\np=a;\ncout<<*(*(p+1)+1)<<endl;\n```\n\n和前面一位数组的理解类似**二维数组名a也可以看作指向第一行(整个一维数组)的指针**，指向的是第一行这个一维数组，这里的调用相当于进行了两次一维数组的查询操作，先确定行再确定列。\n\n在行上，我们有：\n\n```C++\nint a[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}};\nint (*p)[4];\np=a;\ncout<<p[0]<<endl;   // 第一行的首地址，即&a[0][0]\ncout<<p+1<<endl;    // 第二行的首地址，即&a[1][0]\n```\n\n再加上列，我们就有四种组合了，本质上是等价的\n\n```C++\ncout<<p[1][1]<<endl;\ncout<<(*(p+1))[1]<<endl;\ncout<<*(p[1]+1)<<endl;\ncout<<*(*(p+1)+1)<<endl;\n```\n## 行指针和函数\n\n因为在行指针里，每次+1跳过几个位置的规则是十分重要的，所以在把行指针传入函数时，两者的第二给参数，即规则，得完全一致，不然程序会报错\n\n```C++\nvoid f(int arr[][4]){\n\t//\n}\n```\n\n或者：\n\n```C++\nvoid f(int (*arr)[4]){\n\t//\n}\n```\n\n只有规则相同才能调用\n# 动态分配数组空间\n\n## 一维数组\n\n```C++\nint *p=new int[n];\ndelete[] p;\n```\n\n或者\n\n```C++\nint *p=(int*)malloc(sizeof(int)*n);\nfree(p);\n```\n\n相当于每个位置都给了一个int的空间\n注意：`malloc`返回`void*`，需要强制类型转换。\n\n例如，下面这段代码是错误的：\n\n```C++\nint *p = malloc(sizeof(int) * 100);\n```\n\n## 二维数组\n\n在C语言中，动态分配二维数组(不连续)\n\n```C++\nint **matrix = new int *[ROW];\nfor (int i = 0; i < ROW; ++i) {\n\tmatrix[i] = new int[COL];\n}\nfor (i = 0; i < m; i++) {\n\tdelete[] matrix[i];\n}\ndelete[] matrix;\n```\n\n或者\n\n```C++\nint **matrix = (int**) malloc ( ROW * sizeof( int* ));\nfor int(i = 0 ; i < COL ; ++i) {\n\tmatrix[i] = (int*) malloc ( COl * sizeof( int ));\n}\nfor (i = 0; i < m; i++) {\n\tfree(matrix[i]);\n}\nfree(matrix);\n```\n\n这里的二级指针存储的是(每一行开头的元素的地址)的地址\n为什么要这么麻烦呢？但是逐个分配的好处是方便删除，也可以实现各行长度不同（锯齿数组）\n在这种情况下，我们就不能+1来查询了（因为行之间不连续），但可以通过行指针数组来访问每一行。\n\n如果希望分配连续的二维数组，可以使用以下方法：\n\n```C++\nint (*p)[COL] = (int(*)[COL])malloc(ROW * COL * sizeof(int));\n// 使用...\nfree(p);\n```\n\n或者\n\n```C++\n// 方法一：一次分配所有内存（连续）\nint rows = 3, cols = 4;\nint *data = malloc(rows * cols * sizeof(int));\nint **matrix = malloc(rows * sizeof(int*));\n\nfor(int i = 0; i < rows; i++) {\n    matrix[i] = data + i * cols;\n}\n\n// 释放\nfree(matrix);\nfree(data);\n\n// 方法二：用行指针（更接近静态数组）\nint (*p)[cols] = malloc(rows * cols * sizeof(int));\n// 可以直接用 p[i][j] 访问\nfree(p);\n```\n\n这样分配的内存是连续的，可以用`p[i][j]`访问，且p是一个行指针,`p+1`会跳过一行(COL个int)\n\n# 指针与字符串\n\nC++语言中字符串常以字符数组表示，也可以用指针\n\n```C++\nchar str[] = \"Hello\";\nchar *p = str;\nprintf(\"%s\\n\", p); // 输出Hello\n```\n\n字符串常量可以用指针指向：\n\n```C++\nchar *p = \"Hello\"; // p指向字符串常量，注意字符串常量不可修改\n```\n\n# const与指针\n\n这里介绍基本的const用法，以及基本的const指针\n\nconst表示的是常量，表示后面的是不可修改的\n\n首先`const int *p1`表示`p1`的类型是`const int`，所以是指向常量的指针\n第二个`int *const p2`表示`p2`的类型是`const`，`p2` 的值是不变的，指向同一个位置，但是他所指向的地址的值却是可以改变的\n第三个表示指向不变，且指向的是常量\n\n```C++\n// 四种const指针\nconst int *p1;        // 指向常量的指针，值不能改\nint const *p2;        // 同上\nint * const p3;       // 常量指针，指向不能改\nconst int * const p4; // 指向常量的常量指针\n\n// 示例\nint a = 5, b = 10;\nconst int *p = &a;\n// *p = 6;  // ❌ 错误\np = &b;     // ✅ 正确\n\nint * const q = &a;\n*q = 6;     // ✅ 正确\n// q = &b;  // ❌ 错误\n```\n\n# 指针数组与行指针区分\n\n指针数组，每一个位置都是一个指针，指向一个位置\n在指针数组，+1表示移动到指针数组的下一个位置，比如`names+1`表示`name[1]`的首地址，再加上`*`表示一维数组，有相似之处，但是和行指针在访问规则上还是有区别的\n\n```C++\n// 指针数组：数组的每个元素都是指针\nchar *names[] = {\"Alice\", \"Bob\", \"Charlie\"};\n// names[0] 指向 \"Alice\"\n// names[1] 指向 \"Bob\"\n\n// 数组指针：指向整个数组的指针\nint arr[3][4];\nint (*p)[4] = arr;  // 指向含有4个int的数组\n```\n\n# 指针相关题目\n\n下面是程C课上提到的题目，我们来检测一下你有没有理解\n\n例1：\n\n```C++\nint a=10,b=20,c=30;\nvoid fun(int* x,int* y,int* z){\n  cout<<++*x<<','<<*y++<<\",\"<<*(z++)<<endl;\n}\nsigned main(){\n  for(int i=0;i<3;i++){\n    fun(&a,&b,&c);\n  }\n  cout<<a<<\",\"<<b<<\",\"<<c<<endl;\n}\n```\n\n这一题我们需要学习一下C++中的运算符的优先级，从高到低可以理解为：\n\n**后缀运算>前缀运算=单目运算>双目运算**\n\n双目运算的规则还是比较清晰的，这里就不解释了\n详细解释可以看这个网站\n[C++ 运算符优先级](https://cppreference.cn/w/cpp/language/operator_precedence)\n\n所以函数中的`*y++`表示的就是`*(y++)`，先将地址使用，再后移一格，相当于没有对原先位置产生变化，所以得到答案：\n\n```txt\n11,20,30\n12,20,30\n13,20,30\n13,20,30\n```\n\n例2：\n\n```C++\nvoid fun(int* x,int* y,int* z){\n  *z=*x+*y;\n}\nsigned main(){\n  int a[3][3]={1,1};\n  int *p1,*p2,*p3;\n  p1=a[0];\n  p2=a[0]+1;\n  p3=a[0]+2;\n  for(int i=2;i<=9;i++){\n    fun(p1++,p2++,p3++);\n  }\n  for(int i=0;i<3;++i){\n    for(int j=0;j<3;j++){\n      cout<<a[i][j]<<\" \";\n    }\n    cout<<endl;\n  }\n}\n```\n\n这道题的意图还是比较明确的，即利用二维数组空间的连续性，计算斐波那契数列\n注意主函数中的用法，取的是`a[0]`的地址，因为`p1`不是行指针，只能指向一个一位数组的开头，所以写成`p1=a[0]`\n\n答案：\n\n```txt\n1 1 2 \n3 5 8\n13 21 34\n```","tags":["算法"]},{"title":"C++几何计算(保姆级教程)","url":"/ZestfulYK-blog/2025/12/23/C++几何计算(保姆级教程)/","content":"# 版权说明\n\n此文章的所有代码均由qinye_leaf 勤叶大佬收集整理，感谢喵Orz Orz Orz\n\n# 初始化\n\n由于双精度和单精度存在精度问题，所以补能直接判断是否为0或者相等，那么怎么办呢？\n我们可以取绝对值，然后和一个非常小的数字比较\n\n代码示例：\n```C++\n// 浮点数精度阈值(根据题目要求调整，通常1e-8)\nconst double EPS = 1e-8;\n```\n\n# 符号函数\n\n判断正负号的函数，但是是浮点数数版本的\n\n```C++\n// 符号函数：判断浮点数正负\nint sgn(double x) {\n    if (fabs(x) < EPS) return 0;\n    return x > 0 ? 1 : -1;\n}\n```\n\n# 构造函数介绍\n\n解释一下**构造函数**的用法，这里可以直接赋初始值，方便初始化\n\n```C++\nPoint(double x_ = 0, double y_ = 0) : x(x_), y(y_) {}\n//那么我们可以这么来定义一个变量\nPoint p1(2.0,3.0);\nPoint p2;\n```\n\n如果不传参数，那么就是直接得到初始值0,0,要是有值的化就是直接赋值，这样就避免了先定义再赋值的痛点。\n# 点\n\n## 点的定义\n\n点的定义我们使用结构体struct和重载操作符定义点的操作，这样我们就能直接计算两个点构成的向量\n这里面最重要的是加减，但是既然定义了那么就完整定义\n\n```C++\n// 点/向量结构体（二维）\nstruct Point {\n    double x, y;\n    // 构造函数\n    Point(double x_ = 0, double y_ = 0) : x(x_), y(y_) {}\n    // 向量运算重载（核心）\n    // 向量加法\n    Point operator+ (const Point& other) const {\n        return Point(x + other.x, y + other.y);\n    }\n    // 向量减法\n    Point operator- (const Point& other) const {\n        return Point(x - other.x, y - other.y);\n    }\n    // 向量数乘（缩放）\n    Point operator* (double k) const {\n        return Point(x * k, y * k);\n    }\n    // 向量数除\n    Point operator/ (double k) const {\n        return Point(x / k, y / k);\n    }\n    // 浮点数相等判断（带精度）\n    bool operator== (const Point& other) const {\n        return sgn(x - other.x) == 0 && sgn(y - other.y) == 0;\n    }\n};\n```\n\n## 两点间的距离\n\n根据上面的定义，相减以后得到向量，然后再套用下面的向量长度计算公式\n\n```C++\n// 两点间距离\ndouble dist(const Point& a, const Point& b) {\n    return len(a - b);\n}\n```\n\n# 线段\n\n只要这两个变量就能确定一个线段，所以存点\n\n```C++\n// 线段结构体\nstruct Segment {\n    Point a, b; // 线段端点\n    Segment() {}\n    Segment(Point a_, Point b_) : a(a_), b(b_) {}\n};\n```\n\n## 线段的旋转\n\n这里的化，先转化为极坐标，得到：\n设$\\vec a$和x轴的夹角为$\\alpha$,所以$a=(x,y)=(r\\cos\\alpha,r\\sin\\alpha)$\n旋转后得到$a'=(r\\cos(\\alpha+\\theta),r\\sin(\\alpha+\\theta))$\n展开得到\n$a'=(r\\cos(\\alpha)\\cos(\\theta) - r\\sin(\\alpha)\\sin(\\theta), r\\sin(\\alpha)\\cos(\\theta) + r\\cos(\\alpha)\\sin(\\theta)$\n带回坐标就得到公式了。\n如果是原点，直接计算，如果不是，那么先平移一下再计算\n\n```C++\n// 向量a绕原点旋转rad弧度(逆时针为正，顺时针为负)\nPoint rotate(const Point& a, double rad) {\n    double c = cos(rad), s = sin(rad);\n    return Point(a.x * c - a.y * s, a.x * s + a.y * c);\n}\n// 向量a绕点p旋转rad弧度\nPoint rotate_point(const Point& a, const Point& p, double rad) {\n    return rotate(a - p, rad) + p;\n}\n```\n\n用处的化，要是一个几何图形，你一个一个转过去，最后再连起来，就是旋转后的图形了\n# 圆\n\n需要圆心和半径\n\n```C++\n// 圆结构体\nstruct Circle {\n    Point o; // 圆心\n    double r; // 半径\n    Circle() {}\n    Circle(Point o_, double r_) : o(o_), r(r_) {}\n};\n```\n# 向量的计算\n\n## 向量点乘\n\n这里直接用Point来代替向量了，但是实际上差不多,不过是先处理一下而已。\n\n```C++\n// 向量点乘(a·b)\ndouble dot(const Point& a, const Point& b) {\n    return a.x * b.x + a.y * b.y;\n}\n```\n\n用途：\n计算向量夹角、投影长度、判断向量垂直；\n公式：$\\vec a · \\vec b = |\\vec a||\\vec b|\\cos(\\theta)$   ($\\theta$为两向量的夹角)\n\n## 向量的单位化\n\n计算$\\frac{\\vec a}{|\\vec a|}$\n\n```C++\n// 向量单位化(避免零向量)\nPoint normalize(const Point& a) {\n    double l = len(a);\n    if (sgn(l) == 0) return Point(0, 0);\n    return a / l;\n}\n```\n## 求向量的模长和单纯平方\n\n计算$|\\vec a|$和$|\\vec a|^2$\n\n```C++\n//点乘延伸:\n// 向量的模长(长度)平方,(避免开根号，提升效率)\ndouble len2(const Point& a) {\n    return dot(a, a);\n}\n// 向量的模长(长度)\ndouble len(const Point& a) {\n    return sqrt(len2(a));\n}\n```\n\n## 求$\\vec a$在$\\vec b$上的投影向量\n\n公式$$\\frac{\\vec a ·\\vec b}{|\\vec b|}$$\n\n```C++\ndouble proj_len(const Point& a, const Point& b) {\n    return b * ( dot(a, b) / len2(b) );\n}\n```\n\n## 求$\\vec a$在$\\vec b$上的投影向量的模长\n\n```C++\n// 向量投影长度：向量a在向量b上的投影长度 ( projection length（投影长度）)\ndouble proj_len(const Point& a, const Point& b) {\n    return dot(a, b) / len(b);\n}\n```\n\n## 判断向量是否垂直\n\n这个很好理解，因为$$\\vec a·\\vec b=0\\iff\\vec a\\perp\\vec b$$\n```C++\n// 判断两向量垂直\nbool is_vertical(const Point& a, const Point& b) {\n    return sgn(dot(a, b)) == 0;\n}\n```\n\n# 向量的叉乘\n\n## 叉乘的定义\n\n首先叉乘的定义是什么说实话我也不知道该怎么解释，反正知道它的性质就能计算了\n## 计算方式\n\n$$\\vec a\\times \\vec b=x_1*y_2-y_1*x_2$$\n\n```C++\n// 向量叉乘(a×b)\ndouble cross(const Point& a, const Point& b) {\n    return a.x * b.y - a.y * b.x;\n}\n```\n\n## 长度(模长)\n$$\\vec a\\times \\vec b=|\\vec a||\\vec b|\\sin<\\vec a,\\vec b>$$\n## 叉乘的性质\n\n### 方向的表示\n\n根据我的理解叉乘的符号，表示了$\\vec a$到$\\vec b$的方向变化方式\n从a到b：即$\\vec a\\times \\vec b$\n如果是正的，那么是逆时针转的\n如果是负的，那么是顺时针转的\n\n此处的额外要求是把向量的起点放到同一个位置，不过实际上你会发现把向量头尾衔接起来貌似更好理解。下面我都会详细讲解的，保证记住\n示例：顺时针(对应负)从a到b\n\n ```txt\n        b\n        ^\n        |\n        |\na<-------\n ```\n逆时针(对应正)从a到b\n\n ```txt\nb\n^\n|\n|\n------->a\n ```\n\n但是直接记结论貌似不简单？那么试试我的理解方式\n\n首先先把向量整成头尾相接的形式，如下：\n\n```txt\nb\n^\n \\\n  \\\n   \\\n    ^a\n    |\n    |\n    |\n```\n\n然后拿出你的右手，手心向着左边，手掌的走向和a一致，手指的走向和b一致，那么再看看你的大拇指是什么方向呢？朝上对不对？所以是正的。\n那么我们就记住了正对应逆时针。易如反掌\n实际操作时，只要摆对手心和手指的方向就彳亍了，你总不会把手指掰到反面吧 (\n找到舒服的那一侧就是正确的摆法，总之重要的还是记住方向和正负号的关系。\n\n下面给出代码：\n\n```C++\n// 判断向量a是否在向量b的顺时针方向\nbool is_clockwise(const Point& a, const Point& b) {\n    return sgn(cross(a, b)) < 0;\n}\n// 判断向量a是否在向量b的逆时针方向\nbool is_counter_clockwise(const Point& a, const Point& b) {\n    return sgn(cross(a, b)) > 0;\n}\n//直接使用的话是这样的:\n// 判断向量b相对于向量a的方向\ndouble val = cross(a, b);\nif (val > 0) {\n    // b在a的逆时针方向\n} else if (val < 0) {\n    // b在a的顺时针方向\n} else {\n    // a和b共线(同向或反向)\n}\n```\n\n所以下面我们就可以延申到对点和直线关系的判断上了\n\n首先我们判断点和直线关系的本质还是看顺逆时针的变化，构造一条直线，连接向量的尾和这个点，看顺逆时针的变化，所以代码就很理解了\n\n值得注意的是，这里是相对向量的方向而言的，主要作用是为后面点和多边形关系做铺垫\n\n```C++\n// 判断点c在直线ab的左侧/右侧/线上\n// 返回值：>0 左侧，<0 右侧，=0 线上\nint point_line_side(const Point& a, const Point& b, const Point& c) {\n    return sgn(cross(b - a, c - a));//注意顺序\n}\n```\n\n### 和面积的关系\n\n因为叉乘的模长定义为了$$\\vec a\\times \\vec b=|\\vec a||\\vec b|\\sin<\\vec a,\\vec b>$$\n也就是$$2*\\frac{1}{2}|\\vec a||\\vec b|\\sin<\\vec a,\\vec b>$$\n那么就是这三个顶点构成的三角形面积的两倍，或者说，是向量构成的平行四边形的面积\n\n于是我们的三角形的计算公式就有了，下面给出对应的代码\n\n```C++\n// 三点构成的三角形面积(绝对值/2)\ndouble triangle_area(const Point& a, const Point& b, const Point& c) {\n    return fabs(cross(b - a, c - a)) / 2.0;\n}\n```\n\n四边形的计算方法如下：因为我们只要两个向量就彳亍了，这里选择的是$\\vec {AB}$和$\\vec {AD}$，\n\n```C++\n// 四点构成的四边形面积（平行四边形）\ndouble parallelogram_area(const Point& a, const Point& b, const Point& d) {\n    return fabs(cross(b - a, d - a));\n}\n```\n\n### 叉乘的运算规律\n\n加法的左分配律$$a\\times(b+c)=a\\times b+a\\times c$$\n加法的右分配律$$(a+b)\\times c=a\\times c+b\\times c$$\n标量乘法$$(\\lambda a)\\times b=\\lambda(a\\times b)=a\\times(\\lambda b)$$\n\n## 计算点到直线的距离\n\n因为能表示面积，所以能拿来计算距离，具体的推导如下：\n$$\\vec a\\times \\vec b=|\\vec a||\\vec b|\\sin<\\vec a,\\vec b>=h_1*|\\vec a|=h_2*|\\vec b|$$\n所以计算点到直线的距离也可以这么来拆分：\n首先画出三角形，计算这个三角形的面积，然后乘2再除以AB的长度，化简一下就是：\n$$d=\\frac{\\vec{AP}\\times\\vec{AB}}{|\\vec{AB}|}$$\n```C++\n// 点p到直线ab的距离\ndouble point_line_dist(const Point& a, const Point& b, const Point& p) {\n    return fabs(cross(b - a, p - a)) / len(b - a);\n}\n```\n\n那么有人会问了，要是是线段怎么办？\n其实差不多\n\n```C++\n// 点p到线段ab的距离\n\ndouble point_segment_dist(const Point& a, const Point& b, const Point& p) {\n    if (a == b) return dist(a, p); // 线段退化为点\n    // 投影参数t：判断垂足是否在线段上\n    double t = proj_len(p - a, b - a);\n    if (sgn(t) <= 0) return dist(p, a); // 垂足在a外侧\n    if (sgn(t - len(b - a)) >= 0) return dist(p, b); // 垂足在b外侧\n    return point_line_dist(a, b, p); // 垂足在线段内，返回点到直线距离\n}\n```\n\n# 计算点在线段上的垂足\n\n首先先计算一下投影向量，然后加上起点a就彳亍啦\n\n```C++\n// 计算点p在直线ab上的垂足\nPoint foot_point(const Point& a, const Point& b, const Point& p) {\n    Point ab = b - a;\n    double t = dot(p - a, ab) / len2(ab); // 投影参数t(归一化)\n    return a + ab * t;\n}\n```\n\n# 判断点是否在线段上\n\n这里有两个要求，\n首先p得在这条线上，可以通过计算$\\vec {AP}$和$\\vec {BP}$的叉乘得到，叉乘必须为0；\n其次，需要两个向量方向相反，那么点乘为负。\n\n```C++\n// 判断点p是否在线段ab上（含端点）\nbool point_on_segment(const Point& a, const Point& b, const Point& p) {\n    // 1. p在直线ab上；2. p的坐标在a和b之间\n    return sgn(cross(b - a, p - a)) == 0 && sgn(dot(p - a, p - b)) <= 0;\n}\n```\n\n# 判断两直线是否相交\n\n这里我们引入一下包围盒的概念，包围盒的意思是能吧图形包围进去的最小的矩阵，且这个矩阵的边界得和坐标轴平行。\n\n例如：\n```txt\n-----B\n|   /|\n|  / |\n| /  |\n|/   |\nA-----\n```\n\n上面这个就是AB的包围盒\n\n那么有什么用呢？要是包围盒都不相交，那么一定不相交\n\n所以代码如下：\n\n```C++\n// 快速排斥：判断两线段的包围盒是否相交\nbool rect_intersect(const Point& a1, const Point& a2, const Point& b1, const Point& b2) {\n    double min_x1 = min(a1.x, a2.x), max_x1 = max(a1.x, a2.x);\n    double min_y1 = min(a1.y, a2.y), max_y1 = max(a1.y, a2.y);\n    double min_x2 = min(b1.x, b2.x), max_x2 = max(b1.x, b2.x);\n    double min_y2 = min(b1.y, b2.y), max_y2 = max(b1.y, b2.y);\n    return max_x1 >= min_x2 - EPS && max_x2 >= min_x1 - EPS\n        && max_y1 >= min_y2 - EPS && max_y2 >= min_y1 - EPS;\n}\n```\n\n要是严格判定的话，需要用叉乘，实际上，保证A，B在CD异侧就彳亍了\n要是线段AB相交于直线CD的话，那么AC，CD的叉积符号必然和BC，CD的符号相反\n\n这样得到的图实际上可能是这样的：\n\n```txt\n      C\n     ^|^\n    / | \\\n   /  v  \\\n  /   D   \\\n /         \\\nA-----------B\n```\n\n那么我们就发现了，AC到CD和BC到CD的方向一定是不一样的，但是不适用与线段的情况\n\n```C++\n// 跨立实验：判断线段ab是否跨立直线cd\nbool cross_stand(const Point& a, const Point& b, const Point& c, const Point& d) {\n    return sgn(cross(d - c, a - c)) * sgn(cross(d - c, b - c)) <= 0;\n}\n```\n\n但是要是都是线段的话，还要保证C，D在AB异侧，所以代码：\n也就是保证CD和AB也有类似的关系，那么化工图发现这样的一定相交\n\n```C++\n// 判断两线段是否相交（含端点）\n\nbool segment_intersect(const Segment& s1, const Segment& s2) {\n    Point a = s1.a, b = s1.b, c = s2.a, d = s2.b;\n    // 快速排斥\n    if (!rect_intersect(a, b, c, d)) return false;\n    // 跨立实验(双向)\n    return cross_stand(a, b, c, d) && cross_stand(c, d, a, b);\n}\n```\n\n# 求直线或者线段的交点\n\n首先先保证相交再来计算\n\n建议在使用函数之前先调用一下上面的相交函数\n\n下面是交点函数的证明：\n\n```txt\n             A\n            /|\n           / |h1\nC---------E---------------D\n    h2|  /\n      | /\n      |/\n      B\n```\n\n我们先计算A和B分别到CD的距离，记作$h_1\\text{和} h_2$\n那么先相似一下，然后再比例得到E的坐标\n$$E=\\frac{h_1}{h_1+h_2}\\times\\vec{AB}+A$$\n然后，前面刚讲过，高可以由面积得到，那么直接用叉乘代替高就得到计算公式了\n设$s_1=\\vec{CD}\\times\\vec{CA},s_2=\\vec{CD}\\times\\vec{CB}$\n由于符号相反，所以可以这么写：\n$$E=\\frac{s_1}{s_1-s_2}\\times\\vec{AB}+A$$\n\n但是上面考虑的时AB在CD的异侧时的情况\n那么我们来考虑一下如果AB在CD的同侧该怎么计算\n\n```txt\n\t             A\n\t            /|\n\t           / |h1\n\t\t      /  |\n\t         B   |\n\t         |   |\n\t         |h2 |\nC---------E---------------D\n    \n```\n\n我们用叉乘的话可以发现，叉乘符号相同，那么发现公式还是上面那个，统一一下，所以代码写起来就简单了\n然后我们把点带入得到：\n$$E=\\frac{s_1}{s_1-s_2}\\times(B-A)+A=\\frac{B*s_1-A*s_2}{s_1-s_2}$$\n```C++\n// 计算两直线ab和cd的交点（需保证直线不平行）\nPoint line_intersect(const Point& a, const Point& b, const Point& c, const Point& d) {\n    double s1 = cross(d - c, a - c);\n    double s2 = cross(d - c, b - c);\n    return (a * s2 - b * s1) / (s2 - s1);\n}\n```\n\n线段的话，可以先算出交点，然后判断交点是不是在线段上\n\n```C++\n// 计算两线段的交点（仅当相交时返回有效点）\n\nPoint segment_intersect_point(const Segment& s1, const Segment& s2) {\n    return line_intersect(s1.a, s1.b, s2.a, s2.b);\n}\n```\n# 圆相关的计算\n\n## 判断点和圆的关系\n\n为了保证精度，所以采用平方\n\n```C++\n// 判断点p与圆c的位置：>0 圆外，=0 圆上，<0 圆内\nint point_circle_relation(const Point& p, const Circle& c) {\n    double d2 = len2(p - c.o); // 距离平方(避免开根号)\n    double r2 = c.r * c.r;\n    return sgn(d2 - r2);\n}\n```\n\n\n## 点到圆的切线长度\n\n这个很好理解，就是勾股定理\n\n```C++\n// 点p到圆c的切线长度\ndouble tangent_len(const Point& p, const Circle& c) {\n    double d = dist(p, c.o);\n    if (sgn(d - c.r) <= 0) return 0.0; // 点在圆内/圆上，无切线\n    return sqrt(d * d - c.r * c.r);\n}\n```\n\n## 求直线与圆的交点\n\n首先先计算垂足，判断交点个数的情况，要是有两个交点的话，计算方式是，垂足+垂足到交点的距离乘上直线AB的单位向量\n\n```C++\n// 计算直线ab与圆c的交点（返回交点列表）\nvector<Point> line_circle_intersect(const Point& a, const Point& b, const Circle& c) {\n    vector<Point> res;\n    Point foot = foot_point(a, b, c.o); // 圆心到直线的垂足\n    double d = point_line_dist(a, b, c.o); // 圆心到直线的距离\n    if (sgn(d - c.r) > 0) return res; // 无交点\n    if (sgn(d - c.r) == 0) { // 相切，一个交点\n        res.push_back(foot);\n        return res;\n    }\n    // 相交，两个交点：垂足向两侧移动 len = sqrt(r² - d²)\n    double Len = sqrt(c.r * c.r - d * d);\n    Point dir = (b - a) / len(b - a); // 直线方向单位向量\n    res.push_back(foot + dir * Len);\n    res.push_back(foot - dir * Len);\n    return res;\n}\n```\n\n## 线段与圆的交点\n\n首先先算直线和圆的交点，然后再判断这个点是否在线段上\n\n```C++\n// 计算线段ab与圆c的交点（返回交点列表）\nvector<Point> segment_circle_intersect(const Point& a, const Point& b, const Circle& c) {\n    vector<Point> res, line_inter = line_circle_intersect(a, b, c);\n    // 筛选交点是否在线段上\n    for (auto& p : line_inter) {\n        if (point_on_segment(a, b, p)) {\n            res.push_back(p);\n        }\n    }\n    return res;\n}\n```\n\n# 多边形的计算\n\n## 多边形的面积计算\n\n这个由于我们已经有了一个很好的工具，叉乘，那么我们划分一下面积再计算\n比较好理解的方法是，以$P_0$为每个三角形的顶点，依次计算，\n所以公式$$\\frac{1}{2}\\sum_{i=1}^n(P_i-P_0)\\times(P_{i+1}-P_0)$$\n但是注意到我们的叉乘具有向量加法的左右分配律，所以展开上面这个式子$$\\begin{split}\n&\\frac{1}{2}\\sum_{i=1}^nP_i\\times P_{i+1}-P_i\\times P_0-P_0\\times P_{i+1}+P_0\\times P_0\\\\\n&=\\frac{1}{2}\\sum_{i=1}^nP_i\\times P_{i+1}\n\\end{split}$$\n首先$P_0\\times P_0$一定是等于0的，其次，因为所有点都遍历了，那么$\\sum_{i=1}^nP_i\\times P_0=-\\sum_{i=1}^nP_0\\times P_{i+1}$相当于只是后移了一位，但是结果一样，所以直接遍历点的叉乘就可以计算了。\n\n```C++\n// 计算多边形面积（顶点数组，闭合：最后一个点无需等于第一个）\ndouble polygon_area(const vector<Point>& poly) {\n    int n = poly.size();\n    double area = 0.0;\n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        area += cross(poly[i], poly[j]);\n    }\n    return fabs(area) / 2.0;\n}\n```\n\n## 判断点是否在多边形内部\n\n首先做一条射线，向右射出，计算这条射线和多边形的交点数量，奇数则在内部，偶数则在外部\n\n```C++\n// 判断点p是否在多边形poly内（含边界）\nbool point_in_polygon(const Point& p, const vector<Point>& poly) {\n    int n = poly.size();\n    int cnt = 0;\n    for (int i = 0; i < n; i++) {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (point_on_segment(a, b, p)) return true; // 在边界上\n        // 射线法：判断射线与线段是否相交\n        if (sgn(a.y - p.y) > sgn(b.y - p.y)) swap(a, b);\n        if (sgn(b.y - p.y) <= 0) continue;\n        if (sgn(cross(b - a, p - a)) > 0) cnt++;\n    }\n    return cnt % 2 == 1; // 奇数：内部，偶数：外部\n\n}\n```\n\n**感谢看完这篇文章！要是有什么想法或者建议，欢迎来交流讨论！**","tags":["算法"]},{"title":"DP习题笔记","url":"/ZestfulYK-blog/2025/12/16/DP习题笔记1(动态规划的引入)/","content":"# 循环的遍历\n\n- 注意一下最内层的循环是什么，他决定了这一步的决策是什么。\n\n## 例题\n\n[纸币问题 2](https://www.luogu.com.cn/problem/P2840)\n\n- 这一题要我们求完全背包的方案数（考虑顺序）\n- 那么内层循环应该放的是面额的遍历，因为最后一步的面额是不一定的。\n- **正确写法**✔：\n```C++\nfor(int i=1;i<=w;i++)\n   for(int j=1;j<=n;j++)\n      if(i>=a[j])\n        dp[i]=(dp[i-a[j]]+dp[i])%mod;\n```\n\n- **错误写法**❌：\n```C++\nfor(int i=1;i<=n;i++){\n    ll x; cin>>x;\n    for(int j=x;j<=w;j++){\n        dp[j]=(dp[j-x]+dp[j])%mod;\n    }\n}\n```\n- 为什么下面那个是错误的？\n- 因为把当前面额作为内层循环，相当于固定了最后一步只能是这个面额，没法考虑到顺序问题。这样的话第二次只能在第一次的基础上增加。实际上，第一次的面额也可以在第二次的基础上增加。因此这个做法是不正确的。\n**注意**：下面那个方法因为只考虑了最开始的顺序(即输入顺序)，所以只有一种顺序，那么就可以拿来统计**组合数**\n\n在解决这类问题时，关键要问自己：\n- 题目要求的是组合数还是排列数？\n- 我的循环顺序是否允许不同的支付顺序？\n- 我是否在无意中强加了某种顺序限制？(**关键点**)\n对于这道题，既然要求考虑支付顺序，就必须使用金额在外层的循环方式。\n\n# 特殊例题\n## 计算容积不超过n得到的最大的占有体积\n\n- 思路：设$dp[i]$表示不超过i获得的最大值，那么每一个物品的体积是x，价值也是x。\n- 状态转移方程：$$dp[i]=max(dp[i],dp[i-x]+x)$$\n## 例题\n\n[考前临时抱佛脚 - 洛谷](https://www.luogu.com.cn/problem/P2392)\n\n- 题目说可以双核，那么只要一边最接近sum/2就彳亍了，所以可以用上面那个模型\n# 01背包0也有值的问题\n\n- 在正常的01背包中，如果遍历不到就不管了，但是现在要求不能放入时也有一定的值，那么这时就要管了，在体积不够时，每一个都只有一种选法，那就是不选。所以每一个都要加上不选所对应的值。\n## 例题：\n\n[5 倍经验日 - 洛谷](https://www.luogu.com.cn/problem/P1802)\n\n- 题目说了在打不过时也能得到经验，你要是不给玩家经验，当然是不对的啦\n\n\n# DP的一般思路\n\n- 首先看看是否是背包或者背包的变形，要是是的话就简单了\n- 看一下每一次有几种转移方式，把可能的变化列一下，看看是否有规律\n- 在这一讲还是不用区分特殊类型的DP的","tags":["算法"]},{"title":"我这学期犯过的唐","url":"/ZestfulYK-blog/2025/12/16/我这学期犯过的唐/","content":"\n# 不知道vector的size是size_t类型\n\n- 因为是size_t所以直接加减会出错，比如减成负数的时候。\n\n# 内层循环变量写错\n\n- 这个会导致外层循环少了几次\n\n# sort里面的数据范围没开正确\n\n- 例如要对n* m的数据排序，却只写了n\n\n# 不看清读入顺序\n\n- 看清读入的是有序的还是乱序的，不要被样例蒙蔽了双眼","tags":["算法"]},{"title":"构造操作类题目","url":"/ZestfulYK-blog/2025/12/16/构造操作类题目/","content":"# 定义\n\n- 构造一些操作，使得数据满足操作要求，通常还会有次数限制\n\n# 方法\n\n此类题目现在遇到过三种做法：\n\n- 一种是直接操作，不关心部分值，直接对全局操作，使得再让全局满足要求的同时，使得部分也满足要求\n- 另一种是进行操作，最后只改变一个量，每次用多步做一步\n（和魔方有点像？）\n\n# 例题\n\n1.[B. Siga ta Kymata](https://codeforces.com/contest/2163/problem/B)\n\n- 题目描述：\n给你一个排列 $^{\\text{∗}}$ 。从 $1$ 到 $n$ 的每个整数的排列 $p$ 。您还拥有一个大小为 $n$ 的二进制 $^{\\text{†}}$ 字符串 $s$ ，其中 $s_i = \\mathtt{0}$ 代表所有 $1 \\le i \\le n$ 。您最多可以执行以下操作 $5$ 次：\n选择任意两个整数 $l$ 和 $r$ ，使得 $1 \\le l \\le r \\le n$ .然后，对于每一个 $i$ 使得 $l< i< q$ 和 $\\min(p_l, p_r) < p_i < \\max(p_l, p_r)$ 同时成立，你将把 $s_i$设为 $\\mathtt{1}$ 。\n您还会得到一个大小为 $n$ 的二进制字符串 $x$ 。执行运算后，对于每一个 $1 \\le i \\le n$ 都必须成立：如果 $x_i = \\mathtt{1}$ ，则 $s_i = \\mathtt{1}$ 。注意，如果 $x_i = \\mathtt{0}$ ，那么 $s_i$ 可以有**任意**值。\n找出最多**5**个运算序列，使上述条件得到满足，或者报告不可能做到这一点。请注意，您**不必**尽量减少操作次数。\n\n解法：\n```txt\n|----------------|-------------------n------------\n|                |                   |           |\n|----------------|-------------------|——————————a[n]\n|                |                   |           |\na[1]----------------------------------------------\n|                |                   |           |\n|                |                   |           |\n|----------------1--------------------------------\n```\n\n- 一共画了5个框，也就是5次操作的范围\n- 这里实际上是把所有能改变的全改变了，然后也就满足了要求\n- 所以5次也是合理的，证明了做法的正确\n\n2.[西安之泪 - 洛谷](https://www.luogu.com.cn/problem/P14755?contestId=296933)\n\n-  题目描述：\n给定一颗无根树,共有n个顶点。每个顶点 i 都具有一个点权$a_i$，初始所有点权都为0。\n你可以进行如下的操作最多不超过$3n$次：\n指定顶点的编号 r,u (1≤r,u≤n)，使得这棵树暂时以顶点 r 为根，随后对于顶点 u 的子树中的每一个顶点 v，将其点权修改为 av​⊕u。此处的 ⊕ 表示**按位异或**。\n\n这一题就是尝试操作每一个顶点，分步完成。\n让每个顶点的邻居给这个顶点发一次，那么最终剩下的节点就被⊕了出度数-1次。如果是偶数，不变；但是奇数时，为了保持不变，那么我们在自己给自己发一次就行了。\n\n","tags":["算法"]},{"title":"程C笔记2","url":"/ZestfulYK-blog/2025/12/16/程C笔记2/","content":"# 递归\n\n## 函数的定义\n\n注意一下在命名函时，可以不写参数的名称，比如：\n```C++\nvoid fun(int,int)\n```\n\n# 结构体排序\n\n```C++\nvoid mySwap(Data *p1,Data *p2){//交换函数\n    Data t=*p1;\n    *p1=*p2;\n    *p2=t;\n}\nfor(int i=0;i<n-1;i++){\n    for(int j=0;j<n-i-1;j++){\n       if(a[j].num>a[j+1].num || \n       (a[j].num==a[j+1].num && a[j].value>a[j+1].value)){\n           mySwap(&a[j],&a[j+1]);\n        }\n    }\n}\n```\n\n- 传入时注意，要加上&，传入地址，使得函数可以交换地址。\n\n# 数组的定义\n\n- 使用new和delete一起运算。\n\n## 基本方法\n\n```C++\n// 创建一维动态数组\n数据类型* 指针名 = new 数据类型[元素个数];\n// 释放内存\ndelete[] 指针名;\n```\n\n## 一维数组\n### 示例\n\n```C++\n// 方法1：创建基本类型的一维数组\nint n = 5;\nint* arr1 = new int[n];  // 创建包含5个整数的数组\ndelete[] arr1;\n```\n\n## 二维数组\n\n- 比一维数组多了一个*\n\n### 内存连续\n\n```C++\n // 分配连续内存\nint** arr = new int*[rows];  // 创建行指针数组\narr[0] = new int[rows * cols];  // 分配所有元素的空间\n\n// 设置行指针\nfor (int i = 1; i < rows; i++) {\n    arr[i] = arr[i-1] + cols;\n}\n```\n\n### 内存不连续\n\n```C++\n// 创建二维数组\nint** arr = new int*[rows];  // 创建行指针数组\nfor (int i = 0; i < rows; i++) {\n    arr[i] = new int[cols];  // 为每一行分配内存\n}\n```","tags":["算法"]},{"title":"不定积分习题","url":"/ZestfulYK-blog/2025/12/13/不定积分习题/","content":"# 第一类有理积分\n\n## 主要方法\n\n- 放入分子\n- 放入分子的部分\n- 放入分母\n- 放入分母的部分\n- 特殊构造\n  |--商的导数求积分部分\n  |--两个函数相乘求导$e^x$\n  |--三角函数构造$\\tan x$\n- 最后复习一下一些特殊的积分公式\n## 放入分子\n- 这一中方法比较基础。\n- 如果是放入分子的，那么必然是如下形式的$$\\int \\frac{f'(x)}{f(x)}\\,dx$$\n- 这样就能得到$$\\int \\frac{df(x)}{f(x)}$$\n- 所以先看一下分母求导的结果有没有可能等于分子，如果是，那么就可以用这种方法\n### 例题\n$$\\int \\frac{\\sin x+\\cos x}{\\sqrt[3]{\\sin x-\\cos x}}\\,dx$$\n## 放入分子的部分\n\n- 这个通常出现在三角函数中，因为这样可以把所有三角函数化程同名。\n- 然后放入时注意一下和分子的形式要对上。\n### 例题\n$$\\int \\frac{\\sin x\\cos x^3}{1+\\cos x^2}\\,dx$$\n- 这题直接放入$\\sin x$还不行，因为要注意一下分母的形式。\n所以注意到可以凑出$\\sin 2x$，这样放入时形式就一样了\n\n\n## 放入分母\n\n- 放入分母的实际上是这种形式$$\\int f'(x)f(x)\\,dx$$\n- 然后被$f'(x)$正好是分数的形式，看起来就像分式罢了。\n- 所以记得先看看分子求导是否可能是一个分式，比如$\\ln x$或者是$\\sqrt{x^2-1}$这种形式的式子\n- 所以也有可能是分子的导数会穿一部分到分子来，所以建议是先对分子的部分进行求导\n- 主要问题是，出题人会把求导结果化到最简，导致看不出来\n### 例题\n 1. \n$$\\int \\frac{\\sqrt{\\ln(x+\\sqrt{1+x^2})+1}}{\\sqrt{1+x^2}}\\,dx$$\n 2. \n$$\\int\\frac{e^{\\sqrt{1+\\sin x}}\\cos x}{\\sqrt{1+\\sin x}}\\,dx$$\n## 放入分母的部分\n\n- 这一种情况通常是在含有$\\ln x$和$\\frac{1}{x}$时使用，因为可以把$\\frac{1}{x}$放入。\n目前只发现这一种情况可以用这个来解决\n\n### 例题\n$$\\int \\frac{\\ln x^2}{x(1+\\ln x^2)}\\,dx$$\n## 特殊构造\n\n- 比较难想到，但是遇到以后下次就有概率会写\n### 商的导数求积分部分\n\n- 这一种之前做过一次，可以看一下分部积分的**商的导数求积分部分**。\n- 传送门：[分步积分笔记](https://zestfulyk.github.io/ZestfulYK-blog/2025/12/07/%E5%88%86%E6%AD%A5%E7%A7%AF%E5%88%86/)\n\n### 两个函数相乘导数的积分\n\n- 实际上，这个是$$\\int e^{ax}f(x)\\,dx$$\n然后可以被转化为$$\\int e^{ax}(ah(x)+h'(x))\\,dx$$\n所以是$e^{ax}$和别的函数的乘积得到的，通常也只有$e^{ax}$能有这种特殊做法。\n\n#### 为什么只有$e^{ax}$有这个性质\n- $e^{ax}$求导有不变性，这样求导了以后才会出现这种情况，所以只有$e^{ax}$才应当考虑有无这种特殊解法，其余的直接计算就好了，不要想那么多\n\n#### 识别方法：\n1. **观察结构**：被积函数通常包含指数函数$e^{ax}$与另一个函数f(x)的乘积。\n2. **分析 $f(x)$**：尝试将 $f(x)$拆分为两部分，其中一部分是某个函数 $h(x)$，另一部分是其导数 $h'(x)$（或 $ah(x)+h'(x)$）。常见的线索包括：\n- $f(x)$ 为有理函数或三角函数，且分子或分母具有导数的特征。\n- 通过经验猜测$h(x)$的形式.\n1. **验证**：对猜想的 $h(x)$ 求导，检查是否满足 $f(x)=ah(x)+h'(x)$\n\n\n\n#### 例题：\n\n$$\\int \\frac{(1+\\sin x)e^x}{1+\\cos x}\\,dx$$\n发现有$e^{ax}$考虑一下是否可以这么做，那么先计算前面能否拆成$f(x)=ah(x)+h'(x)$，计算得到:$$(\\frac{\\sin x}{1+\\cos x})'=\\frac{1}{(1+\\cos x)}$$\n所以这么拆分是合法的。\n最后得到：\n$$\\frac{e^x \\sin x}{1+\\cos x}+C$$\n此外，还有一题和这个思路十分类似：$$\\int \\frac{\\cos x^2-\\sin x}{\\cos x(1+e^{\\sin x}\\cos x)}\\,dx$$\n注意到：$$(e^{\\sin x}\\cos x)'=\\cos x^2-\\sin x$$\n所以可以把分子放入进行计算，这里依然是$e^{ax}$的性质。此外放入以后发现少了一个$e^{\\sin x}$，那么再加上一个$e^{\\sin x}$再$dx$里面，正好使得分母多了一个$e^{\\sin x}$，那么换元一下就是有理函数的积分了\n\n**总结**：遇到$e^{ax}$，求导一下总是有用的，能简化计算。\n\n### 余正弦化正切\n\n- 遇到这么一种情况，有$\\sin x$和$\\cos x$，但是表现出的却是加法的形式，无法把其中一部分提取出来，那么这时我们就应该考虑一下是不是可以化成$\\tan x$来计算。\n\n### 例题\n\n1.\n$$\\int \\frac{dx}{\\sin x^2+2\\cos x^2}$$\n- 这里无法采用上述提及的所有方法，于是我们采用上下同时除以$\\cos x^2$的方法来计算，得到有关$\\sec x^2$和$\\tan x^2$的式子，这样就可以计算了。\n\n2.$$\\int \\frac{x+\\sin x\\cos x}{(\\cos x-x\\sin x)^2}\\,dx$$\n- 注意到下面部分的导数并非上半部分，上半部分也不能被提取，那么考虑能否转换为$\\tan x$和$\\sec x$的式子，于是先提取一个$\\cos x$，得到：$$\\int \\frac{x\\sec x+\\tan x}{(1-x\\tan x)^2}\\,dx$$\n- 接着就发现下面的导数等于上面部分了，那么就好做了。\n\n\n## 特殊积分公式复习\n- 首先是特殊的三角公式\n$$\\int \\sec x\\,dx=ln|\\sec x+\\tan x|+C$$\n$$\\int \\csc x\\,dx= ln|\\csc x-\\cot x|+C$$\n- 接下来是裂项公式\n$$\\int \\frac{1}{x^2-a^2} \\, dx = \\frac{1}{2a}\\ln\\left|\\frac{x-a}{x+a}\\right| + C$$\n$$\\int \\frac{1}{a^2-x^2} \\, dx = \\frac{1}{2a}\\ln\\left|\\frac{a+x}{a-x}\\right| + C$$\n(要是记不住这个好像也可以直接当有理函数来做？)\n- 最后是反三角式\n$$\\int \\frac{1}{\\sqrt{a^2-x^2}} \\, dx = \\arcsin\\frac{x}{a} + C$$\n$$\\int \\frac{1}{x^2+a^2} \\, dx = \\frac{1}{a}\\arctan\\frac{x}{a} + C$$\n这一个只有两种情况，剩下的老老实实进行$\\sec x$和$\\tan x$代换\n上下其实都会消去一个$\\frac{1}{a}$但是下面那个是二次式子，所以就剩下了一个$\\frac{1}{a}$.\n## 额外提醒\n\n- 注意$\\frac{1}{\\cos x}$和$\\sec x$的转换，如果只是单出现一个，那么就转换成没有分数的式子\n- 注意一下同时含有$\\tan x\\text{和}\\sec x$的分式，可能需要展开消去部分$\\cos x$来简化计算\n- 需不需要展开计算看你是否可以消去\n\n# 第二类换元积分\n\n## 主要方法\n\n- 第二类换元积分开始和有理积分接近，所以换元完要考虑一下有理积分。\n- 含有根式的只有$\\sqrt{a^2-x^2}$有公式，其他老老实实计算！\n- 倒带换是把x换为$\\frac{1}{t}$，别代换错了\n- 要是根式含有$a^x$，那么令整一个根号为t，其他令$a^x$为t\n\n## 简单根式代换\n\n- 除了$\\tan x\\text{和}\\sec x$的代换以外，还有这么一种情况：\n$$\\int \\frac{x^2\\,dx}{\\sqrt{(x^2-a^2)^3}}$$\n- 实际上，里面的次数是没有影响的，因为每一个都可以拆出一个，得到三次式，然后再老老实实计算。\n- 其他含有根式的，要么时属于有理函数的积分，有吗就是可以直接按照三角换元做出来。\n### 例题\n\n$$\\int \\frac{dx}{(1+x^2)\\sqrt{1-x^2}}$$\n- 直接把x代换为$\\sin t$即可，然后这个式子貌似很熟悉？\n## 质数函数的代换\n\n- 例如分母含有$e^x$等赘述函数时，直接代换这一部分\n- 如果在根式中，代换整个根式\n### 例题\n\n#### 代换指数函数\n\n- 例如求\n$$\\int \\frac{1}{e^x+e^{2x}}\\,dx$$\n- 代换$x=\\ln t(e^x=t)$得到$$\\int \\frac{1}{t+t^2}\\frac{1}{t}\\,dt$$\n- 就能变成有理函数的积分了\n#### 代换整个根式\n\n- 例如求$$\\int \\frac{1}{\\sqrt{e^x+1}}\\,dx$$\n- 代换整个根号$x=\\ln(t^2-1)\\,(t=\\sqrt{e^x+1})$得到$$\\int \\frac{1}{t}\\frac{2t}{t^2-1}\\,dt$$\n- 从而又被化成了有理函数的积分\n\n## 倒代换\n\n- 代换为$\\frac{1}{t}$，别把$\\frac{1}{x}$代换成了t就彳亍\n- 然后注意时用在幂函数上，别搞错就彳亍\n### 例题\n\n- 如计算$$\\int \\frac{1}{x(x^6+1)}\\,dx$$\n- 直接代换得到$$-\\int \\frac{1}{\\frac{1}{t}((\\frac{1}{t})^6+1)}\\frac{1}{t^2}\\,dt=\n- \\int \\frac{t^5}{1+t^6}\\,dt$$\n- 就变成第一类换元积分了\n\n## 特殊例子\n\n- 看似一般的根式，凑成可以三角代换的式子\n\n### 例题\n\n$$\\int \\sqrt{2x-x^2}\\,dx$$\n- 先凑一下，得到$$\\int \\sqrt{1-(x-1)^2}\\,dx$$\n- 然后就会计算了\n\n **关注ZestfulYK喵，谢谢喵！**","tags":["数学"]},{"title":"几何计算习题笔记","url":"/ZestfulYK-blog/2025/12/11/几何计算笔记/","content":"# 凹凸多边形的判断\n\n## 重要知识：叉积\n\n### 几何意义：\n\n符号代表了叉积两个向量的转向：\n \\> 0 逆时针\n < 0 顺时针\n = 0 共线\n\n### 基本原理\n\n对于连续三个点A、B、C：\n叉积 = (B.x - A.x) * (C.y - B.y) - (B.y - A.y) * (C.x - B.x)\n要是是向量的话是：a.x * b.y- a.y * b.x\n\n这个叉积实际上计算的是向量 **AB** 到向量 **BC** 的旋转方向。\n\n## 实现方法\n\n### 可视化解释\n\n考虑四边形$ABCD$，我们按顺序（如逆时针）检查每个顶点：\n\n如果所有顶点的叉积都**保持同号**（全部为正或全部为负），说明多边形所有顶点都朝同一个方向\"拐弯\"，这就是凸多边形。\n\n```txt\nC(2,2) ────── D(0,2)\n│              │\n│              │\nB(2,0) ────── A(0,0)\n```\n\n**在顶点A处**：\n- 向量DA = A - D = (0-0, 0-2) = (0, -2)\n- 向量AB = B - A = (2-0, 0-0) = (2, 0)\n- DA × AB = 0* 0 - (-2)* 2 = 4 > 0（逆时针）\n\n**在顶点B处**：\n- 向量AB = (2, 0)\n- 向量BC = C - B = (2-2, 2-0) = (0, 2)\n- AB × BC = 2* 2 - 0* 0 = 4 > 0（逆时针）\n\n### 凹四边形的反例\n\n对于凹四边形，某个顶点会出现相反的转向：\n\n```txt\n     D(1,2)\n    /B(1,1) ← 凹点\nA(0,0)─-───────C(3,0)  \n```\n\n在凹点B处，转向会与其他顶点相反。\n\n## 算法实现步骤\n\n- **计算各个叉积**\n\n```txt\ncp₁ = 叉积(向量AB, 向量BC)  // 在点B处\ncp₂ = 叉积(向量BC, 向量CD)  // 在点C处\ncp₃ = 叉积(向量CD, 向量DA)  // 在点D处\ncp₄ = 叉积(向量DA, 向量AB)  // 在点A处\n```\n\n- 1. **判断符号一致性**：\n    - 如果所有$cp_i \\geq 0$，则为逆时针排列的凸四边形\n    - 如果所有$cp_i\\leq 0$，则为顺时针排列的凸四边形\n    - 否则为凹四边形\n\n\n### 实例代码\n\n```C++\nstruct point{double x,y;};\n\ndouble chaji(const point &a,const point &b,const point &c{\n  point v1,v2;//计算向量\n  v1.x=b.x-a.x; v1.y=b.y-a.y;\n  v2.x=c.x-b.x; v2.y=c.y-b.y;\n  return v1.x*v2.y-v1.y*v2.x;\n  //转换成向量以后，x和y交换着乘\n}\n\nvoid solve(){\n  point a,b,c,d;\n  cin>>a.x>>a.y;\n  cin>>b.x>>b.y;\n  cin>>c.x>>c.y;\n  cin>>d.x>>d.y;\n  double cj1=chaji(a,b,c);\n  double cj2=chaji(b,c,d);\n  double cj3=chaji(c,d,a);\n  double cj4=chaji(d,a,b);\n  if((cj1>0&&cj2>0&&cj3>0&&cj4>0)||(cj1<0&&cj2<0&&cj3<0&&cj4<0)){\n    cout<<\"Yes\"<<endl;//要同号才行\n  }\n  else cout<<\"No\"<<endl;\n}\nsigned main(){\n    solve();\n    return 0;\n}\n```\n\n# 直线的计算\n\n## 写在前面的话\n\n**傻逼C++的double的精度不高所以表示直线建议使用$Ax+By+C=0$**\n\n然后就变简单了喵~\n## 计算公式\n\n$$\\begin{cases}\nA=p2_y-p1_y \\\\\nB=p1_x-p2_x \\\\\nC=p2_x*p1_y-p1_x*p2_y\n\\end{cases}\n$$\n\n之后不要忘记除以他们的最大公约数，用来去重，这点非常重要，因为可能产生倍数\n\n## 例题\n\n[K-colinear Line](https://vjudge.net/contest/771553#problem/B)\n\n这一题要求我们计算经过k个点的直线数量，这里最重要的是理解怎么消去除法。\n这题的做法还是蛮多样的，好友qinye_leaf的解法是：$$(x_1-x_0)(y-y_0)==(y_1-y_0)(x-x_0)=>\\frac{x_1-x_0}{x-x_0}=\\frac{y_1-y_0}{y-y_0}$$\n此外上面的做法也是可行的，总之消去除法，然后防止重复(这是一个好问题)\n\n# 圆的计算\n\n## $\\pi$的取值建议\n\n- 如果有了规定值，那么直接使用\n- 没有的话，处于精度考虑，可以使用$\\arccos (1.0)$来代替、\n# 多边形的计算\n\n## 几何图形面积计算\n### 例一\n\n例题：[P. Area of a Star](https://codeforces.com/problemset/problem/630/P)\n需要我们计算多角形的面积\n这一题的话有两种做法，一种是直接分成$2*n$个小三角形，而每一个三角形的三个内角都是已知的，因此可以直接计算。\n另外一种做法是发现可以整体减空白，稍微复杂一点，但也可行。\n#### 补充知识\n复习一下正弦定理：$$\\frac{a}{\\sin \\alpha}=\\frac{b}{\\sin \\beta}=\\frac{c}{\\sin \\gamma}=2R$$\n因此这一题只知道三个角和一条边是可以直接计算的。\n\n### 例二\n\n#### 例题：[B. Mister B and Angle in Polygon](https://codeforces.com/problemset/problem/820/B)\n需要我们在多边形上找到三个点，使得构成的角度和给定角度最接近。\n\n**重要观察**：在正n边形中，从一个顶点出发，连接所有其他不相邻的顶点（即除相邻两个顶点外的所有顶点），这些连线会将这个顶点的内角等分成$n−2$个相等的角，每个角的度数为 $\\frac{180}{n}$。\n\n> 证明：把多边形放到一个圆里面，然后发现相同弦所对的角相等，所以原命题是成立的\n\n**推论**：那么在这个多边形上任取三个点构成的角也必然是$\\frac{180}{n}$.\n\n> 证明：和刚才一样，只要证明每个条角所对的弦都能在同一个顶点上构造出来\n\n所以解出这题的步骤是：\n- 先看是否大于等于最大角，如果是，那么输出1 2 3\n- 否则计算中间值用$\\frac{180}{n}$的倍数代替。","tags":["算法"]},{"title":"程C笔记","url":"/ZestfulYK-blog/2025/12/11/程C笔记/","content":"## 1. 头文件和命名空间\nC++ 中的 string 类定义在头文件 string 中，通常使用 std 命名空间。\n\n```c++\ns3=strcat(s1,s2);//加在后面\nint x=strcmp(s1,s2)//返回三种情况,见下面\ncout<<strlen(s1)<<endl;//输出的是长度，等同于s1.length()\nstrcpy(s1+x1,s2+x2);//把前面的对应部分添加到前面去，完全覆盖之前的内容\nmemcpy(a+x1,b+x2,sizeof(int)*8);//也是把后面的放到前面，只不过需要规定放入的内容\nsizeof(s1);//考虑后面的'\\0'，比strlen大1.\n```\n$$ x=strcmp(s1,s2)= \n\\begin{cases}\n -1  \\ \\ \\ \\ \\ s1 \\leq s2\\\\\n0\\ \\ \\ \\ s1=s2\\\\\n1\\ \\ \\ \\ s1 \\geq s2\n\\end{cases}\n$$\nmemcpy例子：\n```C++\nint a[8]={1,2,3,4,5,6,7,8};\nint b[10]={10,9,8,7,6,5,4,3,2,1};\nmemcpy(b,a,sizeof(int)*8);\nfor(int i=0;i<10;i++)\n    cout<<b[i];\n```\n输出：\n```C++\n1234567821\n```\n\n## 2.函数\n```C++\nint maxGap(int* p, int n)//传入p[0]的地址，能改变在主函数里的值\nstatic int t;//静态局部变量，下次还是调用上次的值\n//例如：\nint cnm(int p,int q){\n\tstatic int t=0;\n\tt+=p+q;\n\treturn t;\n}\nsigned main(){\n\tcout<<cnm(1,2)<<cnm(2,3)<<endl;\n}\n```\n\n- 局部变量，全局变量，如果多个声明，那么优先使用内部的数据\n```C++\nint a=5;\nint main(){\n\tint a=10,b=20;\n\tfor(int i=1;i<=3;i++){\n\t\tcout<<a++<<\" \"<<b<<endl;\n\t\t{\n\t\t\tstatic a=0;\n\t\t\tfor(int j=1;j<=5;j++){\n\t\t\t\ta+=j;\n\t\t\t}\n\t\t\tb+=a;\n\t\t}\n\t}\n}\n```\n\n- 要根据函数返回的类型来决定函数的类型\n- 要根据函数内的使用变量来决定函数使用的参数值\n```C++\n//例如：\nchar* fun(int c){//程C一般不用string，自己写都行\n\treturn \"yes\";\n}\nint* fun1(int c){\n\tint a[]={1,2,3};\n\treturn a;\n}\n```\n# C++变量初始化\n\n\n```C++\nint a=10;\nbool b=1;//b=true;\nchar c='c';\nint a[10]={1,2,3,4};\nint a[]={1,2,3,4};\nint a[3][3]={1,2,3,5,6};\nint a[3][3]={{1,2},{3,4}};\nint solve(int a,int b=10){//有时可能定义在mian函数前面\n\treturn a+b;//有值用值，反之用默认值\n}\n```\n\n# C++ 插入排序\n\n```C++\nvoid insertSort(int arr[],int n){\n\tfor(int i=1;i<n;i++){\n\t\tint key=arr[i];\n\t\tint j=i-1;\n\t\twhile(j>=0&&key<arr[j]){//注意不是和相邻元素比较\n\t\t\tarr[j+1]=arr[j];\n\t\t\tj--;\n\t\t}\n\t\tarr[j+1]=key;\n\t}\n}\n```\n\n# C++斐波那契数列\n\n```C++\nint climbStair(int n){\n\tif(n<=2) return n;\n\tint prev2=1;\n\tint prev1=2;//注意此处的定义是反过来的，上课被坑到了（\n\tint current;\n\tfor(int i=3;i<=n;i++){\n\t\tcurrent=prev1+prev2;\n\t\tprev2=prev1;\n\t\tprev1=current;\n\t}\n\treturn current;\n}\n```\n\n# 汉诺塔问题\n\n```C++\nvoid digui(int n,char start,char temp,char target){\n\tif(n==1){\n\t\tprintf(\"%d:%c-->%c\\n\",n,start,target);//只有一个直接移动\n\t\treturn;\n\t}\n\tdigui(n-1,start,target,temp);//前n-1个到转移柱子上\n\tprintf(\"%d:%c-->%c\\n\",n,start,target);//把第n个移动到目标柱子上\n\tdigui(n-1,temp,start,target);//前n-1个到目标柱子上\n}\n```\n\n# 最大公约数函数\n\n```C++\n#defien ll long long\nll gcd(ll a,ll b){\n\tif(b==0) return a;\n\t//if(a%b==0) return b;\n\treturn gcd(b,a%b);\n}\n//pow返回的是浮点型，注意类型的转换\n```\n# 上机课J题\n\n## 算法原理\n- 这是$Stern–Brocot$ 树,用于生成全部有理数的一种函数\nOI wiki 链接：[Stern–Brocot 树与 Farey 序列 - OI Wiki](https://oi-wiki.org/math/number-theory/stern-brocot/)\n- 首先规定$\\frac{0}{1}$是0,$\\frac{1}{0}$是$\\infty$，接下来每次在他们中间插入它们的中位分数，即$\\frac{a+c}{b+d}$.\n- 其次也可以用三元组来计算这些有理分数，先设定$$\\left(\\frac{0}{1},\\frac{1}{1},\\frac{1}{0}\\right)$$ 为初始状态，然后每一个节点设$$\\left(\\frac{a}{b},\\frac{p}{q},\\frac{c}{d}\\right)$$\n  计算$$\\left(\\frac{a}{b},\\frac{a+p}{b+q},\\frac{c}{d}\\right),\\left(\\frac{a}{b},\\frac{p+c}{q+d},\\frac{c}{d}\\right)$$\n  作为左右节点，有用的部分是计算得到的节点\n## 证明\n\n- 考虑矩阵$$A= \\begin{pmatrix} b & d \\\\ a & c \\end{pmatrix}$$\n- 根是单位阵\n- 左边的节点是乘上矩阵$$L = \\begin{pmatrix} 1 & 1 \\\\ 0 & 1 \\end{pmatrix}$$\n- 右边的节点是乘上$$R = \\begin{pmatrix} 1 & 0 \\\\ 1 & 1 \\end{pmatrix}$$\n- 当然，加入的节点还是原来的算法\n\n- 单调性的话自然成立，可以理解为糖水混合，不会比浓度高的浓，也不会比浓度低的淡\n**然后为什么一定是互质即最简呢？**\n\n根据**裴蜀定理**\n> 设 𝑎,𝑏 是不全为零的整数。那么，对于任意整数 𝑥,𝑦，都有 $gcd(𝑎,𝑏) ∣𝑎𝑥 +𝑏𝑦$ 成立；而且，存在整数 𝑥,𝑦，使得 $𝑎𝑥 +𝑏𝑦 =gcd(𝑎,𝑏)$ 成立。\n\n这里我们取x=y=1，那么就有新的分子分母也互质。","tags":["数学"]},{"title":"定积分笔记","url":"/ZestfulYK-blog/2025/12/10/定积分笔记/","content":"# 定义式\n\n$$\\Sigma_{i=1}^nf(\\xi_i)\\Delta x_i$$\n# 几何意义\n\n曲线和x轴，直线$x=a$,$x=b$围成的面积\n# 用定义式写简单积分\n\n### 例题：\n\n$$\\int_0^1x^2\\,dx$$\n首先先把$[0,1]$分成n等份，每份是$\\frac{1}{n}$\n然后按照定义式，取$x_i=\\frac{i}{n},\\xi_i=\\frac{i}{n}$\n所以：$$\\int_0^1x^2\\,dx=\\Sigma_{i=1}^nf(\\xi_i)\\Delta x_i=\\Sigma_{i=1}^n(\\frac{i}{n})^2·\\frac{1}{n}=\\frac{1}{n^3}\\Sigma_{i=1}^ni^2=\\frac{1}{n^3}\\frac{1}{6}(n+1)(2n+1)=\\frac{n(n+1)(2n+1)}{6n^3}=\\frac{1}{3}$$\n最后记得对n取一下极限就行了\n\n# 把极限改写成积分形式\n\n由于积分是可以转化为极限的，那么同样也可以反过来计算。\n\n## 例题：\n这里需要弄清改把什么看作是$\\xi_i$,什么又看做是$\\Delta x_i$\n不过通常是取相同的数\n- 1.$$\\lim_{n\\to \\infty}\\frac{1}{n}\\Sigma_{i=1}^n\\sqrt{1+\\frac{i}{n}}$$\n然后会有一个非常重要的观察点，必然会有$\\frac{i^a}{n^a}$和$\\frac{a}{n}$出现，这就说明了你划分为n份的范围和每个区间的取值情况。\n\n所以对上面这个式子进行变形得到：$$\\lim_{n\\to \\infty}\\Sigma_{i=1}^n\\frac{1}{n}\\sqrt{1+\\frac{i}{n}}$$\n所以每一份是$\\frac{1}{n}$,每个区间的取值是$\\frac{i}{n}$.\n答案为：$$\\int_0^1\\sqrt{1+x}$$\n但是就一定要这么理解吗？\n实际上，我们也可以把1-2的区间分成n份，那么每一份还是$\\frac{1}{n}$,但是每份的取值变成了$1+\\frac{i}{n}$。\n因此答案也可以是：$$\\int_1^2\\sqrt{x}$$\n\n# 定积分的性质：\n\n## 性质1\n$$\\int_a^bf(x)\\,dx=-\\int_b^af(x)$$\n### 推论\n\n$$\\int_a^af(x)=0$$\n### 解释\n- 代数角度$\\Delta x_i=\\frac{b-a}{n}$所以在上下反转时会变号\n- 几何角度：理解为有向的面积\n## 性质2\n\n$$\\int_a^b\\,dx=b-a$$\n### 解释\n- 相当于一个矩形的面积，宽是1，长是b-a。\n## 性质3 线性性\n\n**此性质又称作不定积分的线性性**\n即满足数乘和加减法\n数乘：\n$$\\int_a^bkf(x)\\,dx=k\\int_a^bf(x)\\,dx$$\n加减法：\n$$\\int_a^bf(x)\\pm g(x)\\,dx=\\int_a^bf(x)\\,dx\\pm\\int_a^bg(x)\\,dx$$\n\n实际上，这个性质可以转换为极限的线性性\n## 性质4 拆分定理\n\n$$\\int_a^bf(x)\\,dx=\\int_a^cf(x)\\,dx+\\int_c^bf(x)\\,dx$$\n实际上，这个公式就是把要计算的面积拆成多个部分\n当位置不一样的时候，也可以看成是减去一部分\n## 性质5 保号性\n\n不定积分的保号性\n如果有在$[a,b]$上$f(x)\\geq0$那么\n$$\\int_a^bf(x)\\,dx\\geq0$$\n其实这又是极限的保号性\n\n然后就有：\n如果$f(x)\\geq g(x)$\n$$\\int_a^bf(x)\\,dx\\geq\\int_a^bg(x)\\,dx$$\n\n## 性质6\n$$\\int_a^bf(x)\\,dx\\leq ∫_a^b|f(x)|\\,dx\\,(a<b)$$\n要证明这个式子，实际上先计算$$-|f(x)|\\leq f(x)\\leq|f(x)|$$各个式子分别积分，然后就能得到上面那个式子了\n\n## 性质7 估值定理\n\n$$m(b-a)\\leq ∫_a^bf(x)\\,dx \\leq M(b-a)$$\n\n实际上，这个式子是对$$m\\leq f(x)\\leq M$$\n分别积分得到的，也可以理解为算了两个矩形的面积\n\n### 应用\n\n通常拿来估计值和计算边界情况\n试证:$$1\\leq ∫_0^{\\frac{\\pi}{2}}\\frac{\\sin ⁡x}{x}\\,d​x \\leq \\frac{\\pi}{2}$$\n首先先把常数换成积分，然后比较积分内的值就行了\n$$\\int_0^{\\frac{\\pi}{2}}\\frac{2}{\\pi}\\leq\\int_0^{\\frac{\\pi}{2}}\\frac{\\sin ⁡x}{x}\\,d​x \\leq \\int_0^{\\frac{\\pi}{2}}\\,dx$$\n这样，问题就被转化为了证明$$\\frac{2}{\\pi}\\leq\\frac{\\sin ⁡x}{x}\\leq 1$$\n## 性质8 积分中值定理\n\n$$\\int_a^bf(x)\\,dx=f(\\xi)(b-a)\\,(\\xi\\in[a,b])$$\n用性质7加上介值定理就能证明了，同时$f(\\xi)$也被称为函数的平均值\n\n### 应用\n\n注意要乘上长度即$(b-a)$这一段\n例如：$$ \\lim_{x\\to\\infty} f(x)=1，求 \\lim_{n\\to\\infty} ∫_{n}^{n+2} x·sin(\\frac{3}{x})·f(x) dx$$\n这里直接中值定理得到：\n$$∫_{n}^{n+2}x\\sin(\\frac{3}{x}) f(x) dx = (n+2-n)\\xi_n sin(\\frac{3}{\\xi}) f(ξ_n)$$\n最后就相当于计算关于$\\xi$的一个极限","tags":["数学"]},{"title":"时空间复杂度笔记","url":"/ZestfulYK-blog/2025/12/09/时空间复杂度笔记/","content":"## 2秒时间限制下的可执行操作数\n### 一般经验估算\n- **保守估计**：C++在2秒内可执行约 $2*10^8-4*10^8$ 次基本操作（加减、比较、赋值等）\n- **实际表现**：\n    - 简单循环操作：约$1*10^8-2*10^8$\n    - 复杂操作（除法、取模、函数调用）：约$0.5*10^8-1*10^8$\n    - 浮点运算：约$0.3*10^8-0.5*10^8$\n### **不同复杂度对应的最大数据规模**\n```txt\nO(1)        -> 几乎无限（>10^9）\nO(logn)     -> 几乎无限（>10^9）\nO(n)        -> 约 2×10^8\nO(nlogn)    -> 约 2×10^7（2000万）\nO(n√n)      -> 约 2×10^6（200万）\nO(n²)       -> 约 2×10^4（2万）\nO(n³)       -> 约 2×10^3（2000）\nO(2ⁿ)       -> 约 n ≤ 25\nO(n!)       -> 约 n ≤ 11\n```\n\n### **实战参考表**\n\n| 数据规模     | 可接受的复杂度         | 常见算法             |\n| -------- | --------------- | ---------------- |\n| n ≤ 10   | 任意（包括O(n!)）     | 全排列、暴力搜索         |\n| n ≤ 20   | O(2ⁿ)           | 子集枚举、状态压缩DP      |\n| n ≤ 100  | O(n³)           | Floyd、简单DP       |\n| n ≤ 1000 | O(n²)           | 二维DP、Dijkstra朴素版 |\n| n ≤ 10^4 | O(n√n)          | 数论分块             |\n| n ≤ 10^5 | O(nlogn)        | 线段树、树状数组、堆       |\n| n ≤ 10^6 | O(n) 或 O(nlogn) | 前缀和、KMP、单调栈      |\n| n ≤ 10^7 | O(n)            | 筛法、线性DP          |\n| n ≤ 10^8 | O(n)（必须常数小）     | 位运算、简单遍历         |\n## **256MB内存限制下的数组大小**\n\n### **不同数据类型可开数组大小**\n\n|数据类型|字节大小|最大元素数|备注|\n|---|---|---|---|\n|bool|1字节|约 2.68亿|实际比赛中常设为 bool 数组|\n|char|1字节|约 2.68亿||\n|int|4字节|约 6700万|常用|\n|long long|8字节|约 3300万||\n|double|8字节|约 3300万||\n|结构体（16字节）|16字节|约 1600万|视具体结构而定|\n```C++\n// 安全范围（考虑程序其他部分占用）\nint arr1[10000000];     // 4000万字节 ≈ 38MB ✅\nint arr2[50000000];     // 2亿字节 ≈ 190MB ✅（接近极限）\n\nint matrix1[5000][5000]; // 1亿字节 ≈ 95MB ✅\nint matrix2[10000][10000]; // 4亿字节 ≈ 381MB ❌（超限）\n\n// 多个数组时需累加\nint arrA[30000000];  // 114MB\nint arrB[30000000];  // 114MB\n// 总计228MB ✅（但接近极限）\n\n// 危险情况\nvector<vector<int>> graph(100000);  // 每个vector开销\n// 虽可能未立即超限，但动态扩展时可能意外超限\n```\n\n### **实用安全上限表**\n\n|数组类型|推荐最大规模|实际内存占用|安全系数|\n|---|---|---|---|\n|一维int数组|≤ 5×10⁷|≤ 200MB|留有余地|\n|一维long long数组|≤ 2.5×10⁷|≤ 200MB||\n|二维int数组[n][m]|n×m ≤ 3×10⁷|≤ 120MB|常用|\n|邻接表（图）|边数 ≤ 2×10⁶|变长，通常安全||\n|位集bitset|≤ 2×10⁸位|≤ 25MB|非常节省|\n\n---\n## **快速判断方法**\n\n### **时间判断口诀**\n\n```txt\nn=10⁵ → 想想O(nlogn)\nn=10⁶ → 必须O(n)或优化常数\nn≤5000 → O(n²)或许可行\nn≤20 → 可能是状压\n```\n\n### **空间判断口诀**\n\n```txt\nint数组：百万级安全，千万级要小心\n二维数组：相乘别超千万\n结构体：注意对齐开销\nSTL容器：额外开销约50%\n```\n","tags":["算法"]},{"title":"容斥原理笔记","url":"/ZestfulYK-blog/2025/12/09/容斥原理笔记-1/","content":"# 容斥原理的定义以及计算方式\n\n- 容斥原理是十分有用的一种计算方法，通常用于子集统计中\n- 该原理通过交替加减不同层次交集的大小，确保每个元素在并集中只被计算一次。虽然描述中的“只被两个集合重复的”可能指恰好属于两个集合的元素，但容斥原理实际处理的是所有交集（包含属于更多集合的元素），并通过后续的加减进行修正。\n- 原理：整体减空白的思想，不过也有韦恩图的一点思想，当子集数量大于3时，就有些抽象了，这时我们就需要总结一下规律。\n# 基本公式\n\n$$|A_1\\cup A_2\\cup ··· \\cup A_n|=\\Sigma|A_i|-\\Sigma|A_i\\cap A_j|+\\Sigma|A_i\\cap A_j\\cap A_k|+(-1)^{n+1}|A_1\\cap A_2 \\cap ···\\cap A_n|$$\n- 先加上所有子集，再减去每两个子集的重叠部分，再加上每三个子集的重叠部分···最后再是所有子集的交集。\n**重要观察**：每一个求和前面的符号只和选择了几个集合有关，所以在写代码的时候就会变得简单了。\n# 代码实现\n\n以题目[Count Good Numbers](https://codeforces.com/problemset/problem/2125/C)为例：\n题目要求我们统计因子里不含2,3,5,7的所有在区间$[l,r]$里的数字总量(翻译成人话)\n那么这不就是容斥原理吗？\n\n```C++\nll count_divisible(ll l, ll r, ll d) {\n    ll first= (l%d==0) ? l : l+d-l%d;  // 第一个能被 d 整除的数\n    ll last=r-r%d;                         // 最后一个能被 d 整除的数\n    if (first>last) return 0;                 // 如果没有这样的数\n    return (last-first)/d+1;\n}\nvoid solve(){\n    ll l,r;\n    cin>>l>>r;\n    int primes[]={2,3,5,7};               // 质数数组\n    ll ans=0;\n    // 枚举所有子集（包括空集），共 2^4 = 16 个\n    for(int mask=0;mask<(1<<4);mask++) {\n        ll d=1;\n        int cnt=0;                           // 子集中质数的个数\n        for(int i=0;i<4;i++){\n            if(mask&(1<<i)){\n                d*=primes[i];\n                cnt++;\n            }\n        }\n        // 根据子集大小的奇偶性决定符号\n        int sign=(cnt%2==0)?1:-1;\n        ans+=sign*count_divisible(l,r,d);\n    }\n    cout<<ans<<endl;\n}\n```\n\n- 主要思想：用二进制模拟是否要取得这一个集合，然后统计二进制中1出现的次数，即选择的集合数，来决定要加还是减。这样就大大减少了代码量，简单可维护性高。\n\n**备注：整体减空白的思想可以看华农的K题来学习，这里就不再列举了**","tags":["算法"]},{"title":"前缀和笔记","url":"/ZestfulYK-blog/2025/12/08/前缀和笔记/","content":"# 前缀和定义\n\n- 前缀和（Prefix Sum）是一种重要的预处理技术，能在**O(1)**时间内查询区间和，在算法竞赛和面试中应用广泛。以下是前缀和的主要应用场景和变种：\n## 1. 基本前缀和\n\n-  计算$\\Sigma_{i=1}^n a_i$的值，用来求区间和\n\n例如：\n```C++\n// 一维前缀和\nvector<int> pre(n+1, 0);\nfor (int i = 1; i <= n; i++) {\n    pre[i] = pre[i-1] + a[i];\n}\n// 查询区间[l, r]的和\nint sum = pre[r] - pre[l-1];\n```\n\n## 2. 二维前缀和\n\n用于计算矩阵的和$\\Sigma_{i=1}^n\\Sigma_{j=1}^na_{ij}$\n\n```C++\nvector<vector<int>> pre(m+1, vector<int>(n+1, 0));\nfor (int i = 1; i <= m; i++) {\n    for (int j = 1; j <= n; j++) {\n        pre[i][j] = a[i][j] + pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1];\n    }\n}\n// 查询子矩阵(x1,y1)-(x2,y2)的和\nint sum = pre[x2][y2] - pre[x1-1][y2] - pre[x2][y1-1] + pre[x1-1][y1-1];\n```\n\n前面两个的例题比较多，则行里就不举例了。\n\n---\n## 3. 前缀和与哈希表结合\n\n这是**最常用的变种**，用于解决\"区间和为k的区间个数\"问题：\n\n```C++\nint countSubarrays(vector<int>& nums,int k) {\n    unordered_map<int,int> mp; // 前缀和 -> 出现次数\n    mp[0] = 1; // 空数组的前缀和为0\n    int sum=0,count=0;\n    // sum拿来求前缀和，count求和为k的次数\n    for(int num:nums){\n        sum+=num;\n        // sum - target = pre[j]  => pre[j] = sum - k\n        if(mp.find(sum-k)!=mp.end())\n            count+=mp[sum-k];\n        mp[sum]++;\n    }\n    return count;\n}\n```\n上面的代码思路解释，首先，先计算前缀和的值，然后加到map里面，之后看有没有出现过sum-k这种前缀和，如果有，那么这一段的和就是k了，且有$mp[sum-k]$个，这样就计算出了答案\n\n例如：[K-大师和他的领域](https://ac.nowcoder.com/acm/contest/123093/K)\n这一题要我们找存在几个区间满足既含有k又满足k是这个区间的中位数。\n那么步骤：\n1.令小于k的为-1，大于k的为1，等于k的为0\n2.计算前缀和，统计前缀和一样的区间，这样区间内的和为0，说明k是这个区间的中位数，再使用$\\Sigma_{i=1}^{map.size()}C_{m_i}^2$计算总数就行了，这样得到可能的区间。\n3.但是还要保证区间内包含k，所以找到k位置，在两个k间的需要再用相同方法计算一次，\n4.最后减去即可\n\n就是说，要统计合法区间时，都可以把题目的要求变形一下，然后就可以使用这个思路了\n\n## 4. 前缀和与差分数组\n\n差分数组用于**区间修改，单点查询**：\n这一个没什么好说的，就是差分和前缀的互逆关系\n\n```C++\n// 初始化差分数组\nvector<int> diff(n+2, 0);\ndiff[1] = a[1];\nfor (int i = 2; i <= n; i++) {\n    diff[i] = a[i] - a[i-1];\n}\n// 区间[l, r]增加val\nvoid rangeAdd(int l, int r, int val) {\n    diff[l] += val;\n    diff[r+1] -= val;\n}\n// 恢复原数组\nfor (int i = 1; i <= n; i++) {\n    a[i] = a[i-1] + diff[i];\n}\n```\n\n## 5. 前缀最大/最小值\n\n```C++\n// 前缀最大值\nvector<int> preMax(n+1, INT_MIN);\nfor (int i = 1; i <= n; i++) {\n    preMax[i] = max(preMax[i-1], a[i]);\n}\n// 后缀最小值\nvector<int> sufMin(n+2, INT_MAX);\nfor (int i = n; i >= 1; i--) {\n    sufMin[i] = min(sufMin[i+1], a[i]);\n}\n```\n\n## 6. 前缀异或和\n\n用于处理区间异或问题：\n\n```C++\nvector<int> xorPre(n+1, 0);\nfor (int i = 1; i <= n; i++) {\n    xorPre[i] = xorPre[i-1] ^ a[i];\n}\n// 区间[l, r]的异或和\nint xorsum = xorPre[r] ^ xorPre[l-1];\n```\n\n## 7.二维差分数组\n\n```C++\n// 初始化二维差分\nvector<vector<int>> diff(m+2, vector<int>(n+2, 0));\n// 子矩阵(x1,y1)-(x2,y2)增加val\nvoid rangeAdd2D(int x1, int y1, int x2, int y2, int val) {\n    diff[x1][y1] += val;\n    diff[x2+1][y1] -= val;\n    diff[x1][y2+1] -= val;\n    diff[x2+1][y2+1] += val;\n}\n// 恢复原矩阵\nvector<vector<int>> res(m+1, vector<int>(n+1, 0));\nfor (int i = 1; i <= m; i++) {\n    for (int j = 1; j <= n; j++) {\n        res[i][j] = res[i-1][j] + res[i][j-1] - res[i-1][j-1] + diff[i][j];\n    }\n}\n```\n\n然后很重要的一点是，有时可能是假设前缀和数组，最后再反推原数组来进行构造。","tags":["算法"]},{"title":"ACM训练","url":"/ZestfulYK-blog/2025/12/07/ACM训练题目解析/","content":"# 简单题\n\n- 对于简单题目，最好还是仔细一点，或者使用最暴力的解法，而不是投机取巧，或者构造高级方法，通常样例数据都是片面的，常常会有坑。\n\n[sleeping through classes](https://codeforces.com/contest/2173/problem/A)\n\n比如这一题，数据没有包含i+k中间有1的情况，直接i+=k导致错误。\n\n\n# 中等题目\n\n- 中等题目就需要强观察力和trick技巧了\n\n[Niko's Tactical Cards](https://codeforces.com/contest/2173/problem/B)\n\n这一道题目是动态规划的变种，虽然要求每一步最优，但是可能发生最小值突然转变成最大值的情况，因此，计算最小值也是必要的。只要计算这两个值就行了。\n\n[Kanade's Perfect Multiples](https://codeforces.com/contest/2173/problem/C)\n\n这题希望我们构造一个满足要求的B，这个就有点类似于筛法求素数了，实际上两者的代码几乎是一样的，但是在做的时候要注意区分原始数据和v数组，一个一个遍历就行了，找不到就可以直接退出，因为不然当前确定的最小值就无法被覆盖了。\n\n[Merging the Sets](https://codeforces.com/problemset/problem/2146/B)\n\n你想选择其中的一些集合（可能一个都不选，也可能全部都选），使得 1 和 m 之间的每个整数都包含在**个所选集合中的至少一个**中。\n思维误区，不用一边读入一边判断，因为数据保证$l\\leq 2*10^5$所以先读入再判断就行了，此外，要方法合法需要这个集合不存在也合法，那么只要用桶来看看去掉会不会变0就行了。原先想到的覆盖才合法的思路不对的原因是前后都有可能覆盖。\n\n[Abraham's Great Escape](https://codeforces.com/problemset/problem/2155/B)\n\n要求构造一个方阵，每个位置一个箭头，满足有k个格子能沿箭头出去。\n其实只要管最后一行，前面k个填U，后面的填D，最后一行填$RRR……RL$就行了\n比如：\n```C++\n1\n9 4\nUUU\nUDD\nRRL\n```\n这样在最后一行产生循环，前面的不管。原来的做法是两个两个组合，产生循环，虽然也能做，但是不方便。\n\n[Cake Assignment](https://codeforces.com/problemset/problem/2138/A)\n\n这个题目的重要观察点是，当最后一步确定后，上一步的操作一定是确定的，于是我们就可以倒推\n\n[XOR Array](https://codeforces.com/contest/2175/problem/B)\n\n这题的要求是构造一个数组，满足仅在l到r上的异或和为0，其他位置全非0，\n异或有一个特点，和前缀和一样，可以构建前缀异或和，因为$x\\oplus y \\oplus x==x$\n此外非常容易陷入的一个点是，可能会想到之间填入1-n来构造，但是实际上，这么异或会产生很多的0，所以这个方法是不行的。（比如1，2，3）\n因此，这里我们的操作是构造最终异或的结果，写一个前缀异或数组，最后再反推原数组就行了。\n详细信息可以见异或的笔记部分","tags":["算法"]},{"title":"DP笔记","url":"/ZestfulYK-blog/2025/12/07/DP学习笔记/","content":"# DP题目的特点\n\n- 数据较小，至少有一维是可以接受的，比如每一步的决策小于3，总数小于1000等等\n- 每一步的答案可以由之前的答案得到，比如数字三角形\n\n# DP题目的大致做法\n\n## 设DP数组\n\n- 明确DP数组的含义，保证每次求解的答案都是这个含义，不然就可能出错\n(这也是我之前的一大误区)\n\n## 分类讨论\n\n- 明确有几种决策方案，**明确这一步的答案是怎么推断出来的(非常重要!!!)**\n\n接下来编写代码就行了\n\n## 举例：迎新赛M题\n\n- 题目传送门：\n\n> [ZJUTOJ | 2024ZJUT迎新赛-决赛-M. 三色小屋](http://www.zjutacm.cn/problem/3118)\n\n### 题目理解：\n\n- 首先发现每一步的方案数可以接受，并且这一步的答案只由上一步转移而来，所以可以使用DP\n- 每个位置只能填R/G/B三种颜色，而且之和上一步和相邻的颜色有关，几种方案互不影响，符合动态规划的特点\n### 分类讨论：\n\n- 分为两大类，因为开头要初始化，所以单独讨论\n\n\n\n$$\ndp[i][j] = \n\\begin{cases}\ni==1\\begin{cases}\n\tc[i]==\\ '0' & \\text{可以用的颜色为1} \\\\\n\tc[i]\\ !=\\ \\ '0' & \\text{这个颜色为1}\n\\end{cases}\\\\ \\\\\ni\\ !=1\\begin{cases}\n\tc[i]==\\ '0' & \\text{可以填入的颜色为前两个的和} \\\\\n\tc[i] \\ !=\\ \\ '0' & \\text{这个颜色为前两个的和}\n\\end{cases}\n\\end{cases}\n$$\n\n## DP概率题\n\n### 求期望的几个重要公式\n\n$$\\begin{aligned}\nE(aX+b)=aE(x)+b \\\\ \\\\\nE(X+Y)=E(X)+E(Y)\\\\ \\\\\nE(XY)=E(X)E(Y)\n\\end{aligned}$$\n- 上面两个说明了期望的线性关系，下面两个说明了期望的独立性","tags":["算法"]},{"title":"有理函数积分","url":"/ZestfulYK-blog/2025/12/07/不定积分笔记2（有理函数和部分积分）/","content":"# 基本方法\n\n- 凑成能第一类换元积分的式子\n\t例如$\\frac{1}{...}$类的\n部分分式分解\n## 有理函数积分适用条件\n- 1. 有理函数积分\n当被积函数是**有理函数**（两个多项式的商）时：$\\int \\frac{Q(x)}{P(x)}\\,​dx$\n其中 $P(x)$ 和 $Q(x)$ 都是多项式。\n- 2. 分母可因式分解\n\n部分分式分解是处理**有理函数积分**的**系统方法**，特别适用于：\n- 分母可明确因式分解\n- 没有更简单的特殊技巧\n- 需要精确解析表达式\n\n当分母 $Q(x)$ 可以分解为**一次因式**和**不可约二次因式**的乘积时：\n- **一次因式**：$(x-a)$\n- **不可约二次因式**：$(x^2+px+q)$，其中 $p^2-4q<0$\n#### 具体分解规则\n##### 对于一次因式 $(x-a)^k$：\n\n对应部分为：\n$$\\frac{A_1}{x-a}+\\frac{A_2}{(x-a)^2}+···+\\frac{A_k}{(x-a)^k}$$\n##### 对于二次因式 $(x^2+px+q)^m$：\n\n$$\\frac{B_1x+C_1}{x^2+px+q}+\\frac{B_2x+C_2}{(x^2+px+q)^2}+···+\\frac{B_mx+C_m}{(x^2+px+q)^k}$$\n\n但是，在这个部分有一种特殊情况，就是二次式:\n$$\\int \\frac{P(x)}{Q(x)^2}$$\n>在这里，可以把函数看成$\\frac{d}{dx}\\frac{Ax+B}{Q(x)}+\\frac{C}{Q(x)}$两种方法实际上是等价的，因为最后必然化成一个简单的倒数积分和简单的分数积分$\\frac{1}{Q(x)}$。\n\n### 例子：\n- 计算$\\int \\frac{x^2+1}{(x^2+x+1)^2}\\,dx$有两种方式，都能得到答案。\n1.用标准公式计算\n得到:\n$$\\int \\frac{x}{(x^2+x+1)^2}\\,dx-\\int \\frac{1}{x^2+x+1}\\,dx$$\n\n接着再分别计算前后的积分，前面得到的是一个分式加上一个含$\\arctan x$的式子\n比较麻烦，不过对于这类题目，我们知道一定能得到第二种简单的方法的式子，所以经过计算\n得到:\n$$\\frac{1}{3}\\frac{d}{dx}\\frac{x+2}{x^2+x+1}-\\frac{4}{3}\\int · \\frac{1}{x^2+x+1}\\,dx$$\n这种解法的好处是，得到前半段以后可以直接当作积分结果，不需要额外的处理。\n#### 判断步骤\n##### 第一步：检查是否为真分式\n- 如果 $\\deg P(x) \\geq \\deg Q(x)$：先进行**多项式除法**（大除法）\n- 如果 $\\deg P(x) < \\deg Q(x)$：直接进行部分分式分解\n 就是说最高项次数小就能用这个方法\n##### 第二步：因式分解分母\n将分母 $Q(x)$ 完全分解为：\n- 一次因式 $(x-a_i)^{k_i}$\n- 不可约二次因式 $(x^2+p_jx+q_j)^{m_j}$\n##### 第三步：确定分解形式\n根据因式分解结果，写出部分分式的**一般形式**。\n在计算过程中，可以通过给x赋值来快速计算带定值\n\n#### 具体例子分析\n\n##### 例1：$\\int \\frac{x^3+1}{(x^2+1)^2} dx$\n\n- 分母：$(x^2+1)^2$（二次因式的平方）\n- 分解形式：$\\frac{Ax+B}{x^2+1} + \\frac{Cx+D}{(x^2+1)^2}$\n\n##### 例2：$\\int \\frac{1}{x(x-1)^2} dx$\n\n- 分母：$x(x-1)^2$（一次因式及其平方）\n- 分解形式：$\\frac{A}{x} + \\frac{B}{x-1} + \\frac{C}{(x-1)^2}$\n\n##### 例3：$\\int \\frac{x^2+1}{x(x^2+4)} dx$\n\n- 分母：$x(x^2+4)$（一次因式 + 二次因式）\n- 分解形式：$\\frac{A}{x} + \\frac{Bx+C}{x^2+4}$\n\n**例4：**$\\int \\frac{x+1}{x^2+4x+6}\\,dx$\n这个题目看起来和裂项十分相似，但是分母无法因式分解，所以这个方法是不对的。\n注意到这里上方的次数正好是分母求导结束后的次数，所以游客能采取分开计算的方法。\n这里首先先把上面的分析翻倍，（因为分母的导数是$2x+4$），接下来在加一个2，减一个2外面再配上$\\frac{1}{2}$即可。\n所以式子变为:$\\frac{1}{2} \\int \\frac{2x+4-2}{x^2+4x+6}\\,dx$然后两个部分正好都是我们能计算的第一类换元积分，完成！\n\n- $\\int \\frac{f'(x)}{f(x)} dx$：直接得到 $\\ln|f(x)|$\n- $\\int \\frac{1}{x^2+a^2} dx$：直接得到 $\\frac{1}{a}\\arctan\\frac{x}{a}$\n\n## 个人技巧\n\n- 对于一般的式子，通常是去凑积分，先对其1次项，再分离常数项，这样就能直接得到一个ln积分和一个形如$\\frac{p}{t^2+a^2}$的式子了，这个是很好积分的($\\arctan x$)\n- 遇到三次式子，可能配凑一个$\\pm 1$来计算\n- 遇到分母次数很高的，考虑倒代换\n- 其余的式子，直接展开就行了\n\n## 三角代换部分\n\n### 重要公式\n当取$\\tan x=u$时\n$$\\begin{cases}\n\\sin x=\\frac{u}{\\sqrt{1+u^2}} \\\\\n\\cos x=\\sqrt{1+u^2}\n\\end{cases}\n$$\n\n当取$\\tan \\frac{x}{2}=u$时\n$$\\begin{cases}\n\\sin x=\\frac{2u}{1+u^2} \\\\\n\\cos x=\\frac{1-u^2}{1+u^2}\n\\end{cases}\n$$\n\n然后不要忘记，第二类换元积分是需要乘上对应的导数的，**这个导数是t关于x的函数**，乘上的是含有t的导数\n之后像前面一样计算就行了。\n\n#### 题型分类\n- 只含有一种三角函数的，用第一类换元积分，例如：$\\int \\frac{1}{\\sin x^4}\\,dx$\n- 上下均有且为一次式的，用上节课的方法代换，例如$\\int \\frac{\\sin x}{\\sin x+\\cos x}\\,dx$\n- 同名三角函数相加，和差化积，例如$\\int \\frac{1}{\\sin x+\\sin 3x}\\,dx$\n- 正常幂(不含分母的)，按奇偶正常拆分\n- 分母含有高次项的，拆解1，例如$\\int \\frac{1}{\\sin x\\cos x^2}$\n主要是把$\\cos x$化成$\\tan x$来计算。\n例如：1$$\\int \\frac{dx}{a^2+\\sin x^2+b^2+\\cos x^2}=\\int \\frac{\\frac{1}{\\cos x^2}}{a^2\\tan x^2+b^2}\\,dx=\\int \\frac{1+\\tan x^2}{a^2\\tan x^2+b^2}\\,dx$$\n## 根式的代换\n\n### 重要公式\n\n令$$t=\\sqrt[n]{ax+b}$$\n令$$t=\\sqrt[n]{\\frac{ax+b}{cx+d}}$$\n令$$t=\\sqrt[mn]{ax+b}$$\n看含有什么来决定怎么设t\n最后反解出x带入其余部分即可。\n\n### 重要例题根式代换类型\n\n求下面这个函数的积分\n$$\\int \\frac{dx}{\\sqrt[n]{(x-a)^{n+1}(x-b)^{n-1}}}\\,dx$$\n方法：先提取部分，构造类似上面2的一个式子，然后再考虑代换。\n$$\\text{原式}=\\int\\frac{1}{(x-a)(x-b)\\sqrt[n]{\\frac{x-a}{x-b}}}\\,dx$$\n不过接下来直接解出x再带回比较麻烦，所以考虑直接算出$\\frac{dx}{(x-a)(x-b)}$这个部分\n$$t^n=\\frac{a-b}{(x-b)^2}$$\n$$\\frac{nt^n\\,dt}{t}=\\frac{a-b}{(x-b)^2}\\,dx$$\n$$\\frac{n\\,dt}{t}=\\frac{a-b}{(x-b)^2t^n}\\,dx=\\frac{a-b}{(x-a)(x-b)}\\,dx$$\n所以得到原式变为：\n$$-\\frac{n}{a-b}\\sqrt[n]{\\frac{x-b}{x-a}}$$\n## 重要例题偶数次幂分数类型\n\n方法是化为平方分之括号内函数的导数\n即：\n$$\\int \\frac{f'(x)}{f(x)^2+a}$$\n例如：\n$$\\int \\frac{1}{x^4+1}\\,dx=\\frac{1}{2}\\int\\frac{1+\\frac{1}{x^2}-1}{x^2+\\frac{1}{x^2}}=\\frac{1}{2}(\\int \\frac{d x-\\frac{1}{x}}{(x-\\frac{1}{x})^2+2}+\\int \\frac{d x+\\frac{1}{x}}{(x+\\frac{1}{x})^2+2})$$$$=\\frac{1}{2\\sqrt{2}}\\arctan \\frac{x-\\frac{1}{x}}{\\sqrt{2}}-\\frac{1}{4\\sqrt{2}}\\ln|\\frac{x^2-\\sqrt{2}x+1}{x^2+\\sqrt{2}x+1}|$$\n 所以类似于$\\frac{\\text{二次}}{\\text{四次}}$的式子，理论上都有可能用这种方式解决","tags":["数学"]},{"title":"第一类换元积分","url":"/ZestfulYK-blog/2025/12/07/不定积分笔记/","content":"\n## 重要公式\n\n#### 基本积分公式：\n\n**不要忘记加C!!!**\n\n$\\xi \\ \\delta \\ \\alpha \\ \\beta \\ \\pi \\  \\theta \\ \\in \\ \\notin$\n$\\Delta$\n\n$\\int k \\, dx = kx + C$\n$\\int x^n \\, dx = \\frac{x^{n+1}}{n+1} + C \\quad (n \\neq -1)$\n$\\int \\frac{1}{x} \\, dx = \\ln|x| + C$\n\n- 指数函数：\n$\\int e^x \\, dx = e^x + C$\n$\\int a^x \\, dx = \\frac{a^x}{\\ln a} + C$\n\n- 三角函数：\n$\\int \\sin x \\, dx = -\\cos x + C$\n$\\int \\cos x \\, dx = \\sin x + C$\n$\\int \\tan x \\, dx = -\\ln|\\cos x| + C$\n$\\int \\cot x \\, dx = \\ln|\\sin x| + C$\n$\\int \\sec^2 x \\, dx = \\tan x + C$\n$\\int \\csc^2 x \\, dx = -\\cot x + C$\n$\\int \\sec x \\tan x \\, dx = \\sec x + C$\n$\\int \\csc x \\cot x \\, dx = -\\csc x + C$\n$\\int secx\\,dx= ln|secx+tanx|+C$\n$\\int cscx\\,dx= ln|cscx-cotx|+C$\n\n\n- 反三角函数：\n$\\int \\frac{1}{\\sqrt{1-x^2}} \\, dx = \\arcsin x + C$\n$\\int \\frac{1}{1+x^2} \\, dx = \\arctan x + C$\n\n- 双曲函数：\n$\\int \\sinh x \\, dx = \\cosh x + C$\n$\\int \\cosh x \\, dx = \\sinh x + C$\n\n- 特殊积分：\n$\\int \\frac{1}{x^2+a^2} \\, dx = \\frac{1}{a}\\arctan\\frac{x}{a} + C$\n$\\int \\frac{1}{\\sqrt{a^2-x^2}} \\, dx = \\arcsin\\frac{x}{a} + C$\n$\\int \\frac{1}{x^2-a^2} \\, dx = \\frac{1}{2a}\\ln\\left|\\frac{x-a}{x+a}\\right| + C$\n\n- 和差化积公式：\n$\\sin A + \\sin B = 2 \\sin\\left(\\frac{A+B}{2}\\right) \\cos\\left(\\frac{A-B}{2}\\right)$\n$\\sin A - \\sin B = 2 \\cos\\left(\\frac{A+B}{2}\\right) \\sin\\left(\\frac{A-B}{2}\\right)$\n$\\cos A + \\cos B = 2 \\cos\\left(\\frac{A+B}{2}\\right) \\cos\\left(\\frac{A-B}{2}\\right)$\n$\\cos A - \\cos B = -2 \\sin\\left(\\frac{A+B}{2}\\right) \\sin\\left(\\frac{A-B}{2}\\right)$\n\n- 积化和差公式：\n$\\sin A \\cos B = \\frac{1}{2}[\\sin(A+B) + \\sin(A-B)]$\n$\\cos A \\sin B = \\frac{1}{2}[\\sin(A+B) - \\sin(A-B)]$\n$\\cos A \\cos B = \\frac{1}{2}[\\cos(A+B) + \\cos(A-B)]$\n$\\sin A \\sin B = -\\frac{1}{2}[\\cos(A+B) - \\cos(A-B)]$\n\n#### 对部分公式的推导：\n\n$\\int \\tan x \\, dx = -\\ln|\\cos x| + C$\n$\\int \\tan x \\, dx = \\int \\frac{sinx}{cosx} \\,dx = - \\int \\frac{dcosx}{sinx} \\, = -ln|cosx|+ C$\n\n- 对于 $\\int cotx$ 同理\n### 小技巧：\n\n- $sinx^m cosx^n$之类的，奇数的话拆一个进去积分，偶数的话用倍角或半角公式\n- 在对$\\int tanx\\,dx$或者$\\int secx\\,dx$等方法一样，可以类比\n\n奇数如$\\int sin^3 \\, dx$或者$\\int sin^3cosx\\,dx$等\n比如$\\int sinx^3\\,dx=-\\int sinx^2\\,dcosx=-\\int(1-cos^2x)\\,dcosx$\n$=-cosx+\\frac{1}{3}cosx^3+C$\n\n偶数如$\\int cosx^4\\,dx$等\n比如$\\int cosx^4\\,dx=\\int(\\frac{1+cos2x}{2})^2\\,dx=\\frac{1}{4}\\int1+cos2x^2+2cos2x\\,dx$\n$=\\frac{1}{4}(x+\\frac{1}{2}\\int cos2x^2\\,d2x+\\int cos2x\\,d2x)+C$\n$=\\frac{1}{4}(x+sin2x+\\frac{1}{2}\\int \\frac{1+cos4x}{2}\\,d2x)+C$\n$=\\frac{1}{4}(x+sin2x+\\frac{1}{8} \\int(1+cos4x)\\,d4x)+C$\n$=\\frac{1}{4}(x+sin2x+\\frac{1}{8}(4x+sin4x))+C$\n$=\\frac{3}{8}x+\\frac{1}{4}sin2x+\\frac{1}{32}sin4x+C$\n\n- 对于$\\frac{...+...}{...}$类的可能是把上面的式子拆成两个分别计算\n例如：$\\int \\frac{1+x}{\\sqrt{2-3x^2}}\\,dx$\n$=\\int \\frac{1}{\\sqrt{2-3x^2}}\\,dx+\\int \\frac{x}{\\sqrt{2-3x^2}}\\,dx$\n\n- 要熟记各种三角函数的导数和公式以及转换关系：\n $secx^2-1=tanx^2$\n $cscx^2-1=cotx^2$\n$$arctan(\\frac{1}{x})=\\begin{cases}\narccot(x)\\ \\ \\ \\ \\ \\ \\ \\ \\ x>0\\\\\narccot(x)-\\pi  \\ \\ x<0\n\\end{cases}$$\n#### 裂项计算积分\n注意，在第一类换元积分中，我们的计算只能处理$\\int \\frac{1}{ax+b}\\,dx$类的积分，所以，要变成分子是分母的导数的倍数的形式，（用$\\ln |x|$）来处理每一个分式。通常分母会是一个能因式分解的式子，然后要根据分母的形式来决定分子被写成什么样。\n例如:$\\int \\frac{x}{x^2-3x-4}\\,dx$\n这里我们首先对下面的式子进行因式分解，得到:$\\int \\frac{x}{(x-4)(x+1)}\\,dx$\n接下来我们来根据分母决定分子，应为分母是一次式子，所以分子应该对应常数，所以经过凑得到如下结果：$$\\frac{1}{5}\\int \\frac{4}{x-4}+\\frac{1}{x+1}\\,dx$$\n那么我们就能计算积分啦~\n\n### \n#### 含有 $\\sin x + \\cos x$ 的分母的积分\n\n对于含有 $\\sin x + \\cos x$ 的分母的积分，有一种类似于部分分式分解的方法。\n对于形如 $\\int \\frac{a\\sin x + b\\cos x}{c\\sin x + d\\cos x} dx$ 的积分，我们可以使用**线性组合法**，其核心思想是：\n\n**将被积函数的分子表示为分母和分母导数的线性组合**。\n**第一类积分实际上就是把前面的放到d里面，再除以对应的倒数即可**\n\n对于一般形式 $\\int \\frac{a\\sin x + b\\cos x}{c\\sin x + d\\cos x} dx$：\n\n1. 设 $D(x) = c\\sin x + d\\cos x$，$D'(x) = c\\cos x - d\\sin x$\n2. 解方程组：\n$$\\begin{cases} a=Ac-Bd \\\\\nb=Ad+Bc\n\n\\end{cases}$$\n求出 $A$ 和 $B$\n 积分变为：$$A\\int1dx+B\\int \\frac{D'(x)}{D(x)}\\,dx=Ax+Bln|D(x)|+C$$\n 对于更复杂的情况，如分母含有 $\\sin^2 x$、$\\cos^2 x$ 或 $\\sin x \\cos x$，可以使用：\n\n- 万能代换 $t = \\tan\\frac{x}{2}$\n- 三角恒等式化简\n- 配对积分法（如本文开始所示）\n\n\n\n- 我的通常做法是看被积函数有什么部分的导数在这里面出现过，然后提取这个部分\n\n例子：$\\int \\frac{1+lnx}{(xlnx)^3}\\,dx$\n\n下面的导数就是上面那一部分，所以直接提取就行了，按照我的逻辑来看，就是除去这个导数\n这两种理解方式实际上是一样的\n\n---\n## 第二类换元积分\n\n**第二类换元积分实际上就是把下换成t的代数式子再乘上这个式子的导数**\n**不要忘记乘以对应的倒数!!!**\n \n### 第二类换元积分法常用公式：\n\n- 三角代换：\n1. 含有 $\\sqrt{a^2-x^2}$，令 $x = a\\sin t$，则 $dx = a\\cos t\\, dt$\n   $\\int \\frac{1}{\\sqrt{a^2-x^2}} dx = \\arcsin\\frac{x}{a} + C$\n\n2. 含有 $\\sqrt{a^2+x^2}$，令 $x = a\\tan t$，则 $dx = a\\sec^2 t\\, dt$\n   $\\int \\frac{1}{\\sqrt{a^2+x^2}} dx = \\ln|x+\\sqrt{x^2+a^2}| + C$\n\n3. 含有 $\\sqrt{x^2-a^2}$，令 $x = a\\sec t$，则 $dx = a\\sec t\\tan t\\, dt$\n   $\\int \\frac{1}{\\sqrt{x^2-a^2}} dx = \\ln|x+\\sqrt{x^2-a^2}| + C$\n\n- 根式代换：\n1. 含有 $\\sqrt{ax+b}$，令 $t = \\sqrt{ax+b}$，则 $x = \\frac{t^2-b}{a}$，$dx = \\frac{2t}{a} dt$\n\n2. 含有 $\\sqrt[n]{ax+b}$，令 $t = \\sqrt[n]{ax+b}$，则 $x = \\frac{t^n-b}{a}$，$dx = \\frac{nt^{n-1}}{a} dt$\n\n- 倒代换：\n对于形如 $\\int \\frac{1}{x\\sqrt{ax^2+bx+c}} dx$ 等积分，可令 $x = \\frac{1}{t}$，则 $dx = -\\frac{1}{t^2} dt$\n\n- 欧拉代换：\n1. 对于 $\\sqrt{ax^2+bx+c}$，当 $a>0$ 时，令 $\\sqrt{ax^2+bx+c} = t-\\sqrt{a}x$\n2. 当 $c>0$ 时，令 $\\sqrt{ax^2+bx+c} = tx+\\sqrt{c}$\n\n- 万能代换：\n对于三角有理式 $\\int R(\\sin x, \\cos x) dx$，令 $t = \\tan\\frac{x}{2}$，则\n$\\sin x = \\frac{2t}{1+t^2}$，$\\cos x = \\frac{1-t^2}{1+t^2}$，$dx = \\frac{2}{1+t^2} dt$\n\n- 双曲代换：\n1. 含有 $\\sqrt{x^2+a^2}$，令 $x = a\\sinh t$，则 $dx = a\\cosh t\\, dt$\n2. 含有 $\\sqrt{x^2-a^2}$，令 $x = a\\cosh t$，则 $dx = a\\sinh t\\, dt$\n\n- 常用结论：\n$\\int \\sqrt{a^2-x^2} dx = \\frac{x}{2}\\sqrt{a^2-x^2} + \\frac{a^2}{2}\\arcsin\\frac{x}{a} + C$\n$\\int \\sqrt{a^2+x^2} dx = \\frac{x}{2}\\sqrt{a^2+x^2} + \\frac{a^2}{2}\\ln|x+\\sqrt{x^2+a^2}| + C$\n$\\int \\sqrt{x^2-a^2} dx = \\frac{x}{2}\\sqrt{x^2-a^2} - \\frac{a^2}{2}\\ln|x+\\sqrt{x^2-a^2}| + C$\n\n\n---\n\n### 重要例题\n#### 积分 $\\int \\frac{1}{x\\sqrt{x^2+1}} dx$ 的两种解法\n\n###### 方法一：三角代换\n\n令 $x = \\tan t$，则：\n- $dx = \\sec^2 t\\, dt$\n- $\\sqrt{x^2+1} = \\sqrt{\\tan^2 t + 1} = \\sec t$\n\n代入原积分：\n$$\\int \\frac{1}{x\\sqrt{x^2+1}} dx = \\int \\frac{1}{\\tan t \\cdot \\sec t} \\cdot \\sec^2 t\\, dt = \\int \\frac{\\sec t}{\\tan t} dt$$\n\n化简：\n$$\\int \\frac{\\sec t}{\\tan t} dt = \\int \\frac{\\frac{1}{\\cos t}}{\\frac{\\sin t}{\\cos t}} dt = \\int \\frac{1}{\\sin t} dt = \\int \\csc t\\, dt$$\n\n利用公式：\n$$\\int \\csc t\\, dt = \\ln|\\csc t - \\cot t| + C$$\n\n将变量换回 $x$：\n- $\\csc t = \\frac{\\sqrt{x^2+1}}{x}$\n- $\\cot t = \\frac{1}{x}$\n\n最终结果：\n$$\\int \\frac{1}{x\\sqrt{x^2+1}} dx = \\ln\\left|\\frac{\\sqrt{x^2+1}-1}{x}\\right| + C$$\n\n##### 方法二：倒代换\n\n令 $x = \\frac{1}{t}$，则：\n- $dx = -\\frac{1}{t^2} dt$\n- $\\sqrt{x^2+1} = \\sqrt{\\frac{1}{t^2}+1} = \\frac{\\sqrt{1+t^2}}{|t|}$\n\n代入原积分（假设 $t>0$，即 $x>0$）：\n$$\\int \\frac{1}{x\\sqrt{x^2+1}} dx = \\int \\frac{1}{\\frac{1}{t} \\cdot \\frac{\\sqrt{1+t^2}}{t}} \\cdot \\left(-\\frac{1}{t^2}\\right) dt = -\\int \\frac{1}{\\sqrt{1+t^2}} dt$$\n\n利用公式：\n$$\\int \\frac{1}{\\sqrt{1+t^2}} dt = \\ln|t+\\sqrt{1+t^2}| + C$$\n\n代入 $t = \\frac{1}{x}$：\n$$-\\ln\\left|\\frac{1}{x}+\\sqrt{1+\\frac{1}{x^2}}\\right| + C = -\\ln\\left|\\frac{1+\\sqrt{x^2+1}}{x}\\right| + C$$\n\n化简：\n$$-\\ln\\left|\\frac{1+\\sqrt{x^2+1}}{x}\\right| = \\ln\\left|\\frac{x}{1+\\sqrt{x^2+1}}\\right| = \\ln\\left|\\frac{x(\\sqrt{x^2+1}-1)}{x^2}\\right| = \\ln\\left|\\frac{\\sqrt{x^2+1}-1}{x}\\right|$$\n\n最终结果：\n$$\\int \\frac{1}{x\\sqrt{x^2+1}} dx = \\ln\\left|\\frac{\\sqrt{x^2+1}-1}{x}\\right| + C$$\n\n###### 结论\n\n两种方法得到相同的结果：\n$$\\int \\frac{1}{x\\sqrt{x^2+1}} dx = \\ln\\left|\\frac{\\sqrt{x^2+1}-1}{x}\\right| + C$$\n\n三角代换思路直接，倒代换计算简洁，两种方法都有效解决此类积分问题。\n\n#### 积分$\\int x^2(2x-3)^{10}\\,dx$的计算\n\n- 直接换元，这里不适合分步积分\n令$t=2x-3$来简化计算。然后就发现可以展开这个式子了。\n\n\n\n---\n### 什么时候可以统一结果？\n\n**在以下情况下，可以将负号放到三角函数中统一结果：**\n\n1. **当三角函数在某个区间内保持相同符号时**\n    \n    - 对于 $\\sqrt{x^2 - a^2}$，使用 $x = a\\sec\\theta$\n        \n    - 对于 $\\sqrt{a^2 - x^2}$，使用 $x = a\\sin\\theta$ 或 $x = a\\cos\\theta$\n        \n    - 对于 $\\sqrt{x^2 + a^2}$，使用 $x = a\\tan\\theta$\n        \n2. **选择的角范围要保证：**\n    \n    - 代换函数是单调的（便于反函数存在）\n        \n    - 根号内的表达式化简后不产生绝对值\n        \n3. **常见的选择：**\n    \n    - $\\sqrt{x^2 - a^2}$：$\\theta \\in (0, \\pi/2) \\cup (\\pi, 3\\pi/2)$\n        \n    - $\\sqrt{a^2 - x^2}$：$\\theta \\in (-\\pi/2, \\pi/2)$\n        \n    - $\\sqrt{x^2 + a^2}$：$\\theta \\in (-\\pi/2, \\pi/2)$\n\n此外含有$e^x$式子有特殊的计算技巧。\n例如：$$\\int \\frac{1}{e^x+1}\\,dx=\\int \\frac{e^{-x}}{e^{-x}+1}\\,dx$$\n从而实现第一类换元积分。","tags":["数学"]},{"title":"分步积分笔记","url":"/ZestfulYK-blog/2025/12/07/分步积分/","content":"\n## 核心公式\n$$\\int u\\,dv = uv - \\int v\\,du$$\n\n## 选择原则：\"反对幂指三\"\n优先级从高到低选择 $u$：\n- **反**三角函数（$arcsin$,$arccos$, $arctan$等）\n- **对**数函数（$\\ln x$, $log x$等）\n- **幂**函数（$x^n$, $x^2$, $\\sqrt{x}$等）\n- **指**数函数（$e^x$, $a^x$等）\n- **三**角函数（$\\sin x$, $\\cos x$等）\n\n**口诀解释**：越靠前的类型越优先选为 $u$，越靠后的类型越优先放入 $dv$。\n\n---\n\n## 经典类型与解法\n\n### 类型1：幂函数 × 三角函数\n$\\int x^n\\cos x\\,dx$ 或 $\\int x^n\\sin x\\,dx$\n- 将三角函数放入 $dv$（如 $\\cos x\\,dx = d(\\sin x)$）\n- 通过 $n$ 次分部积分逐次降幂\n\n### 类型2：幂函数 × 指数函数\n$\\int x^n e^{ax}\\,dx$\n- 将指数函数放入 $dv$（如 $e^{ax}\\,dx = \\frac{1}{a}d(e^{ax})$）\n- 逐次降幂至 $x^0$\n\n### 类型3：幂函数 × 对数函数\n$\\int x^n \\ln x\\,dx$\n- 将对数函数选为 $u$（$\\ln x$ 求导得 $\\frac{1}{x}$，可消去 $x$ 幂）\n- 幂函数放入 $dv$\n\n### 类型4：指数函数 × 三角函数\n$\\int e^{ax}\\sin(bx)\\,dx$ 或 $\\int e^{ax}\\cos(bx)\\,dx$\n- 任选其一放入 $dv$（通常选三角函数）\n- 两次分部积分后出现循环，解方程求得原积分\n\n---\n\n## 高级技巧与注意事项\n\n### 技巧1：隐藏的 $dv$\n当被积函数为分式时，常将分母或其部分放入 $dv$：\n$$\\int \\frac{x\\arcsin x}{\\sqrt{1-x^2}}\\,dx$$\n令 $u=\\arcsin x$，$dv=\\frac{x}{\\sqrt{1-x^2}}dx$，则 $v=-\\sqrt{1-x^2}$\n\n### 技巧2：凑微分调整\n对于 $\\int \\frac{x}{e^{2x}}\\,dx$，可改写为 $\\int x e^{-2x}\\,dx$\n- 令 $u=x$，$dv=e^{-2x}dx$\n- 则 $du=dx$，$v=-\\frac{1}{2}e^{-2x}$\n- 代入公式：$-\\frac{1}{2}xe^{-2x} + \\frac{1}{2}\\int e^{-2x}dx$\n\n### 技巧3：多次分部积分\n$$\\int x^2 e^x\\,dx = x^2 e^x - 2\\int x e^x\\,dx$$\n需连续使用分部积分，直到幂函数降为常数\n\n### 技巧4：递推关系\n某些积分可建立递推公式：\n$$\\int x^n e^x\\,dx = x^n e^x - n\\int x^{n-1} e^x\\,dx$$\n\n### 技巧5：组合拆分\n对于 $\\int e^x(\\sin x + \\cos x)\\,dx$，可拆分为两个分部积分，但更简单的方法是观察导数关系：\n$d(e^x \\sin x) = e^x(\\sin x + \\cos x)dx$\n\n---\n\n## 常见易错点\n1. **符号错误**：公式中的减号易漏写\n2. **$v$ 计算错误**：求 $v$ 时积分常数可省略（因最后会抵消）\n3. **选择不当**：违反\"反对幂指三\"可能导致积分更复杂\n4. **循环处理**：$\\int e^x \\sin x\\,dx$ 类问题，移项时注意系数\n\n---\n\n## 典型例题\n\n### 例1：对数函数\n$$\\int \\ln x\\,dx = x\\ln x - \\int x\\cdot\\frac{1}{x}dx = x\\ln x - x + C$$\n\n### 例2：反三角函数\n$$\\int \\arcsin x\\,dx = x\\arcsin x - \\int \\frac{x}{\\sqrt{1-x^2}}dx = x\\arcsin x + \\sqrt{1-x^2} + C$$\n\n### 例3：循环积分\n$$\\int e^x \\sin x\\,dx$$\n- 第一次：$u=\\sin x$，$dv=e^x dx$，得 $e^x \\sin x - \\int e^x \\cos x\\,dx$\n- 第二次：对 $\\int e^x \\cos x\\,dx$ 再分部积分\n- 得方程：$I = e^x \\sin x - e^x \\cos x - I$\n- 解得：$I = \\frac{e^x(\\sin x - \\cos x)}{2} + C$\n\n### 例4：含负指数\n$$\\int \\frac{\\arctan e^x}{e^{2x}}\\,dx = -\\frac{1}{2}\\int \\arctan e^x\\,d(e^{-2x})$$\n令 $u=\\arctan e^x$，$dv=d(e^{-2x})$，需注意 $du=\\frac{e^x}{1+e^{2x}}dx$\n\n---\n\n## 特殊情形处理\n1. **只有一类函数**：如 $\\int \\ln x\\,dx$，视为 $1\\cdot\\ln x\\,dx$\n2. **乘积含三个因子**：先组合两个放入 $dv$，或换元简化\n3. **分母复杂**：考虑整体代换或分部积分后消去分母\n4. **定积分**：计算时先求原函数，注意上下限代入\n\n**还有更重要的一点是**\n不要被形式迷惑了双眼，$\\frac{1}{\\cos x^2}$是什么啊？不认识？这就不对了\n我认为，直接先表示回去就行了，这下认出来了（\n然后看到对$\\sec x$求导时不要忘记公式，还在企图自己推导\n\n## 商的导数逆运算（反向商法则）\n\n在积分中，有时会遇到形如 $\\frac{u'v - uv'}{v^2}$ 的被积函数，这正是商函数 $\\left( \\frac{u}{v} \\right)'$ 的导数。因此，可以直接写出原函数 $\\frac{u}{v} + C$。\n\n---\n\n### 核心识别技巧\n\n1. **分母为平方形式**：通常为 $v^2$ 或可化为 $v^2$。\n2. **分子为两项之差**：且每项均为两个函数的乘积（即 $u'v$ 和 $uv'$）。\n3. **找出 $u$ 和 $v$**：从分母中猜测 $v$（通常为分母的“一部分”），再根据分子确定 $u$。\n\n---\n\n### 一般步骤\n\n设被积函数为 $\\frac{P(x)}{Q(x)}$：\n1. 尝试将 $Q(x)$ 写成 $v^2$ 的形式（或类似）。\n2. 观察 $P(x)$ 是否能表示为 $u'v - uv'$。\n3. 若可以，则积分结果为 $\\frac{u}{v} + C$。\n例题：\n$$\\int\\frac{xf'(x)-(1+x)f(x)}{x^2e^x}\\,dx$$\n- **分母**：$x^2 e^x = (x e^x)^2 \\cdot e^{-x}$？实际上，直接考虑函数 $\\frac{f(x)}{x e^x}$ 的导数。\n- 设 $v = x e^x$，则 $v' = (1+x)e^x$。\n- 设 $u = f(x)$，则 $u' = f'(x)$。\n- 计算 $\\left( \\frac{u}{v} \\right)' = \\frac{u'v - uv'}{v^2} = \\frac{f'(x) \\cdot x e^x - f(x) \\cdot (1+x)e^x}{(x e^x)^2} = \\frac{x f'(x) - (1+x)f(x)}{x^2 e^x}$。\n- 因此，原积分 $= \\frac{f(x)}{x e^x} + C$。\n\n### 常用构造\n\n1. **对于 $\\int \\frac{f'(x)g(x) - f(x)g'(x)}{g(x)^2} dx$**，结果为 $\\frac{f(x)}{g(x)} + C$。\n2. **对于 $\\int \\frac{f'(x)g(x) - f(x)g'(x)}{[g(x)]^n} dx$**（$n \\neq 2$），通常需要调整。","tags":["数学"]},{"title":"华中农业达大学迎新赛题解与反思","url":"/ZestfulYK-blog/2025/12/07/华中农业达大学迎新赛题解与反思/","content":"\n[M-终极考验](https://ac.nowcoder.com/acm/contest/123093/M)\n\n这题的大致思路是对的，但是最后处理差分时，直接选择了min(i+x,n)，这个就不对了，因为我们要的不是二选1，而是只有在满足要求时才处理。所以把min改成if判断就行了，下次需要注意这个逻辑问题。\n\n[H-对决](https://ac.nowcoder.com/acm/contest/123093/H)\n\n这个题目是纯暴力的搜索题，那么只要一个一个判断就好了，但是此处注意循环范围是$\\leq n-4$而不是$<n-4$.最好自己先之上推导一下再提交\n\n[B-爱的魔法](https://ac.nowcoder.com/acm/contest/123093/B)\n\n这一题一开始的错误原因是没有注意到交换最接近的会导致得到的不是最大的数字，例如1999，交换以后是9199是不对的，所以要倒遍历。建议自己先多造几组数据再提交，包括一些边界情况等等。随机数也不错（较小范围能手推的）\n\n","tags":["算法"]},{"title":"异或笔记","url":"/ZestfulYK-blog/2025/12/07/异或笔记/","content":"### 一、 异或的基本性质（基石）\n\n记住这四条，其他大多可以推导：\n\n1. **归零律**：`a ⊕ a = 0`\n2. **恒等律**：`a ⊕ 0 = a`\n3. **自反性**（交换律与结合律的推论）：`a ⊕ b ⊕ a = b`\n4. **交换律**与**结合律**：运算顺序和分组不影响结果。这使得前缀异或成为可能。\n\n### 二、 前缀异或：子数组问题的利器\n\n这是处理**子数组异或和查询**最核心的技巧，类似于前缀和。\n\n- **定义**：设 `pre[i] = a[1] ⊕ a[2] ⊕ ... ⊕ a[i]`，并约定 `pre[0] = 0`。\n- **核心公式**：`a[l] ⊕ a[l+1] ⊕ ... ⊕ a[r] = pre[r] ⊕ pre[l-1]`\n    - **原理**：`pre[r] ⊕ pre[l-1] = (前缀到r) ⊕ (前缀到l-1)`，根据结合律和归零律，相同的部分（前l-1项）抵消，剩下就是区间 `[l, r]` 的异或和。\n- **应用场景**：\n    - 快速求任意子数组异或和。\n    - 将“子数组异或和为0”的条件转化为 `pre[r] == pre[l-1]`。**这是解题的关键一步！**\n    - 问题转化为对前缀异或数组 `pre` 的分析，常结合哈希表（`unordered_map`）来统计次数、寻找配对。\n\n### 三、 位运算的独特性质（解题突破口）\n\n1. **不进位加法/减法**：异或在每一位上独立操作。`a ⊕ b` 在二进制下，每一位的规则是“相同为0，不同为1”。这暗示我们可以**按位考虑问题**。\n2. **判断奇偶性**（结合律的妙用）：\n    - 多个数异或，结果的**最低位** 等于 所有数最低位的异或。\n    - 而一个数二进制最低位为 `1` 代表奇数，为 `0` 代表偶数。\n    - **推论**：在一堆数中，异或结果的奇偶性 等于 所有数奇偶性的异或。这在一些博弈或奇偶分类问题中有用。\n3. **与加法的关系**：`a ⊕ b <= a + b`。等号成立当且仅当 `a` 和 `b` 的二进制表示没有同时为1的位（即 `a & b == 0`）。这个性质在涉及“最大异或和”与“和”的比较时常用。\n4. **构造互补对**：对于任意数 `x`，存在唯一的数 `y`，使得 `x ⊕ y = (全1的二进制串)`，这个 `y` 等于 `~x`（在限定位数下）。在构造题中，常用 `(1<<k)-1 - x` 来得到与 `x` 在 `k` 位下每一位都相反的数。\n### 四、 经典题型与技巧\n1. **寻找唯一出现奇数次的数**：利用 `a⊕a=0`，将所有数异或，出现偶数次的会两两抵消，结果就是那个出现奇数次的数。\n2. **寻找两个只出现一次的数**（其他出现两次）：\n    - 第一步：将所有数异或，得到 `x = a ⊕ b`（`a`, `b` 为所求）。\n    - 第二步：找到 `x` 的任意一个为 `1` 的二进制位。这一位意味着 `a` 和 `b` 在这一位上不同。\n    - 第三步：根据这一位将原数组分成两组，分别异或，得到的两个结果就是 `a` 和 `b`。\n3. **最大/最小异或对问题**：\n    - **暴力**：`O(n^2)` 对于大数据不行。\n    - **优化（`O(n*logC)`）**：使用**01-Trie（字典树）**。将数字按二进制从高位到低位插入Trie，查询时尽量“走相反位”可以得到最大异或值，“走相同位”可以得到最小异或值。这是必须掌握的高级数据结构。\n4. **异或相关的构造题**（如你刚才遇到的）：\n    - **核心目标**：控制前缀异或数组 `pre` 的值。\n    - **常用手段**：\n        - 让 `pre` 数组的值是 `0` 到 `n` 的一个排列，然后微调（例如交换两个值）来满足特定区间异或为0的条件。\n        - 利用性质：如果 `pre[l-1] = pre[r]`，则区间 `[l, r]` 异或为0。要保证其他区间不为0，就要保证其他任意 `pre[i]` 与 `pre[j]` 都不相等（除了我们特意制造的那一对相等）。\n        - 注意题目对 `a[i]` 取值范围的限制（如 `1 <= a[i] <= 1e9`），这要求 `pre[i] ⊕ pre[i-1]` 的结果必须在这个范围内。通常用连续整数构造 `pre` 可以满足。\n\n### 五、 做题时的注意事项（避坑指南）\n\n1. **注意数据范围和溢出**：你刚才遇到的问题就是典型。当使用2的幂构造时，`2^30 ≈ 1e9`，所以区间长度不能超过30。必须时刻检查构造值是否在允许范围内。\n2. **小心 `0`**：异或中 `0` 是单位元，非常特殊。在构造时，如果允许元素为 `0`，可能会意外产生多个异或为0的子数组（例如单个元素为0）。题目常要求**正整数**来避免这种情况。\n3. **前缀异或的初始化**：务必定义 `pre[0] = 0`，这样才能正确表示从 `a[1]` 开始的子数组。\n4. **调试方法**：对于小数据，可以暴力计算所有子数组的异或和来验证你的构造是否正确。\n5. **思维转化**：遇到“所有子数组异或和不为0”这类强条件，要立刻想到它等价于“前缀异或数组 `pre` 中所有元素两两不同（且 `pre[0]=0` 也不与其他重复）”。这大大简化了问题。\n### 六、 推荐的巩固练习方向\n\n1. **基础**：LeetCode 136（只出现一次的数字）、LeetCode 268（缺失数字）。\n2. **进阶**：LeetCode 260（只出现一次的数字 III）、LeetCode 421（数组中两个数的最大异或值）**（必做，练习01-Trie）**。\n3. **综合与构造**：Codeforces 上的许多构造题（难度 1500-1800），比如你刚才做的这道题的原型。多观察题解中是如何利用前缀异或性质进行构造的。\n\n总结一下，异或问题的核心思路是：**利用前缀异或转化区间问题，利用归零律和结合律进行抵消与配对，利用位独立性进行按位处理或使用Trie**。多练习，你会对这种“魔力”运算越来越有感觉。\n\n因为异或可以逆运算，所以此处直接先算1-n的异或和再和现在的异或和异或一下就行了。\n这样就找到了那个没有出现过的数字。\n找出现奇数次的数字时，可以直接异或，因为只有一个数字满足这个要求，那么最后剩下的那个就是无法完成匹配的数字，就是答案了。\n找两个只出现一次的数字时，也是先异或得到$x=x_1\\oplus x_2$，然后看不一样的那一位来分开数组。\n解释：就是看这一位是否是1，然后就和只出现一次的数那题一样了。出现两次的数，分组一定在一起，那么就相互异或抵消了。","tags":["算法"]},{"title":"ACM数字类题目","url":"/ZestfulYK-blog/2025/12/07/数字类算法/","content":"# 数字类题目\n\n- 定义：通常有乘除法，或者时分解质因数之类的\n\n**重要观察**\n\n$2^{30} >= 10^9$所以一般不需要几个数就能乘到上界，除法的话同理，分解质因数实际上也算乘法。\n因此这类题目往往可以比较暴力的解决。因为只要枚举这几个位置即可。\n\n重要例题：\n\n1.题目传送门[Strange Machine](https://codeforces.com/contest/2156/problem/B)\n- 重要观察：$log_2(10^9)=30$,所以除去全是1的情况，每次除2最多30次循环就结束了，因此可以暴力解决。除了有1的情况，因为n最大为20，所以最多$20*30$每个数据。\n\n2.题目传送门[Even Modulo Pair](https://codeforces.com/contest/2164/problem/B)\n- 重要观察，要塞大量数据来导致超时的话是不可能的，因为在30个数内必然能找到。\n理由：首先如果只有偶数，那么一定有解。（因为严格递增）\n\t当只有奇数时：\n\t因为当$y<2*x$时，必然有$y \\mod x \\ = \\ y-x \\ = \\text{偶数}$,因此要构造较大的数据的话，只能让$y \\geq x *2$\n\t要让$y \\mod x \\ !=  \\text{偶数}$，那么最小只能构造$y=x*2$那么和上一题就一样了。\n\n3.题目传送门[Add 0 or K](https://codeforces.com/problemset/problem/2134/B)\n- 题目理解，首先要求吧原数组每个元素加上K的若干倍，构成含有相同因子的数组。\n- 重要观察：加完以后，因为含有相同的因子，所以考虑把每个加完以后的数字拆分，得到一串质数，而前29个质数的乘积已经大于$10^9$了，所以直接可以算出最终的共同因子。\n接下来对最后结果化简$a_i+c_i*k \\equiv 0  (mod\\ g)$,所以$c_i=(-a_i)*inv_k$\n而k存在$mod \\ g$下有逆元，需要g和k互质，所以可以简单完成。\n\n4.题目传送门[C-区间乘_2025年广东工业大学新生赛（同步赛）](https://ac.nowcoder.com/acm/contest/123428/C)\n- 希望我们计算一个区间的乘积，判断是否可能达到给定的输出。\n- 数据规模n和查询规模q都是$2*10^5$所以不能直接查询。\n- 重要观察：如果把1去掉算法就能变简单，而如果不是全为1的话，查询数据$x \\leq 10^9$，所以当不是1的时候，只要30个2就能超过数据范围了，每个位置计算一下，可以直接提取计算可能出现的数字，故最多$30*2*10^5$次计算，查询$q\\log_2(x)$次就行了\n所以最终时间复杂度是$O(T*count*q\\log_2(q))$ \ndirt=（总提交次数-过题数量）/总提交次数\n\n然后注意，只有质因数时可以用，其他的如因子就不行\n出现奇偶判断的也不要用这个方法，用奇偶性分析特判\n\n# GCD二级结论\n\n## 结论1\n$$lcm(a,b)*gcd(a,b)=ab$$\n## 结论2\n$$gcd(a,b) = gcd(a,|b-a|)$$\n\n## 结论3\n$$gcd(a,b,c)=1等价于存在ax+by+cz =1$$\n## 结论4\n$$gcd(a,b) = g * gcd(a >> k,b >> k)\\,(g = 2 ^ k)$$\n## 结论5\n$$gcd(a^{n-1},a^{m-1})=a^{gcd(n,m)-1}$$\n## 结论6\n$$gcd(f_n,f_m)=f_{gcd(n,m)}$$\n斐波那契数列\n\n# 数论题目\n\n## 例题\n\n- 题目描述：求N个数，相乘等于M\n- 题目转化，因为相乘等于M，那么得到的每一个数必然都是由M的质因数转化而来的，那么考虑每一个质因数在排列中出现的位置，就得到实际上是求把m个球放到n个不同的盒子里的方案数，每一个质因数都要计算一次，相乘得到答案。\n那么怎么计算**把m个球放到n个不同的盒子里的方案数**呢？\n引用一下某大佬的解释：\n>我们回头看看2(球同，盒不同，不允许空盒)。在2的条件下，我们可以给出另一个处理方案：\n如果我们给每个盒子都放上1个球，那么剩下的n-m个球放入m个盒子里，就不需要管是否有空盒了（因为已经事先给每个盒子都放了一个球）。\n如果用T(n-m, m)表示加粗部分的方案数量，那么2的答案 = 1（先每个盒子一个球，只有1种放法） * T(n-m, m)。\n那么显然，T(n-m, m)就是情况3，只不过是n-m个球入m个盒，而不是我们要求的n个球入m个盒。\n那么我们只需要把2情况里，球的总数量变成n+m个，在上述方案里，就会变成“如果我们给每个盒子都放上1个球，那么剩下的n + m - m = n个球放入m个盒子里，就不需要管是否有空盒了”\n因此，方案数量在数值上是等于2里，把n替换成n+m的：\n方案数量 = C(n + m - 1, m - 1)\n\n那么接下来我们计算阶乘和逆元就能解答了（\n（怎么这么麻烦，没招了）","tags":["算法"]},{"title":"计算机18讲题解","url":"/ZestfulYK-blog/2025/12/07/计算机18讲题解/","content":"\n#### 小技巧\n- 在网页前面加上read有奇效\n例如：\n```html\nraed:https://www.reach-top.cn.com\n```\n这个是阅读器模式，开启以后就能获取里面原先不让复制的内容了\n## A题\n\n-  题目描述\n每个整数都应输出一个各位数字和，并独占一行。\n- 解题思路\n拿之前上课的程序自然是能解决的，直接一个循环算到底\n每一位的值是n%10，要取得下一位就n/=10再算就彳亍了\n但是注意到这节课的标题是函数，那么我们就编写一个递归程序来计算每一位的和\n边界条件：n<=10\n递推式子：n %10+solve(n/10)\n- 参考代码\n```C++\nll solve(ll n){\n  if(n<10) return n;\n  return n%10+solve(n/10);\n}\nsigned main(){\n  ll T;\n  while(cin>>T)\n\tcout<<solve(T)<<endl;\n  return 0;\n}//此处#define ll long long\n```\n## B题\n\n- 题目描述\n给定若干个正整数，请你从这些整数中找到最小值和第二小的值，计算一下第二小的数值减去最小值的结果是不是素数，如果是则输出Yes，否则输出No\"o。 \n- 解题思路\n直接写一个循环计算最小值和次小值，然后判断差是不是素数就行了\n计算最小值和次小值的思路，如果输入值x比最小值小，那么把次小值改成原先的最小值，再把最小值修改为输入值x，如果只是比次小值小，那么把次小值改成输入值x\n- 参考代码\n```C++\nvoid isprime(int n){\n  if(n==1){\n    cout<<\"No\\\"o\"<<endl;\n    return;\n  }\n  for(int i=2;i<=sqrt(n);i++){\n    if(n%i==0){\n      cout<<\"No\\\"o\"<<endl;\n      return;\n    }\n  }\n  cout<<\"Yes\"<<endl;\n}\nsigned main()\n  ll minn1=1e18,minn2=1e18,x;\n  while(cin>>x){\n    if(x<minn1){\n      minn2=minn1;\n      minn1=x;\n    }\n    else if(x<minn2)\n      minn2=x;\n  }\n  isprime(minn2-minn1);\n  return 0;\n}\n```\n\n\n## C题\n\n- 题目描述\n哥德巴赫猜想大家都知道一点吧。我们现在不是想证明这个结论，而是想在程序语言内部能够表示的数集中，任意取出一个偶数，来寻找两个素数，使得其和等于该偶数。  做好了这件实事，就能说明这个猜想是成立的。由于可以有不同的素数对来表示同一个偶数，所以专门要求所寻找的素数对是两个值最相近的。\n- 解题思路\n直接暴力求解从中间开始计算，设两个数分别是x，y，然后x--，y++，判断是否是合法的，如果合法那么输出，这样得到的第一组解必然是最小的一组解。\n判断是否是素数的代码可以用上一题的代码。\n- 参考代码\n```C++\nbool isprime(ll n){\n  if(n==1) return false;\n  for(int i=2;i<=sqrt(n);i++){\n    if(n%i==0)\n      return false;\n  }\n  return true;\n}\nsigned main(){\n  ll x;\n  while(cin>>x&&x){\n    ll a1=x/2,a2=x/2;\n    while(1){\n      if(isprime(a1)&&isprime(a2)){\n        cout<<a1<<' '<<a2<<endl;\n        break;\n      }\n      a1--; a2++;\n    }\n  }\n  return 0;\n}\n```\n\n## D题\n\n- 题目描述\n求给定n个正整数的最大公约数\n- 解题思路\n计算每个数和现在得到的最大公约数的最大公约数\n首先先默认最大公约数为第一个正数，然后计算即可。\n计算最大公约数其实有两种方式，要是你用万能头的话，可以使用自带函数直接计算。\n这里采用的是标准的辗转相除法。\n- 参考代码\n```C++\nll gcd(ll n,ll m){\n  if(n%m==0) return m;\n  else return gcd(m,n%m);\n}\nsigned main(){\n  ll n,x; cin>>n;\n  ll m=n,maxgcd;\n  while(cin>>x&&n){\n    if(x<=0) continue;\n    if(n==m) maxgcd=x;\n    n--;\n    maxgcd=gcd(maxgcd,x);\n    //maxgcd=__gcd(x,maxgcd);这个是自带的函数，也是可以的\n  }\n  cout<<maxgcd<<endl;\n}\n```\n\n## E题\n- 题目描述\n找比x大的第一个回文数\n- 解题思路\n每次加1，直到找到回文数为止。\n判断回文数的话，直接先一位一位取出来，然后计算，一个正向遍历，一个反向遍历，结果一样就是回文。\n- 参考代码\n```C++\nbool hws(ll x){\n  ll a[2000],id=1;\n  while(x){\n    a[id++]=x%10;\n    x/=10;\n  }\n  for(int i=1;i<id;i++)\n    if(a[i]!=a[id-i])\n      return false;\n  return true;\n}\nsigned main(){\n  ll x;\n  while(cin>>x){\n    x++;\n    while(!hws(x++));\n    cout<<x-1<<endl;\n  }\n}\n```\n这里因为要求要比x大，所以先x++，最后输出x-1的原因是循环里写的是x++最后会多1。\n\n## F题\n- 题目描述\n如果一个数从左到右和从右到左读都一样，那么这个数就叫做“回文数”。如果一个数的十进制和二进制表示都是回文数，则把这个数叫做“双重回文数”。例如，十进制33是回文数，将其转化为二进制表示100001也是回文数，所以33是双重回文数。编写程序，查找1~1000的所有双重回文数。\n- 解题思路\n和上一题一样，只不过要多出力一个二进制的而已。\n- 参考代码\n```C++\nbool hws(ll x){\n  ll a[2000],id=1;\n  ll y=x;\n  while(x){\n    a[id++]=x%10;\n    x/=10;\n  }\n  for(int i=1;i<id;i++)\n    if(a[i]!=a[id-i])\n      return false;\n  \n  id=1;\n  while(y){\n    a[id++]=y%2;\n    y/=2;\n  }\n  for(int i=1;i<id;i++)\n    if(a[i]!=a[id-i])\n      return false;\n  return true;\n}\nsigned main(){\n  for(int i=1;i<=1000;i++)\n    if(hws(i)) cout<<i<<\"为双重回文数\"<<endl;\n}\n```\n\n\n\n\n\n\n","tags":["算法"]},{"title":"模运算性质总结","url":"/ZestfulYK-blog/2025/11/25/mod/","content":"# 模运算（Mod）性质总结\n\n## 定义\n\n对于任意实数 $( x, y )$，有：\n\n$$x \\mod y = x - y \\left\\lfloor \\frac{x}{y} \\right\\rfloor, \\quad y \\neq 0$$\n\n模运算（在一些场合使用符号 % 表示）是一个二元运算。$( x \\mod y )$ 的值范围如下：\n\n- 当 $( y > 0 )$ 时：$( 0 \\leq x \\mod y < y )$\n- 当 $( y < 0 )$ 时：$( 0 \\geq x \\mod y > y )$\n- 当 $( y = 0 )$ 时：为避免除以零，定义 $( x \\mod 0 = x )$\n\n## 基本运算规则\n\n模运算与基本四则运算类似（除法除外）：\n\n1. **加法规则**：$((a + b) \\mod p = (a \\mod p + b \\mod p) \\mod p)$\n2. **减法规则**：$((a - b) \\mod p = (a \\mod p - b \\mod p) \\mod p)$\n3. **乘法规则**：$((a \\times b) \\mod p = (a \\mod p \\times b \\mod p) \\mod p)$\n4. **幂运算规则**：$(a^b \\mod p = ((a \\mod p)^b) \\mod p)$\n5. **求和规则**：由第1个公式可推导出 $(\\left(\\sum_{i=1}^{n} x_i\\right) \\mod p = \\left(\\sum_{i=1}^{n} (x_i \\mod p)\\right) \\mod p)$\n\n## 运算律\n\n### A. 结合律\n\n$$((a + b) \\mod p + c) \\mod p = (a + (b + c) \\mod p) \\mod p$$\n\n$$((a \\times b) \\mod p \\times c) \\mod p = (a \\times (b \\times c) \\mod p) \\mod p$$\n\n### B. 交换律\n\n$$(a + b) \\mod p = (b + a) \\mod p$$\n\n$$(a \\times b) \\mod p = (b \\times a) \\mod p$$\n\n### C. 分配律\n\n$$(a + b) \\mod p = (a \\mod p + b \\mod p) \\mod p$$\n\n$$((a + b) \\mod p \\times c) \\mod p = ((a \\times c) \\mod p + (b \\times c) \\mod p) \\mod p$$\n\n## 补充性质\n\n### 同余性质\n\n- **反身性**：$(a \\equiv a \\pmod{m})$\n- **对称性**：如果 $(a \\equiv b \\pmod{m})$，则 $(b \\equiv a \\pmod{m})$\n- **传递性**：如果 $(a \\equiv b \\pmod{m})$ 且 $(b \\equiv c \\pmod{m})$，则 $(a \\equiv c \\pmod{m})$\n\n### 模运算与除法\n\n模运算与除法不直接兼容，但有以下性质：\n\n- 如果 $(ac \\equiv bc \\pmod{m})$ 且 $(\\gcd(c, m) = 1)$，则 $(a \\equiv b \\pmod{m})$\n    \n- **模逆元**：如果 $(\\gcd(a, m) = 1)$，则存在整数 $(b)$ 使得 $(ab \\equiv 1 \\pmod{m})$，称 $(b)$ 为 $(a)$ 模 $(m)$ 的逆元\n    \n- **核心性质**：在模运算里除以一个数等于乘以这个数的逆元，即：$$c/a≡c×a^{−1} (modm)$$其中 $a^{-1}$ 是 $a$ 在模 $m$ 下的逆元。\n\n**重要前提**：模逆元存在的**充分必要条件**是 $\\gcd(a, m) = 1$（即 $a$ 与 $m$ 互质）。如果 $a$ 与 $m$ 不互质，则 $a$ 在模 $m$ 下没有逆元，除法操作无法进行。\n\n---\n#### 计算模逆元的方法\n\n常用的计算模逆元的方法是**扩展欧几里得算法**，它不仅能求最大公约数，还能找到满足贝祖等式的系数。\n\n示例代码;\n```C++\n#include <iostream>\nusing namespace std;\n\n// 扩展欧几里得算法求逆元\nlong long mod_inverse(long long a, long long m) {\n    long long m0 = m;\n    long long y = 0, x = 1;\n    \n    if (m == 1) return 0;\n    \n    while (a > 1) {\n        long long q = a / m;\n        long long t = m;\n        \n        m = a % m;\n        a = t;\n        t = y;\n        \n        y = x - q * y;\n        x = t;\n    }\n    \n    if (x < 0) x += m0;\n    \n    return (a == 1) ? x : -1; // 如果逆元不存在返回 -1\n}\n\n// 使用示例\nint main() {\n    long long a = 3, m = 7;\n    long long inv = mod_inverse(a, m);\n    if (inv != -1) {\n        cout << a << \" 在模 \" << m << \" 下的逆元是: \" << inv << endl;\n    } else {\n        cout << a << \" 在模 \" << m << \" 下没有逆元\" << endl;\n    }\n    return 0;\n}\n```\n\n#### 应用示例\n\n计算 $6 / 3 \\pmod{7}$：\n\n1. 先求 $3^{-1} \\pmod{7}$：$3 \\times 5 = 15 \\equiv 1 \\pmod{7}$，所以逆元为 5\n    \n2. $6 / 3 \\equiv 6 \\times 5 = 30 \\equiv 2 \\pmod{7}$\n    \n3. 验证：$2 \\times 3 = 6 \\equiv 6 \\pmod{7}$ ✓\n    \n\n这个性质在密码学、组合数学和算法竞赛中都有广泛应用。\n### 模运算的周期性质\n\n- 对于任意整数 $(k)$，有 $(a \\mod m = (a + km) \\mod m)$\n- 模运算的结果具有周期性，周期为模数 $(m)$\n\n# 逆元的计算\n\n- 如果是计算单个的逆元，那么使用小费定理：\n```C++\nll qpow(ll a,b=mod-2) {\n    ll res = 1;\n    while (b) {\n        if (b & 1) res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n```\n\n- 计算多个数字的逆元，使用拓展欧几里得算法\n```C++\nLL inv[mod+5]; \nvoid getInv(LL mod) { \n\tinv[1]=1; \n\tfor(int i=2;i<mod;i++) \n\t\tinv[i]=(mod-mod/i)*inv[mod%i]%mod; \n}\n```\n\n- 然后如果是一个等式的话，考虑两边同时取逆元\n- 例如：计算$n!$的逆元，得到递推式子\n$$(i+1)! \\equiv i \\,!*(i+1) \\mod p$$\n所以：$$inv[(i+1)!]\\equiv inv[i]*inv[i+1] \\mod p$$\n又因为：$$inv[i+1]*(i+1)\\equiv1\\mod p$$\n所以把已知的$inv[i+1]$移到左边，得到：$$inv[(i+1)!]*(i+1)\\equiv inv[i] \\mod p$$\n这就是求阶乘逆元的递推式了","tags":["算法"]},{"title":"算法挑战赛题解","url":"/ZestfulYK-blog/2025/11/20/2/","content":"\n### 算法挑战赛第二期题解\n\n## 题目\n\n- 二进制小数的乘积~HC哥哥说这个很困！难！\n\n- Description\n\n> HC哥哥今天又突发奇想，它依然定义一个数字为二进制小数，如果它是一个正整数，并且其十进制表示中的所有数字都是0或1。例如，110 是一个二进制小数，而 102 和 787 不是。\n\n> 现在HC哥哥给定你一个数 n，你被要求判断是否可能将 n 表示为一些（不一定是不同的）二进制小数的乘积。\n\n\n- Input\n\n> 第一行包含一个整数 t（1≤t≤5⋅10^4）— 测试用例的数量。\n\n> 每个测试用例的唯一一行包含一个整数 n（1≤n≤10^5）。\n\n\n- Output\n\n> 对于每个测试用例，如果 n 可以表示为一些二进制小数的乘积，则输出 \"YES\"（不带引号），否则输出 \"NO\"（不带引号）。\n\n- 题目解释 （~~翻译成人话~~）\n\n计算把01串强制转换为整数，再相乘得到的数就是合法的数字，其余都是不合法的。\n那么直接**打表**就行了，总共1e5个数，打表还是很容易实现的\n\n接下来我们来学习一下该怎么打表\n\n## 打表\n\n- 定义 : 计算出所有情况，然后直接判断。\n\n比如问你100以内的数是否是质数，你肯定能直接回答，因为你已经把100以内的质数全部背下来了。这其实就是打表的一种体现，你提前计算前100内的数是否是质数，然后直接调用答案。\n\n但是我们的计算机实际上并不知道一个问题的所有解，那么你自己提前算好告诉它不就彳亍了吗。\n\n这时我们需要两个重要程序：**打表程序**和**判断程序**。\n\n### 打表程序\n\n- 用于计算所有情况的答案，不用关心时间复杂度，反正是提前计算\n\n比如计算素数集，你直接暴力就好了，不会欧拉筛又有什么关系呢？\n\n### 判断程序\n\n- 用于直接获得答案的程序，时间复杂度O(n),n为数据规模，每次查询的时间复杂度为O(1)。\n\n**接下来就该思考怎么写一个无脑的程序来计算这些情况了**\n\n## 做法\n\n- 首先先写一个无脑程序生成所有01组合的数\n```C++\nvector<ll> ans;\nint main(){\n    for(int i=1;i<=100000;i++){\n        ll x=i,cnt=0,w=0;\n        while(x){\n            if(x%10<2) cnt++;\n            w++;\n            x/=10;\n        }\n        if(cnt==w) ans.push_back(i);\n    }\n    for(auto &i:ans)\n        cout<<i<<\",\";\n}\n```\n\n> 此处是对每一位进行判断，如果01的个数和位数一样，那么就是一个合法的数字\n\n- 得到如下结果：\n```C++\n\n1,10,11,100,101,110,111,1000,1001,1010,\n1011,1100,1101,1110,1111,10000,10001,10010,\n10011,10100,10101,10110,10111,11000,11001,\n11010,11011,11100,11101,11110,11111,100000\n```\n\n- 把以上结果复制进下一段生成代码，然后再计算所有合法的数字\n```C++\nll number[1010]={0,1,10,11,100,101,110,111,1000,1001,\n    1010,1011,1100,1101,1110,1111,10000,10001\n    ,10010,10011,10100,10101,10110,10111,11000\n    ,11001,11010,11011,11100,11101,11110,11111,100000};\nset<ll> s;\nll dfs(ll n){\n    s.insert(n);\n    for(int i=2;i<=32;i++){\n        if(n*number[i]<=100000)\n           dfs(n*number[i]);\n    }\n    return 0;\n}\nsigned main(){\n    dfs(1);\n    ll cnt=0;\n    for(auto &i:s){\n        cout<<i<<\",\";\n        cnt++;\n    }\n    cout<<endl<<cnt<<endl;\n    return 0;\n\n}\n```\n\n> 此处使用了dfs(Deep First Search)，文末会有详细介绍\n\n- 得到如下结果：\n```C++\n1,10,11,100,101,110,111,121,1000\n,1001,1010,1011,1100,1101,1110,\n1111,1210,1221,1331,10000,10001,\n10010,10011,10100,10101,10110,10111,\n10201,11000,11001,11010,11011,11100,\n11101,11110,11111,11121,11211,12100,\n12111,12210,12221,12321,13310,13431,\n14641,100000\n```\n\n- 最后再是无脑的判断程序：\n```C++\nvector<string> ans;\nll a[1010]={0,1,10,11,100,101,110,111,121,1000,1001,1010,1011,1100,1101,\n    1110,1111,1210,1221,1331,10000,10001,10010,10011,10100,10101,10110,\n    10111,10201,11000,11001,11010,11011,11100,11101,11110,11111,11121,\n    11211,12100,12111,12210,12221,12321,13310,13431,14641,100000};\nvoid solve(){\n    ll x; cin>>x;\n    for(int i=1;i<=47;i++){\n        if(a[i]==x){\n            ans.push_back(\"YES\");\n            return;\n        }\n    }\n    ans.push_back(\"NO\");\n}\nint main(){\n    ll T; cin>>T;\n    while(T--) solve();\n    for(auto &i:ans)\n        cout<<i<<endl;\n}\n```\n\n不是我说，这种做法在打表题目是真轮椅吧，时间复杂度完全没影响，计算出来总共就47个数字，简单版甚至20个都没到，非常适合不会搜索的蒻蒟(比如我)学习和理解。\n\n\n### 下面是对dfs(Deep First Search)算法的详细介绍：\n\n- 什么是dfs？\ndfs是深度优先搜索的英文缩写，以深度为优先来进行计算\n\n比如，要计算走n级楼梯（每次一到两级台阶）有几种走法，就可以使用dfs，假设第一次先走一步，依次遍历，如果能刚好走到n则方法数加1，如果超过了n则返回到上一步，回头找下一个方法。\n\n- 在本题的应用\n\n那么在这题，我们已经提前计算了所有合法的数字，我们每次乘上可能的数字，看看是否依旧合法，之后在超过1e5时返回，相当于楼梯数为1e5，每次可以走number[1....n]步，但是每一个小于n的位置都合法，并存储答案。\n\n如果想进一步了解dfs，可以访问OIwiki进行学习！\n\n那么本期的题解就到此结束了，感谢阅读！如果想交流算法题，也可以添加我的qq哦(717056060)\n\n#                        关注ZestfulYK，谢谢喵！"},{"title":"算法挑战赛题解（11.2）","url":"/ZestfulYK-blog/2025/11/03/1/","content":"\n# 算法挑战赛题解（11.2）\n\n## 简单版本：\n\n### 题目大意：\n\n给定n个区间，判断这些区间能划分出几种不同的区域\n\n- [性质不同的数字](http://www.zjutacm.cn/problem/3120)\n\n### 题目分析：\n\n实际上是在讨论每个点被哪几个区包含，在样例中，数据是这样的，我们来分析一下这两个样例\n\n```yaml\nSample Input 1 \n\n1\n1 6\n\nSample Output 1\n\n2\n\nSample Input 2\n\n4\n0 12\n4 13\n6 13\n12 13\n\nSample Output 2\n\n6\n\n```\n\n### 样例分析：\n\n```yaml\n样例1: 0 1 1 1 1 1 1 0 0 … …  所以是两种区间\n样例2: 1   2  3   4   5   6   7  8    9   10  11  12  13 … …\n       1   1  1   1   1   1   1  1   1    1   1   1\n                  2   2   2   2  2   2    2   2   2   2\n                          3   3  3   3    3   3   3   3\n                                                  4   4\n       |< ------ >|< ---- >|< ----------------- >|<->|<->|<--\n\n```\n\n所以是6种区间\n这样,我们就弄明白了题目在讲什么,接下来就可以思考怎么实现了\n\n### 题目思路：\n\n实际上有些人会以为我们需要统计的是这个点有几个区间经过，但是这是错误的，在样例二就能发现这一点。\n（这也是我第一次的想法，测试样例二时发现的T_T）\n\n我们需要思考怎么表示这一个点有哪些区间经过，而且每一个区间是互不相同的。这里我们考虑类似**状态压缩**的思想。\n\n什么是状态压缩呢？简而言之就是用一个数来代替这个状态。\n比如说，我们用1表示未进行，2表示正在进行，3表示完成，\n那么一个含有4个任务的任务表可以是这样的：\n\n                1321\n\n（1，4任务未进行，2任务完成，3正在进行）\n\n我们使用了一个4位数表示了这一状态，这样就实现了状态压缩，我们没有用数组存储状态，而是一个数，这样我们在判断两个状态是否相同时就可以直接判断数字是否相同了，节约了时间和判断的复杂度。\n\n那么怎么把这个思想用在这一题呢？我们考虑给每个区间一个标号k，每个区间内的点加上2^k，这样就保证了每一个状态不会重复。\n但是这么写居然WA了！这是因为数据范围n是[0,300]也就是会有2^300，远大于long long的最大范围(2^64-1)这显然是不行的。\n\n实际上这个算法已经十分接近答案了,但我们还需要改进这个算法。\n接着我们想到一个类似的方法，**哈希表(hash)**。\n\n其实哈希表和刚才的思路差不多，不过加入了一些更高级的算法来防止数据溢出。\n\n### 那么什么是hash呢？\n\n实际上也是创建一种对应关系，使得在查询时能快速访问这种情况对应的值。就像上面的例子一样，我们通过我们规定的方式把任务状态和整数一一对应。\n\n### 怎么创建hash表呢？\n\n首先，找到一个质数作为进制数P，通常取131或者13331，模数mod通常取1e9+7或1e9+9，对应关系就是对应的P进制数%mod\n例如这个点上经过了134这三个集合，那么我们就把134转化为131进制，即1 * 131^2+3 * 131+4，在实际操作时，就是每一个集合的下标k作为对应的位数，则每一个点的表示可以是这样的：\n\n![公式](/images/公式.png)\n\n这样我们就计算出了每一个点的唯一标识，含有相同标识的才能算是同一个点。（这里选择质数是为了防止哈希碰撞，即不同状态的得到了相同的标记；选择mod是防止溢出）\n\n最后只要统计一下标识的个数就行了（可以用set实现）\n代码实现：对于简单版本，暴力完全够用了。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define endl '\\n'\nconst ll P=131,mod=1e9+7;\nint main(){\n    ll n,z=1,a[1010]; cin>>n;\n    for(int i=0;i<=1000;i++) a[i]=0;\n    while(n--){\n        ll l,r; cin>>l>>r;\n        for(int i=l;i<=r;i++){\n            a[i]=(a[i]+z)%mod;\n        }\n        z=(z*P)%mod;\n    }\n    set<ll> q;\n    for(int i=0;i<=1000;i++){\n        q.insert(a[i]);\n    }\n    cout<<q.size()<<endl;\n}\n```\n\n\n所以这样我们就解决了简单版本。\n\n## 复杂版本：\n\n那么对于数据量大的**复杂版本**呢？\n\n这里我们依然采用hash，但是由于数据量大，为了防止冲突，我们给每一个区间都分配一个随机hash值，在计算时只考虑起点和终点，在进入起点时加入标记，离开时移除标记。这时我们就想到了具有可逆性质的异或，我们只要给对应的起终点打上相同标记就行了，最后还是用set统计产生的不同标记数\n\n### 参考代码：\n\n```C++\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ULL unsigned long long\n#define endl '\\n'\nint main(){\n    ll n; cin>>n;\n    vector<pair<ll,int>> box;\n    for (int i=0;i<n;i++){\n        ll l,r; cin>>l>>r;\n        box.push_back({l,i});\n        box.push_back({r+1,i});\n    }\n    sort(box.begin(),box.end());\n    vector<unsigned long long> h(n);\n    mt19937_64 rng(time(0));\n    for(int i=0;i<n;i++){\n        h[i]=rng();\n    }\n    set<ULL> s; s.insert(0);\n    ULL cur=0;ll last=-2e9;\n    for(auto& i:box){\n        ll pos=i.first,idx=i.second;\n        if(pos>last&&last!=-2e9) s.insert(cur);\n        cur^=h[idx];\n        last=pos;\n    }\n    s.insert(cur);\n    cout<<s.size()<<endl;\n}\n```\n\n```yaml\n                     感谢观看！关注ZestfulYK喵，谢谢喵！","tags":["算法"]},{"title":"压行技巧","url":"/ZestfulYK-blog/2025/10/24/压行技巧/","content":"\n#   如何给你的代码压行？\n\n如果不会压行，你的代码看起来会是这样的：\n\n```C++\nint ml(vector<int> s, int n)\n{\n    int m = s[0];\n    for (int i = 0; i <= n; i++)\n    {\n        if (s[i] > m)\n            m = s[i];\n    }\n    return m;\n}\n```\n\n整整用了9行！\n实际上其实根本不需用那么多行：\n```C++\nint ml(vector<int> s,int n){\n    int m=s[0];\n    for(int i=0;i<=n;i++){\n        if(s[i]>m)m=s[i];\n    }\n    return m;\n}\n```\n\n当然也可以更短：\n```C++\nint ml(vector<int> s,int n){\n    int m=s[0];\n    for(int i=0;i<=n;i++) if(s[i]>m) m=s[i];\n    return m;\n}\n```\n那么问题来了，怎么在不影响代码运行的情况下合理的压行呢？\n\n# 判断类循环类的压行技巧\n\n## 判断类\n\n如果判断语句仅一行，可以考虑压行：\n\n```C++\nif(a==1) sum++;\nelse sum--;\n\n//或者这样\n\nif(a==1)\n    sum++;//可以通过缩进来方便区分\n```\n\n两句的话，压行可以考虑用大括号包起来压行~~前提是你觉得看着没影响~~\n\n```C++\nif(a==1) {sum++;a=2;}\n```\n\n注意在大括号里的每一句都是要加上封号的，因为这一段代码实际上等价于：\n\n```C++\nif(a==1){\n    sum++;\n    a=2;\n}\n```\n\n## 循环类压行\n\n也和判断的一样，可以这么压行：\n\n```C++\nfor(int i=1;i<=n;i++) cout<<1<<endl;\n\n//或者这样：\n\nfor(int i=1;i<=n;i++)\n    cout<<1<<endl;\n```\n\n如果是输出的话，其实可以这么写：\n\n```C++\nfor(int i=1;i<=n;i++) cout<<i<<\" \"; cout<<endl;\n```\n\n因为```C++cout<<endl;```其实是在循环之外的，所以这么写是正确的\n\n# 头文件压行\n\n下面送给大家万能头文件：\n\n```C++\n#include<bits/stdc++.h>\n```\n\n# 其他技巧\n\n```C++\n#define ll long long\n#define rep(1,n) for(int i=1;i<=(n);i++)\nll n;\nint main(){\n    rep(1,n) cout<<\"*\"; cout<<endl;\n}\n```\n\n通过define来减少代码长度，增加可读性\n\n## 一些非常有用的C++自带函数\n\n```C++\nsort(a,a+n);//a为数组，n为a的大小\n__gcd(x,y);//x，y的最大公约数\nx=1<<n;//2的n次方\n```\n","tags":["算法"]},{"title":"过关考模拟考题解","url":"/ZestfulYK-blog/2025/10/23/过关考模拟考题解/","content":"# 过关考模拟考题解\n\n## A签到题\n\n- 分析:\n\n要是这也不会那学习委员真没招了\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    cout<<\"Help others voluntarily but never let them know they owe you a favor.\"<<endl;\n}\n```\n\n## B选择结构\n\n- 分析:\n\n按照要求逐个判断，然后取最小值就行了\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    double x,y,n,p,ans=200;\n    cin>>x>>y>>n>>p;\n    if(p>=x) ans=min(ans,p-y);\n    ans=min(ans,p/10*n);\n    printf(\"%.2lf\",ans);\n}\n```\n\n## C循环\n\n- 分析:\n\n分三种情况，<10的一定成立，两三四位数自己判断就行了\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,cnt=0; cin>>n;\n    for(int i=1;i<=n;i++){\n        if(i<10) cnt++;\n        else if(i<100){\n            if(i%10==i/10) cnt++;\n        }\n        else if(i<1000){\n            if(i%10==i/10%10&&i%10==i/100) cnt++;\n        }\n        else if(i%10==i/10%10&&i%10==i/100%10&&i%10==i/1000) cnt++;\n    }\n    cout<<cnt<<endl;\n}\n```\n- 打表的做法\n\n为什么没人想到这题能打表呢？总共也就28个数啊\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int a[30]={1,2,3,4,5,6,7,8,9,11,\n    22,33,44,55,66,77,88,99,111,\n    222,333,444,555,666,777,888,999,1111,2222},n;\n    cin>>n;\n    for(int i=0;i<=28;i++){\n        if(a[i]>n) {cout<<i<<endl;break;}\n    }\n}\n```\n\n## D菱形\n\n- 分析:\n\n逐行输出，先上半部分，再是后半部分\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n; cin>>n;\n    for(int i=0;i<=n/2;i++){\n        for(int j=1;j<=n/2-i;j++) cout<<\".\";\n        cout<<\"#\";\n        for(int j=1;j<=i*2-1;j++) cout<<\".\";\n        if(i!=0) cout<<\"#\";\n        for(int j=1;j<=n/2-i;j++) cout<<\".\";\n        cout<<endl;\n    }\n    for(int i=n/2-1;i>=0;i--){\n        for(int j=1;j<=n/2-i;j++) cout<<\".\";\n        cout<<\"#\";\n        for(int j=1;j<=i*2-1;j++) cout<<\".\";\n        if(i!=0) cout<<\"#\";\n        for(int j=1;j<=n/2-i;j++) cout<<\".\";\n        cout<<endl;\n    }\n}\n```\n\n\n## E金字塔\n\n- 分析:\n\n逐个循环相加就行了\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,ans=0; cin>>n;\n    for(int i=1;i<=n;i++) ans+=i*i;\n    cout<<ans<<endl;\n}\n```\n\n## F假期阅读\n\n- 分析:\n\n最多k*t页，但不能超过n\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,k,t; cin>>n>>k>>t;\n    cout<<min(n,k*t)<<endl;\n}\n```\n\n## G值日\n\n- 分析:\n\n求最小公倍数\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,m,i; cin>>n>>m;\n    for(i=n;i%m!=0;i+=n);\n    cout<<i<<endl;\n}\n```\n\n## H数三角形\n\n- 分析:\n\n循环i 1..n，j 1..i即可，每次判断一下是否存在整数解\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,cnt=0; cin>>n;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=i;j++){\n            if(i*j%2==0) cnt++;\n        }\n    }\n    cout<<cnt<<endl;\n}\n```\n\n## I幂数和\n\n- 分析:\n\n直接暴力枚举所有数，判断是否能拆就行了\n遍历每种可能的情况，计算和是否为这个数就行了\n至于代码中的<<是二进制内左移的意思，用来计算2的n次幂\n比如1<<1是10，变成了2，同理还有右移，自己学习\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int l,r,cnt=0; cin>>l>>r;\n    for(int i=l;i<=r;i++){\n        bool f=false;\n        for(int j=0;j<=20;j++){\n            for(int k=0;k<=20;k++){\n                if((1<<j)+(1<<k)==i) {cnt++;f=true;break;}\n            }\n            if(f) break;\n        }\n    }\n    cout<<cnt<<endl;\n}\n```\n\n\n## J质因数分解\n\n- 分析:\n\n第一空，先输出n，免得后面n的值变掉了\n第二空判断是否算一个因子，当然最后一个是需要特判的\n第三空，既然发现了因子，那么把n减小，变为n/i\n第四空，找的不对，i自增，寻找下一个位置\n第五空，输出最后一个质因数\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint main(){\n    ll n,i=2; cin>>n;\n    cout<<n<<\"=\";\n    for(i=2;i<=n;){\n        if(n%i==0&&n/i!=1){\n            cout<<i<<\"*\";\n            n/=i;\n        }\n        else{\n            i++;\n        }\n    }\n    cout<<i-1<<endl;\n}\n```","tags":["算法"]},{"title":"全排列函数的应用","url":"/ZestfulYK-blog/2025/10/22/全排列函数的应用/","content":"# 全排列函数\n\n## 什么是全排列？\n\n简单来说就是排列组合的所有情况，并按照字典顺序输出\n例如：123全排列的结果为\n\n```yaml\n123\n132\n213\n231\n312\n321\n```\n\n而实际上全排列需要在代码中用复杂的深度搜索来写\n这实在是太复杂了！！！\n于是我就发现了全排列函数这个东西^__^\n现在我们就来学习一下这个高级函数————next_permutation\n\n## 全排列函数\n\n```C++\n#include <iostream>  \n#include <algorithm>  \nusing namespace std;  \nint main()  \n{  \n    int num[3]={1,2,3};  \n    do  \n    {  \n        cout<<num[0]<<\" \"<<num[1]<<\" \"<<num[2]<<endl;\n    }while(next_permutation(num,num+3));  \n    return 0;  \n}\n```\n- 全排列函数详细定义\n对于next_permutation函数，其函数原型为：\n\n    #include <algorithm>\n\n    bool next_permutation(iterator start,iterator end)\n\n当当前序列不存在下一个排列时，函数返回false，否则返回true\n\n- 全排列函数的特性\n\nnext_permutation(num,num+n)函数是对数组num中的前n个元素进行全排列，同时并改变num数组的值。\n\n另外，需要强调的是，next_permutation()在使用前需要对欲排列数组按升序排序，否则只能找出该序列之后的全排列数。比如，如果数组num初始化为2,3,1，那么输出就变为了：\n```yaml\n231\n312\n321\n```\n\n# 全排列函数的应用\n\n[题目链接](https://atcoder.jp/contests/abc326/tasks/abc326_d?lang=en)\n\n题目要求我们按要求完成5*5数独，且只要填ABC，可以有空格子\n一种方法是遍历每一个格子，逐个填入，\n时间复杂度(4^25)，显然不行\n不过我的朋友使用了大量剪枝，最后还是过了\n%%%大佬 qinye_leaf\n\n[代码链接](https://atcoder.jp/contests/abc326/submissions/70334070)\n\n但是我们刚学了全排列函数，就不能使用一下吗？\n你别说，还真能使用！\n我们只要先填写每一行，然后就只用40^5就能计算完了\n因为可以加上一个判断，看看每一行是否符合标准(也算剪枝吧)\n\n```C++\n    vector<string> eachrow(int row) {\n        vector<string> result;\n        string h=string(n-3,'.')+\"ABC\";\n        do{ for(int i=0;i<n;i++){\n            if(h[i]!='.'){\n                if(h[i]==r[row]) result.push_back(h);\n                break;\n            }\n        }\n        }while(next_permutation(h.begin(),h.end()));\n        return result;\n    }\n```\n那么这样我们就能得到每一行的可能情况，每行40种\n之后就可以正常的DFS了\n\n[个人AC代码链接](https://atcoder.jp/contests/abc326/submissions/70340782)","tags":["算法"]},{"title":"广工月赛","url":"/ZestfulYK-blog/2025/10/20/广工月赛/","content":"# ZestfulYK的战绩\n![图片](/images/ggys.png)\n\n# 比赛难度\n中等，以基础题为主，拼尽全力战胜少量难题\n\n# 部分代码\n## F\n- 分析\n很不错的博弈题目，使我的大脑旋转，最后打表做出来了\n\n[题目链接](https://ac.nowcoder.com/acm/contest/119605/F)\n\n![代码](/images/image.png)\n\n代码:\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    if(n==0&&m==0) cout<<\"Bob\"<<endl;\n    else if(n==1&m==0) cout<<\"Alice\"<<endl;\n    else if(n==2&m==0) cout<<\"Bob\"<<endl;\n    else if(n==3&m==0) cout<<\"Bob\"<<endl;\n    else if(n==0&m==1) cout<<\"Alice\"<<endl;\n    else if(n==0&m==2) cout<<\"Bob\"<<endl;\n    else if(n==0&m==3) cout<<\"Alice\"<<endl;//\n    else if(n==1&m==1) cout<<\"Bob\"<<endl;\n    else if(n==1&m==2) cout<<\"Bob\"<<endl;\n    else if(n==1&m==3) cout<<\"Alice\"<<endl;//\n    else if(n==2&m==1) cout<<\"Bob\"<<endl;\n    else if(n==2&m==2) cout<<\"Bob\"<<endl;\n    else if(n==2&m==3) cout<<\"Alice\"<<endl;//\n    else if(n==3&m==1) cout<<\"Bob\"<<endl;\n    else if(n==3&m==2) cout<<\"Bob\"<<endl;\n    else if(n==3&m==3) cout<<\"Alice\"<<endl;\n}\n```\n\n## J\n- 分析\n这题目也不错，但其实看代码找规律就行了\n\n[题目链接](https://ac.nowcoder.com/acm/contest/119605/J)\n\n![代码](/images/J.png)\n\n代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint main(){\n    ll n; cin>>n;\n    ll s=sqrt(n);\n    if(s*s!=n) s++;\n    ll last=n%s;\n    for(int i=last;i>=1;i--) cout<<i<<\" \";\n    for(int j=1;j<=n/s;j++){\n        for(int i=last+j*s;i>last+(j-1)*s;i--) cout<<i<<\" \";\n    }\n}\n```","tags":["算法"]},{"title":"markdown使用教程","url":"/ZestfulYK-blog/2025/10/20/markdown使用教程/","content":"### 标题的使用\n```yaml\n# 一级标题\n## 二级标题\n### 三级标题\n```\n### 字体\n\n**粗体** *斜体* ~~删除线~~ `行内代码`\n\n### 小标题的使用\n\n- 无序列表项\n- 另一个项目\n\n1. 有序列表\n2. 第二项\n\n### 链接，图片\n\n```yaml\n[链接文字](https://example.com)\n![图片描述](https://example.com/image.jpg)\n```\n\n### 引用块\n\n```yaml\n> 这是一个引用块\n> 可以多行使用\n```\n> 这是一个引用块\n> 可以多行使用\n\n### 表格\n\n```yaml\n| 姓名 | 年龄 | 城市 |\n|------|------|------|\n| 张三 | 25   | 北京 |\n| 李四 | 30   | 上海 |\n```\n\n| 姓名 | 年龄 | 城市 |\n|------|------|------|\n| 张三 | 25   | 北京 |\n| 李四 | 30   | 上海 |","tags":["技术"]}]