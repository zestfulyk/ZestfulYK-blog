[{"title":"DP习题笔记","url":"/ZestfulYK-blog/2025/12/16/DP习题笔记1(动态规划的引入)/","content":"# 循环的遍历\n\n- 注意一下最内层的循环是什么，他决定了这一步的决策是什么。\n\n## 例题\n\n[纸币问题 2](https://www.luogu.com.cn/problem/P2840)\n\n- 这一题要我们求完全背包的方案数（考虑顺序）\n- 那么内层循环应该放的是面额的遍历，因为最后一步的面额是不一定的。\n- **正确写法**✔：\n```C++\nfor(int i=1;i<=w;i++)\n   for(int j=1;j<=n;j++)\n      if(i>=a[j])\n        dp[i]=(dp[i-a[j]]+dp[i])%mod;\n```\n\n- **错误写法**❌：\n```C++\nfor(int i=1;i<=n;i++){\n    ll x; cin>>x;\n    for(int j=x;j<=w;j++){\n        dp[j]=(dp[j-x]+dp[j])%mod;\n    }\n}\n```\n- 为什么下面那个是错误的？\n- 因为把当前面额作为内层循环，相当于固定了最后一步只能是这个面额，没法考虑到顺序问题。这样的话第二次只能在第一次的基础上增加。实际上，第一次的面额也可以在第二次的基础上增加。因此这个做法是不正确的。\n**注意**：下面那个方法因为只考虑了最开始的顺序(即输入顺序)，所以只有一种顺序，那么就可以拿来统计**组合数**\n\n在解决这类问题时，关键要问自己：\n- 题目要求的是组合数还是排列数？\n- 我的循环顺序是否允许不同的支付顺序？\n- 我是否在无意中强加了某种顺序限制？(**关键点**)\n对于这道题，既然要求考虑支付顺序，就必须使用金额在外层的循环方式。\n\n# 特殊例题\n## 计算容积不超过n得到的最大的占有体积\n\n- 思路：设$dp[i]$表示不超过i获得的最大值，那么每一个物品的体积是x，价值也是x。\n- 状态转移方程：$$dp[i]=max(dp[i],dp[i-x]+x)$$\n## 例题\n\n[考前临时抱佛脚 - 洛谷](https://www.luogu.com.cn/problem/P2392)\n\n- 题目说可以双核，那么只要一边最接近sum/2就彳亍了，所以可以用上面那个模型\n# 01背包0也有值的问题\n\n- 在正常的01背包中，如果遍历不到就不管了，但是现在要求不能放入时也有一定的值，那么这时就要管了，在体积不够时，每一个都只有一种选法，那就是不选。所以每一个都要加上不选所对应的值。\n## 例题：\n\n[5 倍经验日 - 洛谷](https://www.luogu.com.cn/problem/P1802)\n\n- 题目说了在打不过时也能得到经验，你要是不给玩家经验，当然是不对的啦\n\n\n# DP的一般思路\n\n- 首先看看是否是背包或者背包的变形，要是是的话就简单了\n- 看一下每一次有几种转移方式，把可能的变化列一下，看看是否有规律\n- 在这一讲还是不用区分特殊类型的DP的","tags":["算法"]},{"title":"我这学期犯过的唐","url":"/ZestfulYK-blog/2025/12/16/我这学期犯过的唐/","content":"\n# 不知道vector的size是size_t类型\n\n- 因为是size_t所以直接加减会出错，比如减成负数的时候。\n\n# 内层循环变量写错\n\n- 这个会导致外层循环少了几次\n\n# sort里面的数据范围没开正确\n\n- 例如要对n* m的数据排序，却只写了n\n\n# 不看清读入顺序\n\n- 看清读入的是有序的还是乱序的，不要被样例蒙蔽了双眼","tags":["算法"]},{"title":"构造操作类题目","url":"/ZestfulYK-blog/2025/12/16/构造操作类题目/","content":"# 定义\n\n- 构造一些操作，使得数据满足操作要求，通常还会有次数限制\n\n# 方法\n\n此类题目现在遇到过三种做法：\n\n- 一种是直接操作，不关心部分值，直接对全局操作，使得再让全局满足要求的同时，使得部分也满足要求\n- 另一种是进行操作，最后只改变一个量，每次用多步做一步\n（和魔方有点像？）\n\n# 例题\n\n1.[B. Siga ta Kymata](https://codeforces.com/contest/2163/problem/B)\n\n- 题目描述：\n给你一个排列 $^{\\text{∗}}$ 。从 $1$ 到 $n$ 的每个整数的排列 $p$ 。您还拥有一个大小为 $n$ 的二进制 $^{\\text{†}}$ 字符串 $s$ ，其中 $s_i = \\mathtt{0}$ 代表所有 $1 \\le i \\le n$ 。您最多可以执行以下操作 $5$ 次：\n选择任意两个整数 $l$ 和 $r$ ，使得 $1 \\le l \\le r \\le n$ .然后，对于每一个 $i$ 使得 $l< i< q$ 和 $\\min(p_l, p_r) < p_i < \\max(p_l, p_r)$ 同时成立，你将把 $s_i$设为 $\\mathtt{1}$ 。\n您还会得到一个大小为 $n$ 的二进制字符串 $x$ 。执行运算后，对于每一个 $1 \\le i \\le n$ 都必须成立：如果 $x_i = \\mathtt{1}$ ，则 $s_i = \\mathtt{1}$ 。注意，如果 $x_i = \\mathtt{0}$ ，那么 $s_i$ 可以有**任意**值。\n找出最多**5**个运算序列，使上述条件得到满足，或者报告不可能做到这一点。请注意，您**不必**尽量减少操作次数。\n\n解法：\n```txt\n|----------------|-------------------n------------\n|                |                   |           |\n|----------------|-------------------|——————————a[n]\n|                |                   |           |\na[1]----------------------------------------------\n|                |                   |           |\n|                |                   |           |\n|----------------1--------------------------------\n```\n\n- 一共画了5个框，也就是5次操作的范围\n- 这里实际上是把所有能改变的全改变了，然后也就满足了要求\n- 所以5次也是合理的，证明了做法的正确\n\n2.[西安之泪 - 洛谷](https://www.luogu.com.cn/problem/P14755?contestId=296933)\n\n-  题目描述：\n给定一颗无根树,共有n个顶点。每个顶点 i 都具有一个点权$a_i$，初始所有点权都为0。\n你可以进行如下的操作最多不超过$3n$次：\n指定顶点的编号 r,u (1≤r,u≤n)，使得这棵树暂时以顶点 r 为根，随后对于顶点 u 的子树中的每一个顶点 v，将其点权修改为 av​⊕u。此处的 ⊕ 表示**按位异或**。\n\n这一题就是尝试操作每一个顶点，分步完成。\n让每个顶点的邻居给这个顶点发一次，那么最终剩下的节点就被⊕了出度数-1次。如果是偶数，不变；但是奇数时，为了保持不变，那么我们在自己给自己发一次就行了。\n\n","tags":["算法"]},{"title":"程C笔记2","url":"/ZestfulYK-blog/2025/12/16/程C笔记2/","content":"# 递归\n\n## 函数的定义\n\n注意一下在命名函时，可以不写参数的名称，比如：\n```C++\nvoid fun(int,int)\n```\n\n# 结构体排序\n\n```C++\nvoid mySwap(Data *p1,Data *p2){//交换函数\n    Data t=*p1;\n    *p1=*p2;\n    *p2=t;\n}\nfor(int i=0;i<n-1;i++){\n    for(int j=0;j<n-i-1;j++){\n       if(a[j].num>a[j+1].num || \n       (a[j].num==a[j+1].num && a[j].value>a[j+1].value)){\n           mySwap(&a[j],&a[j+1]);\n        }\n    }\n}\n```\n\n- 传入时注意，要加上&，传入地址，使得函数可以交换地址。\n\n# 数组的定义\n\n- 使用new和delete一起运算。\n\n## 基本方法\n\n```C++\n// 创建一维动态数组\n数据类型* 指针名 = new 数据类型[元素个数];\n// 释放内存\ndelete[] 指针名;\n```\n\n## 一维数组\n### 示例\n\n```C++\n// 方法1：创建基本类型的一维数组\nint n = 5;\nint* arr1 = new int[n];  // 创建包含5个整数的数组\ndelete[] arr1;\n```\n\n## 二维数组\n\n- 比一维数组多了一个*\n\n### 内存连续\n\n```C++\n // 分配连续内存\nint** arr = new int*[rows];  // 创建行指针数组\narr[0] = new int[rows * cols];  // 分配所有元素的空间\n\n// 设置行指针\nfor (int i = 1; i < rows; i++) {\n    arr[i] = arr[i-1] + cols;\n}\n```\n\n### 内存不连续\n\n```C++\n// 创建二维数组\nint** arr = new int*[rows];  // 创建行指针数组\nfor (int i = 0; i < rows; i++) {\n    arr[i] = new int[cols];  // 为每一行分配内存\n}\n```","tags":["算法"]},{"title":"不定积分习题","url":"/ZestfulYK-blog/2025/12/13/不定积分习题/","content":"# 第一类有理积分\n\n## 主要方法\n\n- 放入分子\n- 放入分子的部分\n- 放入分母\n- 放入分母的部分\n- 特殊构造\n  |--商的导数求积分部分\n  |--两个函数相乘求导$e^x$\n  |--三角函数构造$\\tan x$\n- 最后复习一下一些特殊的积分公式\n## 放入分子\n- 这一中方法比较基础。\n- 如果是放入分子的，那么必然是如下形式的$$\\int \\frac{f'(x)}{f(x)}\\,dx$$\n- 这样就能得到$$\\int \\frac{df(x)}{f(x)}$$\n- 所以先看一下分母求导的结果有没有可能等于分子，如果是，那么就可以用这种方法\n### 例题\n$$\\int \\frac{\\sin x+\\cos x}{\\sqrt[3]{\\sin x-\\cos x}}\\,dx$$\n## 放入分子的部分\n\n- 这个通常出现在三角函数中，因为这样可以把所有三角函数化程同名。\n- 然后放入时注意一下和分子的形式要对上。\n### 例题\n$$\\int \\frac{\\sin x\\cos x^3}{1+\\cos x^2}\\,dx$$\n- 这题直接放入$\\sin x$还不行，因为要注意一下分母的形式。\n所以注意到可以凑出$\\sin 2x$，这样放入时形式就一样了\n\n\n## 放入分母\n\n- 放入分母的实际上是这种形式$$\\int f'(x)f(x)\\,dx$$\n- 然后被$f'(x)$正好是分数的形式，看起来就像分式罢了。\n- 所以记得先看看分子求导是否可能是一个分式，比如$\\ln x$或者是$\\sqrt{x^2-1}$这种形式的式子\n- 所以也有可能是分子的导数会穿一部分到分子来，所以建议是先对分子的部分进行求导\n- 主要问题是，出题人会把求导结果化到最简，导致看不出来\n### 例题\n 1. \n$$\\int \\frac{\\sqrt{\\ln(x+\\sqrt{1+x^2})+1}}{\\sqrt{1+x^2}}\\,dx$$\n 2. \n$$\\int\\frac{e^{\\sqrt{1+\\sin x}}\\cos x}{\\sqrt{1+\\sin x}}\\,dx$$\n## 放入分母的部分\n\n- 这一种情况通常是在含有$\\ln x$和$\\frac{1}{x}$时使用，因为可以把$\\frac{1}{x}$放入。\n目前只发现这一种情况可以用这个来解决\n\n### 例题\n$$\\int \\frac{\\ln x^2}{x(1+\\ln x^2)}\\,dx$$\n## 特殊构造\n\n- 比较难想到，但是遇到以后下次就有概率会写\n### 商的导数求积分部分\n\n- 这一种之前做过一次，可以看一下分部积分的**商的导数求积分部分**。\n- 传送门：[分步积分笔记](https://zestfulyk.github.io/ZestfulYK-blog/2025/12/07/%E5%88%86%E6%AD%A5%E7%A7%AF%E5%88%86/)\n\n### 两个函数相乘导数的积分\n\n- 实际上，这个是$$\\int e^{ax}f(x)\\,dx$$\n然后可以被转化为$$\\int e^{ax}(ah(x)+h'(x))\\,dx$$\n所以是$e^{ax}$和别的函数的乘积得到的，通常也只有$e^{ax}$能有这种特殊做法。\n\n#### 为什么只有$e^{ax}$有这个性质\n- $e^{ax}$求导有不变性，这样求导了以后才会出现这种情况，所以只有$e^{ax}$才应当考虑有无这种特殊解法，其余的直接计算就好了，不要想那么多\n\n#### 识别方法：\n1. **观察结构**：被积函数通常包含指数函数$e^{ax}$与另一个函数f(x)的乘积。\n2. **分析 $f(x)$**：尝试将 $f(x)$拆分为两部分，其中一部分是某个函数 $h(x)$，另一部分是其导数 $h'(x)$（或 $ah(x)+h'(x)$）。常见的线索包括：\n- $f(x)$ 为有理函数或三角函数，且分子或分母具有导数的特征。\n- 通过经验猜测$h(x)$的形式.\n1. **验证**：对猜想的 $h(x)$ 求导，检查是否满足 $f(x)=ah(x)+h'(x)$\n\n\n\n#### 例题：\n\n$$\\int \\frac{(1+\\sin x)e^x}{1+\\cos x}\\,dx$$\n发现有$e^{ax}$考虑一下是否可以这么做，那么先计算前面能否拆成$f(x)=ah(x)+h'(x)$，计算得到:$$(\\frac{\\sin x}{1+\\cos x})'=\\frac{1}{(1+\\cos x)}$$\n所以这么拆分是合法的。\n最后得到：\n$$\\frac{e^x \\sin x}{1+\\cos x}+C$$\n此外，还有一题和这个思路十分类似：$$\\int \\frac{\\cos x^2-\\sin x}{\\cos x(1+e^{\\sin x}\\cos x)}\\,dx$$\n注意到：$$(e^{\\sin x}\\cos x)'=\\cos x^2-\\sin x$$\n所以可以把分子放入进行计算，这里依然是$e^{ax}$的性质。此外放入以后发现少了一个$e^{\\sin x}$，那么再加上一个$e^{\\sin x}$再$dx$里面，正好使得分母多了一个$e^{\\sin x}$，那么换元一下就是有理函数的积分了\n\n**总结**：遇到$e^{ax}$，求导一下总是有用的，能简化计算。\n\n### 余正弦化正切\n\n- 遇到这么一种情况，有$\\sin x$和$\\cos x$，但是表现出的却是加法的形式，无法把其中一部分提取出来，那么这时我们就应该考虑一下是不是可以化成$\\tan x$来计算。\n\n### 例题\n\n1.\n$$\\int \\frac{dx}{\\sin x^2+2\\cos x^2}$$\n- 这里无法采用上述提及的所有方法，于是我们采用上下同时除以$\\cos x^2$的方法来计算，得到有关$\\sec x^2$和$\\tan x^2$的式子，这样就可以计算了。\n\n2.$$\\int \\frac{x+\\sin x\\cos x}{(\\cos x-x\\sin x)^2}\\,dx$$\n- 注意到下面部分的导数并非上半部分，上半部分也不能被提取，那么考虑能否转换为$\\tan x$和$\\sec x$的式子，于是先提取一个$\\cos x$，得到：$$\\int \\frac{x\\sec x+\\tan x}{(1-x\\tan x)^2}\\,dx$$\n- 接着就发现下面的导数等于上面部分了，那么就好做了。\n\n\n## 特殊积分公式复习\n- 首先是特殊的三角公式\n$$\\int \\sec x\\,dx=ln|\\sec x+\\tan x|+C$$\n$$\\int \\csc x\\,dx= ln|\\csc x-\\cot x|+C$$\n- 接下来是裂项公式\n$$\\int \\frac{1}{x^2-a^2} \\, dx = \\frac{1}{2a}\\ln\\left|\\frac{x-a}{x+a}\\right| + C$$\n$$\\int \\frac{1}{a^2-x^2} \\, dx = \\frac{1}{2a}\\ln\\left|\\frac{a+x}{a-x}\\right| + C$$\n(要是记不住这个好像也可以直接当有理函数来做？)\n- 最后是反三角式\n$$\\int \\frac{1}{\\sqrt{a^2-x^2}} \\, dx = \\arcsin\\frac{x}{a} + C$$\n$$\\int \\frac{1}{x^2+a^2} \\, dx = \\frac{1}{a}\\arctan\\frac{x}{a} + C$$\n这一个只有两种情况，剩下的老老实实进行$\\sec x$和$\\tan x$代换\n上下其实都会消去一个$\\frac{1}{a}$但是下面那个是二次式子，所以就剩下了一个$\\frac{1}{a}$.\n## 额外提醒\n\n- 注意$\\frac{1}{\\cos x}$和$\\sec x$的转换，如果只是单出现一个，那么就转换成没有分数的式子\n- 注意一下同时含有$\\tan x\\text{和}\\sec x$的分式，可能需要展开消去部分$\\cos x$来简化计算\n- 需不需要展开计算看你是否可以消去\n\n# 第二类换元积分\n\n## 主要方法\n\n- 第二类换元积分开始和有理积分接近，所以换元完要考虑一下有理积分。\n- 含有根式的只有$\\sqrt{a^2-x^2}$有公式，其他老老实实计算！\n- 倒带换是把x换为$\\frac{1}{t}$，别代换错了\n- 要是根式含有$a^x$，那么令整一个根号为t，其他令$a^x$为t\n\n## 简单根式代换\n\n- 除了$\\tan x\\text{和}\\sec x$的代换以外，还有这么一种情况：\n$$\\int \\frac{x^2\\,dx}{\\sqrt{(x^2-a^2)^3}}$$\n- 实际上，里面的次数是没有影响的，因为每一个都可以拆出一个，得到三次式，然后再老老实实计算。\n- 其他含有根式的，要么时属于有理函数的积分，有吗就是可以直接按照三角换元做出来。\n### 例题\n\n$$\\int \\frac{dx}{(1+x^2)\\sqrt{1-x^2}}$$\n- 直接把x代换为$\\sin t$即可，然后这个式子貌似很熟悉？\n## 质数函数的代换\n\n- 例如分母含有$e^x$等赘述函数时，直接代换这一部分\n- 如果在根式中，代换整个根式\n### 例题\n\n#### 代换指数函数\n\n- 例如求\n$$\\int \\frac{1}{e^x+e^{2x}}\\,dx$$\n- 代换$x=\\ln t(e^x=t)$得到$$\\int \\frac{1}{t+t^2}\\frac{1}{t}\\,dt$$\n- 就能变成有理函数的积分了\n#### 代换整个根式\n\n- 例如求$$\\int \\frac{1}{\\sqrt{e^x+1}}\\,dx$$\n- 代换整个根号$x=\\ln(t^2-1)\\,(t=\\sqrt{e^x+1})$得到$$\\int \\frac{1}{t}\\frac{2t}{t^2-1}\\,dt$$\n- 从而又被化成了有理函数的积分\n\n## 倒代换\n\n- 代换为$\\frac{1}{t}$，别把$\\frac{1}{x}$代换成了t就彳亍\n- 然后注意时用在幂函数上，别搞错就彳亍\n### 例题\n\n- 如计算$$\\int \\frac{1}{x(x^6+1)}\\,dx$$\n- 直接代换得到$$-\\int \\frac{1}{\\frac{1}{t}((\\frac{1}{t})^6+1)}\\frac{1}{t^2}\\,dt=\n- \\int \\frac{t^5}{1+t^6}\\,dt$$\n- 就变成第一类换元积分了\n\n## 特殊例子\n\n- 看似一般的根式，凑成可以三角代换的式子\n\n### 例题\n\n$$\\int \\sqrt{2x-x^2}\\,dx$$\n- 先凑一下，得到$$\\int \\sqrt{1-(x-1)^2}\\,dx$$\n- 然后就会计算了\n\n **关注ZestfulYK喵，谢谢喵！**","tags":["数学"]},{"title":"几何计算笔记","url":"/ZestfulYK-blog/2025/12/11/几何计算笔记/","content":"# 凹凸多边形的判断\n\n## 重要知识：叉积\n\n### 几何意义：\n\n符号代表了叉积两个向量的转向：\n \\> 0 逆时针\n < 0 顺时针\n = 0 共线\n\n### 基本原理\n\n对于连续三个点A、B、C：\n叉积 = (B.x - A.x) * (C.y - B.y) - (B.y - A.y) * (C.x - B.x)\n要是是向量的话是：a.x * b.y- a.y * b.x\n\n这个叉积实际上计算的是向量 **AB** 到向量 **BC** 的旋转方向。\n\n## 实现方法\n\n### 可视化解释\n\n考虑四边形$ABCD$，我们按顺序（如逆时针）检查每个顶点：\n\n如果所有顶点的叉积都**保持同号**（全部为正或全部为负），说明多边形所有顶点都朝同一个方向\"拐弯\"，这就是凸多边形。\n\n```txt\nC(2,2) ────── D(0,2)\n│              │\n│              │\nB(2,0) ────── A(0,0)\n```\n\n**在顶点A处**：\n- 向量DA = A - D = (0-0, 0-2) = (0, -2)\n- 向量AB = B - A = (2-0, 0-0) = (2, 0)\n- DA × AB = 0* 0 - (-2)* 2 = 4 > 0（逆时针）\n\n**在顶点B处**：\n- 向量AB = (2, 0)\n- 向量BC = C - B = (2-2, 2-0) = (0, 2)\n- AB × BC = 2* 2 - 0* 0 = 4 > 0（逆时针）\n\n### 凹四边形的反例\n\n对于凹四边形，某个顶点会出现相反的转向：\n\n```txt\n     D(1,2)\n    /B(1,1) ← 凹点\nA(0,0)─-───────C(3,0)  \n```\n\n在凹点B处，转向会与其他顶点相反。\n\n## 算法实现步骤\n\n- **计算各个叉积**\n\n```txt\ncp₁ = 叉积(向量AB, 向量BC)  // 在点B处\ncp₂ = 叉积(向量BC, 向量CD)  // 在点C处\ncp₃ = 叉积(向量CD, 向量DA)  // 在点D处\ncp₄ = 叉积(向量DA, 向量AB)  // 在点A处\n```\n\n- 1. **判断符号一致性**：\n    - 如果所有$cp_i \\geq 0$，则为逆时针排列的凸四边形\n    - 如果所有$cp_i\\leq 0$，则为顺时针排列的凸四边形\n    - 否则为凹四边形\n\n\n### 实例代码\n\n```C++\nstruct point{double x,y;};\n\ndouble chaji(const point &a,const point &b,const point &c{\n  point v1,v2;//计算向量\n  v1.x=b.x-a.x; v1.y=b.y-a.y;\n  v2.x=c.x-b.x; v2.y=c.y-b.y;\n  return v1.x*v2.y-v1.y*v2.x;\n  //转换成向量以后，x和y交换着乘\n}\n\nvoid solve(){\n  point a,b,c,d;\n  cin>>a.x>>a.y;\n  cin>>b.x>>b.y;\n  cin>>c.x>>c.y;\n  cin>>d.x>>d.y;\n  double cj1=chaji(a,b,c);\n  double cj2=chaji(b,c,d);\n  double cj3=chaji(c,d,a);\n  double cj4=chaji(d,a,b);\n  if((cj1>0&&cj2>0&&cj3>0&&cj4>0)||(cj1<0&&cj2<0&&cj3<0&&cj4<0)){\n    cout<<\"Yes\"<<endl;//要同号才行\n  }\n  else cout<<\"No\"<<endl;\n}\nsigned main(){\n    solve();\n    return 0;\n}\n```\n\n# 直线的计算\n\n## 写在前面的话\n\n**傻逼C++的double的精度不高所以表示直线建议使用$Ax+By+C=0$**\n\n然后就变简单了喵~\n## 计算公式\n\n$$\\begin{cases}\nA=p2_y-p1_y \\\\\nB=p1_x-p2_x \\\\\nC=p2_x*p1_y-p1_x*p2_y\n\\end{cases}\n$$\n\n之后不要忘记除以他们的最大公约数，用来去重，这点非常重要，因为可能产生倍数\n\n## 例题\n\n[K-colinear Line](https://vjudge.net/contest/771553#problem/B)\n\n这一题要求我们计算经过k个点的直线数量，这里最重要的是理解怎么消去除法。\n这题的做法还是蛮多样的，好友qinye_leaf的解法是：$$(x_1-x_0)(y-y_0)==(y_1-y_0)(x-x_0)=>\\frac{x_1-x_0}{x-x_0}=\\frac{y_1-y_0}{y-y_0}$$\n此外上面的做法也是可行的，总之消去除法，然后防止重复(这是一个好问题)\n\n# 圆的计算\n\n## $\\pi$的取值建议\n\n- 如果有了规定值，那么直接使用\n- 没有的话，处于精度考虑，可以使用$\\arccos (1.0)$来代替、\n# 多边形的计算\n\n## 几何图形面积计算\n### 例一\n\n例题：[P. Area of a Star](https://codeforces.com/problemset/problem/630/P)\n需要我们计算多角形的面积\n这一题的话有两种做法，一种是直接分成$2*n$个小三角形，而每一个三角形的三个内角都是已知的，因此可以直接计算。\n另外一种做法是发现可以整体减空白，稍微复杂一点，但也可行。\n#### 补充知识\n复习一下正弦定理：$$\\frac{a}{\\sin \\alpha}=\\frac{b}{\\sin \\beta}=\\frac{c}{\\sin \\gamma}=2R$$\n因此这一题只知道三个角和一条边是可以直接计算的。\n\n### 例二\n\n#### 例题：[B. Mister B and Angle in Polygon](https://codeforces.com/problemset/problem/820/B)\n需要我们在多边形上找到三个点，使得构成的角度和给定角度最接近。\n\n**重要观察**：在正n边形中，从一个顶点出发，连接所有其他不相邻的顶点（即除相邻两个顶点外的所有顶点），这些连线会将这个顶点的内角等分成$n−2$个相等的角，每个角的度数为 $\\frac{180}{n}$。\n\n> 证明：把多边形放到一个圆里面，然后发现相同弦所对的角相等，所以原命题是成立的\n\n**推论**：那么在这个多边形上任取三个点构成的角也必然是$\\frac{180}{n}$.\n\n> 证明：和刚才一样，只要证明每个条角所对的弦都能在同一个顶点上构造出来\n\n所以解出这题的步骤是：\n- 先看是否大于等于最大角，如果是，那么输出1 2 3\n- 否则计算中间值用$\\frac{180}{n}$的倍数代替。","tags":["算法"]},{"title":"程C笔记","url":"/ZestfulYK-blog/2025/12/11/程C笔记/","content":"## 1. 头文件和命名空间\nC++ 中的 string 类定义在头文件 string 中，通常使用 std 命名空间。\n\n```c++\ns3=strcat(s1,s2);//加在后面\nint x=strcmp(s1,s2)//返回三种情况,见下面\ncout<<strlen(s1)<<endl;//输出的是长度，等同于s1.length()\nstrcpy(s1+x1,s2+x2);//把前面的对应部分添加到前面去，完全覆盖之前的内容\nmemcpy(a+x1,b+x2,sizeof(int)*8);//也是把后面的放到前面，只不过需要规定放入的内容\nsizeof(s1);//考虑后面的'\\0'，比strlen大1.\n```\n$$ x=strcmp(s1,s2)= \n\\begin{cases}\n -1  \\ \\ \\ \\ \\ s1 \\leq s2\\\\\n0\\ \\ \\ \\ s1=s2\\\\\n1\\ \\ \\ \\ s1 \\geq s2\n\\end{cases}\n$$\nmemcpy例子：\n```C++\nint a[8]={1,2,3,4,5,6,7,8};\nint b[10]={10,9,8,7,6,5,4,3,2,1};\nmemcpy(b,a,sizeof(int)*8);\nfor(int i=0;i<10;i++)\n    cout<<b[i];\n```\n输出：\n```C++\n1234567821\n```\n\n## 2.函数\n```C++\nint maxGap(int* p, int n)//传入p[0]的地址，能改变在主函数里的值\nstatic int t;//静态局部变量，下次还是调用上次的值\n//例如：\nint cnm(int p,int q){\n\tstatic int t=0;\n\tt+=p+q;\n\treturn t;\n}\nsigned main(){\n\tcout<<cnm(1,2)<<cnm(2,3)<<endl;\n}\n```\n\n- 局部变量，全局变量，如果多个声明，那么优先使用内部的数据\n```C++\nint a=5;\nint main(){\n\tint a=10,b=20;\n\tfor(int i=1;i<=3;i++){\n\t\tcout<<a++<<\" \"<<b<<endl;\n\t\t{\n\t\t\tstatic a=0;\n\t\t\tfor(int j=1;j<=5;j++){\n\t\t\t\ta+=j;\n\t\t\t}\n\t\t\tb+=a;\n\t\t}\n\t}\n}\n```\n\n- 要根据函数返回的类型来决定函数的类型\n- 要根据函数内的使用变量来决定函数使用的参数值\n```C++\n//例如：\nchar* fun(int c){//程C一般不用string，自己写都行\n\treturn \"yes\";\n}\nint* fun1(int c){\n\tint a[]={1,2,3};\n\treturn a;\n}\n```\n# C++变量初始化\n\n\n```C++\nint a=10;\nbool b=1;//b=true;\nchar c='c';\nint a[10]={1,2,3,4};\nint a[]={1,2,3,4};\nint a[3][3]={1,2,3,5,6};\nint a[3][3]={{1,2},{3,4}};\nint solve(int a,int b=10){//有时可能定义在mian函数前面\n\treturn a+b;//有值用值，反之用默认值\n}\n```\n\n# C++ 插入排序\n\n```C++\nvoid insertSort(int arr[],int n){\n\tfor(int i=1;i<n;i++){\n\t\tint key=arr[i];\n\t\tint j=i-1;\n\t\twhile(j>=0&&key<arr[j]){//注意不是和相邻元素比较\n\t\t\tarr[j+1]=arr[j];\n\t\t\tj--;\n\t\t}\n\t\tarr[j+1]=key;\n\t}\n}\n```\n\n# C++斐波那契数列\n\n```C++\nint climbStair(int n){\n\tif(n<=2) return n;\n\tint prev2=1;\n\tint prev1=2;//注意此处的定义是反过来的，上课被坑到了（\n\tint current;\n\tfor(int i=3;i<=n;i++){\n\t\tcurrent=prev1+prev2;\n\t\tprev2=prev1;\n\t\tprev1=current;\n\t}\n\treturn current;\n}\n```\n\n# 汉诺塔问题\n\n```C++\nvoid digui(int n,char start,char temp,char target){\n\tif(n==1){\n\t\tprintf(\"%d:%c-->%c\\n\",n,start,target);//只有一个直接移动\n\t\treturn;\n\t}\n\tdigui(n-1,start,target,temp);//前n-1个到转移柱子上\n\tprintf(\"%d:%c-->%c\\n\",n,start,target);//把第n个移动到目标柱子上\n\tdigui(n-1,temp,start,target);//前n-1个到目标柱子上\n}\n```\n\n# 最大公约数函数\n\n```C++\n#defien ll long long\nll gcd(ll a,ll b){\n\tif(b==0) return a;\n\t//if(a%b==0) return b;\n\treturn gcd(b,a%b);\n}\n//pow返回的是浮点型，注意类型的转换\n```\n# 上机课J题\n\n## 算法原理\n- 这是$Stern–Brocot$ 树,用于生成全部有理数的一种函数\nOI wiki 链接：[Stern–Brocot 树与 Farey 序列 - OI Wiki](https://oi-wiki.org/math/number-theory/stern-brocot/)\n- 首先规定$\\frac{0}{1}$是0,$\\frac{1}{0}$是$\\infty$，接下来每次在他们中间插入它们的中位分数，即$\\frac{a+c}{b+d}$.\n- 其次也可以用三元组来计算这些有理分数，先设定$$\\left(\\frac{0}{1},\\frac{1}{1},\\frac{1}{0}\\right)$$ 为初始状态，然后每一个节点设$$\\left(\\frac{a}{b},\\frac{p}{q},\\frac{c}{d}\\right)$$\n  计算$$\\left(\\frac{a}{b},\\frac{a+p}{b+q},\\frac{c}{d}\\right),\\left(\\frac{a}{b},\\frac{p+c}{q+d},\\frac{c}{d}\\right)$$\n  作为左右节点，有用的部分是计算得到的节点\n## 证明\n\n- 考虑矩阵$$A= \\begin{pmatrix} b & d \\\\ a & c \\end{pmatrix}$$\n- 根是单位阵\n- 左边的节点是乘上矩阵$$L = \\begin{pmatrix} 1 & 1 \\\\ 0 & 1 \\end{pmatrix}$$\n- 右边的节点是乘上$$R = \\begin{pmatrix} 1 & 0 \\\\ 1 & 1 \\end{pmatrix}$$\n- 当然，加入的节点还是原来的算法\n\n- 单调性的话自然成立，可以理解为糖水混合，不会比浓度高的浓，也不会比浓度低的淡\n**然后为什么一定是互质即最简呢？**\n\n根据**裴蜀定理**\n> 设 𝑎,𝑏 是不全为零的整数。那么，对于任意整数 𝑥,𝑦，都有 $gcd(𝑎,𝑏) ∣𝑎𝑥 +𝑏𝑦$ 成立；而且，存在整数 𝑥,𝑦，使得 $𝑎𝑥 +𝑏𝑦 =gcd(𝑎,𝑏)$ 成立。\n\n这里我们取x=y=1，那么就有新的分子分母也互质。","tags":["数学"]},{"title":"定积分笔记","url":"/ZestfulYK-blog/2025/12/10/定积分笔记/","content":"# 定义式\n\n$$\\Sigma_{i=1}^nf(\\xi_i)\\Delta x_i$$\n# 几何意义\n\n曲线和x轴，直线$x=a$,$x=b$围成的面积\n# 用定义式写简单积分\n\n### 例题：\n\n$$\\int_0^1x^2\\,dx$$\n首先先把$[0,1]$分成n等份，每份是$\\frac{1}{n}$\n然后按照定义式，取$x_i=\\frac{i}{n},\\xi_i=\\frac{i}{n}$\n所以：$$\\int_0^1x^2\\,dx=\\Sigma_{i=1}^nf(\\xi_i)\\Delta x_i=\\Sigma_{i=1}^n(\\frac{i}{n})^2·\\frac{1}{n}=\\frac{1}{n^3}\\Sigma_{i=1}^ni^2=\\frac{1}{n^3}\\frac{1}{6}(n+1)(2n+1)=\\frac{n(n+1)(2n+1)}{6n^3}=\\frac{1}{3}$$\n最后记得对n取一下极限就行了\n\n# 把极限改写成积分形式\n\n由于积分是可以转化为极限的，那么同样也可以反过来计算。\n\n## 例题：\n这里需要弄清改把什么看作是$\\xi_i$,什么又看做是$\\Delta x_i$\n不过通常是取相同的数\n- 1.$$\\lim_{n\\to \\infty}\\frac{1}{n}\\Sigma_{i=1}^n\\sqrt{1+\\frac{i}{n}}$$\n然后会有一个非常重要的观察点，必然会有$\\frac{i^a}{n^a}$和$\\frac{a}{n}$出现，这就说明了你划分为n份的范围和每个区间的取值情况。\n\n所以对上面这个式子进行变形得到：$$\\lim_{n\\to \\infty}\\Sigma_{i=1}^n\\frac{1}{n}\\sqrt{1+\\frac{i}{n}}$$\n所以每一份是$\\frac{1}{n}$,每个区间的取值是$\\frac{i}{n}$.\n答案为：$$\\int_0^1\\sqrt{1+x}$$\n但是就一定要这么理解吗？\n实际上，我们也可以把1-2的区间分成n份，那么每一份还是$\\frac{1}{n}$,但是每份的取值变成了$1+\\frac{i}{n}$。\n因此答案也可以是：$$\\int_1^2\\sqrt{x}$$\n\n# 定积分的性质：\n\n## 性质1\n$$\\int_a^bf(x)\\,dx=-\\int_b^af(x)$$\n### 推论\n\n$$\\int_a^af(x)=0$$\n### 解释\n- 代数角度$\\Delta x_i=\\frac{b-a}{n}$所以在上下反转时会变号\n- 几何角度：理解为有向的面积\n## 性质2\n\n$$\\int_a^b\\,dx=b-a$$\n### 解释\n- 相当于一个矩形的面积，宽是1，长是b-a。\n## 性质3 线性性\n\n**此性质又称作不定积分的线性性**\n即满足数乘和加减法\n数乘：\n$$\\int_a^bkf(x)\\,dx=k\\int_a^bf(x)\\,dx$$\n加减法：\n$$\\int_a^bf(x)\\pm g(x)\\,dx=\\int_a^bf(x)\\,dx\\pm\\int_a^bg(x)\\,dx$$\n\n实际上，这个性质可以转换为极限的线性性\n## 性质4 拆分定理\n\n$$\\int_a^bf(x)\\,dx=\\int_a^cf(x)\\,dx+\\int_c^bf(x)\\,dx$$\n实际上，这个公式就是把要计算的面积拆成多个部分\n当位置不一样的时候，也可以看成是减去一部分\n## 性质5 保号性\n\n不定积分的保号性\n如果有在$[a,b]$上$f(x)\\geq0$那么\n$$\\int_a^bf(x)\\,dx\\geq0$$\n其实这又是极限的保号性\n\n然后就有：\n如果$f(x)\\geq g(x)$\n$$\\int_a^bf(x)\\,dx\\geq\\int_a^bg(x)\\,dx$$\n\n## 性质6\n$$\\int_a^bf(x)\\,dx\\leq ∫_a^b|f(x)|\\,dx\\,(a<b)$$\n要证明这个式子，实际上先计算$$-|f(x)|\\leq f(x)\\leq|f(x)|$$各个式子分别积分，然后就能得到上面那个式子了\n\n## 性质7 估值定理\n\n$$m(b-a)\\leq ∫_a^bf(x)\\,dx \\leq M(b-a)$$\n\n实际上，这个式子是对$$m\\leq f(x)\\leq M$$\n分别积分得到的，也可以理解为算了两个矩形的面积\n\n### 应用\n\n通常拿来估计值和计算边界情况\n试证:$$1\\leq ∫_0^{\\frac{\\pi}{2}}\\frac{\\sin ⁡x}{x}\\,d​x \\leq \\frac{\\pi}{2}$$\n首先先把常数换成积分，然后比较积分内的值就行了\n$$\\int_0^{\\frac{\\pi}{2}}\\frac{2}{\\pi}\\leq\\int_0^{\\frac{\\pi}{2}}\\frac{\\sin ⁡x}{x}\\,d​x \\leq \\int_0^{\\frac{\\pi}{2}}\\,dx$$\n这样，问题就被转化为了证明$$\\frac{2}{\\pi}\\leq\\frac{\\sin ⁡x}{x}\\leq 1$$\n## 性质8 积分中值定理\n\n$$\\int_a^bf(x)\\,dx=f(\\xi)(b-a)\\,(\\xi\\in[a,b])$$\n用性质7加上介值定理就能证明了，同时$f(\\xi)$也被称为函数的平均值\n\n### 应用\n\n注意要乘上长度即$(b-a)$这一段\n例如：$$ \\lim_{x\\to\\infty} f(x)=1，求 \\lim_{n\\to\\infty} ∫_{n}^{n+2} x·sin(\\frac{3}{x})·f(x) dx$$\n这里直接中值定理得到：\n$$∫_{n}^{n+2}x\\sin(\\frac{3}{x}) f(x) dx = (n+2-n)\\xi_n sin(\\frac{3}{\\xi}) f(ξ_n)$$\n最后就相当于计算关于$\\xi$的一个极限","tags":["数学"]},{"title":"时空间复杂度笔记","url":"/ZestfulYK-blog/2025/12/09/时空间复杂度笔记/","content":"## 2秒时间限制下的可执行操作数\n### 一般经验估算\n- **保守估计**：C++在2秒内可执行约 $2*10^8-4*10^8$ 次基本操作（加减、比较、赋值等）\n- **实际表现**：\n    - 简单循环操作：约$1*10^8-2*10^8$\n    - 复杂操作（除法、取模、函数调用）：约$0.5*10^8-1*10^8$\n    - 浮点运算：约$0.3*10^8-0.5*10^8$\n### **不同复杂度对应的最大数据规模**\n```txt\nO(1)        -> 几乎无限（>10^9）\nO(logn)     -> 几乎无限（>10^9）\nO(n)        -> 约 2×10^8\nO(nlogn)    -> 约 2×10^7（2000万）\nO(n√n)      -> 约 2×10^6（200万）\nO(n²)       -> 约 2×10^4（2万）\nO(n³)       -> 约 2×10^3（2000）\nO(2ⁿ)       -> 约 n ≤ 25\nO(n!)       -> 约 n ≤ 11\n```\n\n### **实战参考表**\n\n| 数据规模     | 可接受的复杂度         | 常见算法             |\n| -------- | --------------- | ---------------- |\n| n ≤ 10   | 任意（包括O(n!)）     | 全排列、暴力搜索         |\n| n ≤ 20   | O(2ⁿ)           | 子集枚举、状态压缩DP      |\n| n ≤ 100  | O(n³)           | Floyd、简单DP       |\n| n ≤ 1000 | O(n²)           | 二维DP、Dijkstra朴素版 |\n| n ≤ 10^4 | O(n√n)          | 数论分块             |\n| n ≤ 10^5 | O(nlogn)        | 线段树、树状数组、堆       |\n| n ≤ 10^6 | O(n) 或 O(nlogn) | 前缀和、KMP、单调栈      |\n| n ≤ 10^7 | O(n)            | 筛法、线性DP          |\n| n ≤ 10^8 | O(n)（必须常数小）     | 位运算、简单遍历         |\n## **256MB内存限制下的数组大小**\n\n### **不同数据类型可开数组大小**\n\n|数据类型|字节大小|最大元素数|备注|\n|---|---|---|---|\n|bool|1字节|约 2.68亿|实际比赛中常设为 bool 数组|\n|char|1字节|约 2.68亿||\n|int|4字节|约 6700万|常用|\n|long long|8字节|约 3300万||\n|double|8字节|约 3300万||\n|结构体（16字节）|16字节|约 1600万|视具体结构而定|\n```C++\n// 安全范围（考虑程序其他部分占用）\nint arr1[10000000];     // 4000万字节 ≈ 38MB ✅\nint arr2[50000000];     // 2亿字节 ≈ 190MB ✅（接近极限）\n\nint matrix1[5000][5000]; // 1亿字节 ≈ 95MB ✅\nint matrix2[10000][10000]; // 4亿字节 ≈ 381MB ❌（超限）\n\n// 多个数组时需累加\nint arrA[30000000];  // 114MB\nint arrB[30000000];  // 114MB\n// 总计228MB ✅（但接近极限）\n\n// 危险情况\nvector<vector<int>> graph(100000);  // 每个vector开销\n// 虽可能未立即超限，但动态扩展时可能意外超限\n```\n\n### **实用安全上限表**\n\n|数组类型|推荐最大规模|实际内存占用|安全系数|\n|---|---|---|---|\n|一维int数组|≤ 5×10⁷|≤ 200MB|留有余地|\n|一维long long数组|≤ 2.5×10⁷|≤ 200MB||\n|二维int数组[n][m]|n×m ≤ 3×10⁷|≤ 120MB|常用|\n|邻接表（图）|边数 ≤ 2×10⁶|变长，通常安全||\n|位集bitset|≤ 2×10⁸位|≤ 25MB|非常节省|\n\n---\n## **快速判断方法**\n\n### **时间判断口诀**\n\n```txt\nn=10⁵ → 想想O(nlogn)\nn=10⁶ → 必须O(n)或优化常数\nn≤5000 → O(n²)或许可行\nn≤20 → 可能是状压\n```\n\n### **空间判断口诀**\n\n```txt\nint数组：百万级安全，千万级要小心\n二维数组：相乘别超千万\n结构体：注意对齐开销\nSTL容器：额外开销约50%\n```\n","tags":["算法"]},{"title":"容斥原理笔记","url":"/ZestfulYK-blog/2025/12/09/容斥原理笔记-1/","content":"# 容斥原理的定义以及计算方式\n\n- 容斥原理是十分有用的一种计算方法，通常用于子集统计中\n- 该原理通过交替加减不同层次交集的大小，确保每个元素在并集中只被计算一次。虽然描述中的“只被两个集合重复的”可能指恰好属于两个集合的元素，但容斥原理实际处理的是所有交集（包含属于更多集合的元素），并通过后续的加减进行修正。\n- 原理：整体减空白的思想，不过也有韦恩图的一点思想，当子集数量大于3时，就有些抽象了，这时我们就需要总结一下规律。\n# 基本公式\n\n$$|A_1\\cup A_2\\cup ··· \\cup A_n|=\\Sigma|A_i|-\\Sigma|A_i\\cap A_j|+\\Sigma|A_i\\cap A_j\\cap A_k|+(-1)^{n+1}|A_1\\cap A_2 \\cap ···\\cap A_n|$$\n- 先加上所有子集，再减去每两个子集的重叠部分，再加上每三个子集的重叠部分···最后再是所有子集的交集。\n**重要观察**：每一个求和前面的符号只和选择了几个集合有关，所以在写代码的时候就会变得简单了。\n# 代码实现\n\n以题目[Count Good Numbers](https://codeforces.com/problemset/problem/2125/C)为例：\n题目要求我们统计因子里不含2,3,5,7的所有在区间$[l,r]$里的数字总量(翻译成人话)\n那么这不就是容斥原理吗？\n\n```C++\nll count_divisible(ll l, ll r, ll d) {\n    ll first= (l%d==0) ? l : l+d-l%d;  // 第一个能被 d 整除的数\n    ll last=r-r%d;                         // 最后一个能被 d 整除的数\n    if (first>last) return 0;                 // 如果没有这样的数\n    return (last-first)/d+1;\n}\nvoid solve(){\n    ll l,r;\n    cin>>l>>r;\n    int primes[]={2,3,5,7};               // 质数数组\n    ll ans=0;\n    // 枚举所有子集（包括空集），共 2^4 = 16 个\n    for(int mask=0;mask<(1<<4);mask++) {\n        ll d=1;\n        int cnt=0;                           // 子集中质数的个数\n        for(int i=0;i<4;i++){\n            if(mask&(1<<i)){\n                d*=primes[i];\n                cnt++;\n            }\n        }\n        // 根据子集大小的奇偶性决定符号\n        int sign=(cnt%2==0)?1:-1;\n        ans+=sign*count_divisible(l,r,d);\n    }\n    cout<<ans<<endl;\n}\n```\n\n- 主要思想：用二进制模拟是否要取得这一个集合，然后统计二进制中1出现的次数，即选择的集合数，来决定要加还是减。这样就大大减少了代码量，简单可维护性高。\n\n**备注：整体减空白的思想可以看华农的K题来学习，这里就不再列举了**","tags":["算法"]},{"title":"前缀和笔记","url":"/ZestfulYK-blog/2025/12/08/前缀和笔记/","content":"# 前缀和定义\n\n- 前缀和（Prefix Sum）是一种重要的预处理技术，能在**O(1)**时间内查询区间和，在算法竞赛和面试中应用广泛。以下是前缀和的主要应用场景和变种：\n## 1. 基本前缀和\n\n-  计算$\\Sigma_{i=1}^n a_i$的值，用来求区间和\n\n例如：\n```C++\n// 一维前缀和\nvector<int> pre(n+1, 0);\nfor (int i = 1; i <= n; i++) {\n    pre[i] = pre[i-1] + a[i];\n}\n// 查询区间[l, r]的和\nint sum = pre[r] - pre[l-1];\n```\n\n## 2. 二维前缀和\n\n用于计算矩阵的和$\\Sigma_{i=1}^n\\Sigma_{j=1}^na_{ij}$\n\n```C++\nvector<vector<int>> pre(m+1, vector<int>(n+1, 0));\nfor (int i = 1; i <= m; i++) {\n    for (int j = 1; j <= n; j++) {\n        pre[i][j] = a[i][j] + pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1];\n    }\n}\n// 查询子矩阵(x1,y1)-(x2,y2)的和\nint sum = pre[x2][y2] - pre[x1-1][y2] - pre[x2][y1-1] + pre[x1-1][y1-1];\n```\n\n前面两个的例题比较多，则行里就不举例了。\n\n---\n## 3. 前缀和与哈希表结合\n\n这是**最常用的变种**，用于解决\"区间和为k的区间个数\"问题：\n\n```C++\nint countSubarrays(vector<int>& nums,int k) {\n    unordered_map<int,int> mp; // 前缀和 -> 出现次数\n    mp[0] = 1; // 空数组的前缀和为0\n    int sum=0,count=0;\n    // sum拿来求前缀和，count求和为k的次数\n    for(int num:nums){\n        sum+=num;\n        // sum - target = pre[j]  => pre[j] = sum - k\n        if(mp.find(sum-k)!=mp.end())\n            count+=mp[sum-k];\n        mp[sum]++;\n    }\n    return count;\n}\n```\n上面的代码思路解释，首先，先计算前缀和的值，然后加到map里面，之后看有没有出现过sum-k这种前缀和，如果有，那么这一段的和就是k了，且有$mp[sum-k]$个，这样就计算出了答案\n\n例如：[K-大师和他的领域](https://ac.nowcoder.com/acm/contest/123093/K)\n这一题要我们找存在几个区间满足既含有k又满足k是这个区间的中位数。\n那么步骤：\n1.令小于k的为-1，大于k的为1，等于k的为0\n2.计算前缀和，统计前缀和一样的区间，这样区间内的和为0，说明k是这个区间的中位数，再使用$\\Sigma_{i=1}^{map.size()}C_{m_i}^2$计算总数就行了，这样得到可能的区间。\n3.但是还要保证区间内包含k，所以找到k位置，在两个k间的需要再用相同方法计算一次，\n4.最后减去即可\n\n就是说，要统计合法区间时，都可以把题目的要求变形一下，然后就可以使用这个思路了\n\n## 4. 前缀和与差分数组\n\n差分数组用于**区间修改，单点查询**：\n这一个没什么好说的，就是差分和前缀的互逆关系\n\n```C++\n// 初始化差分数组\nvector<int> diff(n+2, 0);\ndiff[1] = a[1];\nfor (int i = 2; i <= n; i++) {\n    diff[i] = a[i] - a[i-1];\n}\n// 区间[l, r]增加val\nvoid rangeAdd(int l, int r, int val) {\n    diff[l] += val;\n    diff[r+1] -= val;\n}\n// 恢复原数组\nfor (int i = 1; i <= n; i++) {\n    a[i] = a[i-1] + diff[i];\n}\n```\n\n## 5. 前缀最大/最小值\n\n```C++\n// 前缀最大值\nvector<int> preMax(n+1, INT_MIN);\nfor (int i = 1; i <= n; i++) {\n    preMax[i] = max(preMax[i-1], a[i]);\n}\n// 后缀最小值\nvector<int> sufMin(n+2, INT_MAX);\nfor (int i = n; i >= 1; i--) {\n    sufMin[i] = min(sufMin[i+1], a[i]);\n}\n```\n\n## 6. 前缀异或和\n\n用于处理区间异或问题：\n\n```C++\nvector<int> xorPre(n+1, 0);\nfor (int i = 1; i <= n; i++) {\n    xorPre[i] = xorPre[i-1] ^ a[i];\n}\n// 区间[l, r]的异或和\nint xorsum = xorPre[r] ^ xorPre[l-1];\n```\n\n## 7.二维差分数组\n\n```C++\n// 初始化二维差分\nvector<vector<int>> diff(m+2, vector<int>(n+2, 0));\n// 子矩阵(x1,y1)-(x2,y2)增加val\nvoid rangeAdd2D(int x1, int y1, int x2, int y2, int val) {\n    diff[x1][y1] += val;\n    diff[x2+1][y1] -= val;\n    diff[x1][y2+1] -= val;\n    diff[x2+1][y2+1] += val;\n}\n// 恢复原矩阵\nvector<vector<int>> res(m+1, vector<int>(n+1, 0));\nfor (int i = 1; i <= m; i++) {\n    for (int j = 1; j <= n; j++) {\n        res[i][j] = res[i-1][j] + res[i][j-1] - res[i-1][j-1] + diff[i][j];\n    }\n}\n```\n\n然后很重要的一点是，有时可能是假设前缀和数组，最后再反推原数组来进行构造。","tags":["算法"]},{"title":"ACM训练","url":"/ZestfulYK-blog/2025/12/07/ACM训练题目解析/","content":"# 简单题\n\n- 对于简单题目，最好还是仔细一点，或者使用最暴力的解法，而不是投机取巧，或者构造高级方法，通常样例数据都是片面的，常常会有坑。\n\n[sleeping through classes](https://codeforces.com/contest/2173/problem/A)\n\n比如这一题，数据没有包含i+k中间有1的情况，直接i+=k导致错误。\n\n\n# 中等题目\n\n- 中等题目就需要强观察力和trick技巧了\n\n[Niko's Tactical Cards](https://codeforces.com/contest/2173/problem/B)\n\n这一道题目是动态规划的变种，虽然要求每一步最优，但是可能发生最小值突然转变成最大值的情况，因此，计算最小值也是必要的。只要计算这两个值就行了。\n\n[Kanade's Perfect Multiples](https://codeforces.com/contest/2173/problem/C)\n\n这题希望我们构造一个满足要求的B，这个就有点类似于筛法求素数了，实际上两者的代码几乎是一样的，但是在做的时候要注意区分原始数据和v数组，一个一个遍历就行了，找不到就可以直接退出，因为不然当前确定的最小值就无法被覆盖了。\n\n[Merging the Sets](https://codeforces.com/problemset/problem/2146/B)\n\n你想选择其中的一些集合（可能一个都不选，也可能全部都选），使得 1 和 m 之间的每个整数都包含在**个所选集合中的至少一个**中。\n思维误区，不用一边读入一边判断，因为数据保证$l\\leq 2*10^5$所以先读入再判断就行了，此外，要方法合法需要这个集合不存在也合法，那么只要用桶来看看去掉会不会变0就行了。原先想到的覆盖才合法的思路不对的原因是前后都有可能覆盖。\n\n[Abraham's Great Escape](https://codeforces.com/problemset/problem/2155/B)\n\n要求构造一个方阵，每个位置一个箭头，满足有k个格子能沿箭头出去。\n其实只要管最后一行，前面k个填U，后面的填D，最后一行填$RRR……RL$就行了\n比如：\n```C++\n1\n9 4\nUUU\nUDD\nRRL\n```\n这样在最后一行产生循环，前面的不管。原来的做法是两个两个组合，产生循环，虽然也能做，但是不方便。\n\n[Cake Assignment](https://codeforces.com/problemset/problem/2138/A)\n\n这个题目的重要观察点是，当最后一步确定后，上一步的操作一定是确定的，于是我们就可以倒推\n\n[XOR Array](https://codeforces.com/contest/2175/problem/B)\n\n这题的要求是构造一个数组，满足仅在l到r上的异或和为0，其他位置全非0，\n异或有一个特点，和前缀和一样，可以构建前缀异或和，因为$x\\oplus y \\oplus x==x$\n此外非常容易陷入的一个点是，可能会想到之间填入1-n来构造，但是实际上，这么异或会产生很多的0，所以这个方法是不行的。（比如1，2，3）\n因此，这里我们的操作是构造最终异或的结果，写一个前缀异或数组，最后再反推原数组就行了。\n详细信息可以见异或的笔记部分","tags":["算法"]},{"title":"DP笔记","url":"/ZestfulYK-blog/2025/12/07/DP学习笔记/","content":"# DP题目的特点\n\n- 数据较小，至少有一维是可以接受的，比如每一步的决策小于3，总数小于1000等等\n- 每一步的答案可以由之前的答案得到，比如数字三角形\n\n# DP题目的大致做法\n\n## 设DP数组\n\n- 明确DP数组的含义，保证每次求解的答案都是这个含义，不然就可能出错\n(这也是我之前的一大误区)\n\n## 分类讨论\n\n- 明确有几种决策方案，**明确这一步的答案是怎么推断出来的(非常重要!!!)**\n\n接下来编写代码就行了\n\n## 举例：迎新赛M题\n\n- 题目传送门：\n\n> [ZJUTOJ | 2024ZJUT迎新赛-决赛-M. 三色小屋](http://www.zjutacm.cn/problem/3118)\n\n### 题目理解：\n\n- 首先发现每一步的方案数可以接受，并且这一步的答案只由上一步转移而来，所以可以使用DP\n- 每个位置只能填R/G/B三种颜色，而且之和上一步和相邻的颜色有关，几种方案互不影响，符合动态规划的特点\n### 分类讨论：\n\n- 分为两大类，因为开头要初始化，所以单独讨论\n\n\n\n$$\ndp[i][j] = \n\\begin{cases}\ni==1\\begin{cases}\n\tc[i]==\\ '0' & \\text{可以用的颜色为1} \\\\\n\tc[i]\\ !=\\ \\ '0' & \\text{这个颜色为1}\n\\end{cases}\\\\ \\\\\ni\\ !=1\\begin{cases}\n\tc[i]==\\ '0' & \\text{可以填入的颜色为前两个的和} \\\\\n\tc[i] \\ !=\\ \\ '0' & \\text{这个颜色为前两个的和}\n\\end{cases}\n\\end{cases}\n$$\n\n## DP概率题\n\n### 求期望的几个重要公式\n\n$$\\begin{aligned}\nE(aX+b)=aE(x)+b \\\\ \\\\\nE(X+Y)=E(X)+E(Y)\\\\ \\\\\nE(XY)=E(X)E(Y)\n\\end{aligned}$$\n- 上面两个说明了期望的线性关系，下面两个说明了期望的独立性","tags":["算法"]},{"title":"第一类换元积分","url":"/ZestfulYK-blog/2025/12/07/不定积分笔记/","content":"\n## 重要公式\n\n#### 基本积分公式：\n\n**不要忘记加C!!!**\n\n$\\xi \\ \\delta \\ \\alpha \\ \\beta \\ \\pi \\  \\theta \\ \\in \\ \\notin$\n$\\Delta$\n\n$\\int k \\, dx = kx + C$\n$\\int x^n \\, dx = \\frac{x^{n+1}}{n+1} + C \\quad (n \\neq -1)$\n$\\int \\frac{1}{x} \\, dx = \\ln|x| + C$\n\n- 指数函数：\n$\\int e^x \\, dx = e^x + C$\n$\\int a^x \\, dx = \\frac{a^x}{\\ln a} + C$\n\n- 三角函数：\n$\\int \\sin x \\, dx = -\\cos x + C$\n$\\int \\cos x \\, dx = \\sin x + C$\n$\\int \\tan x \\, dx = -\\ln|\\cos x| + C$\n$\\int \\cot x \\, dx = \\ln|\\sin x| + C$\n$\\int \\sec^2 x \\, dx = \\tan x + C$\n$\\int \\csc^2 x \\, dx = -\\cot x + C$\n$\\int \\sec x \\tan x \\, dx = \\sec x + C$\n$\\int \\csc x \\cot x \\, dx = -\\csc x + C$\n$\\int secx\\,dx= ln|secx+tanx|+C$\n$\\int cscx\\,dx= ln|cscx-cotx|+C$\n\n\n- 反三角函数：\n$\\int \\frac{1}{\\sqrt{1-x^2}} \\, dx = \\arcsin x + C$\n$\\int \\frac{1}{1+x^2} \\, dx = \\arctan x + C$\n\n- 双曲函数：\n$\\int \\sinh x \\, dx = \\cosh x + C$\n$\\int \\cosh x \\, dx = \\sinh x + C$\n\n- 特殊积分：\n$\\int \\frac{1}{x^2+a^2} \\, dx = \\frac{1}{a}\\arctan\\frac{x}{a} + C$\n$\\int \\frac{1}{\\sqrt{a^2-x^2}} \\, dx = \\arcsin\\frac{x}{a} + C$\n$\\int \\frac{1}{x^2-a^2} \\, dx = \\frac{1}{2a}\\ln\\left|\\frac{x-a}{x+a}\\right| + C$\n\n- 和差化积公式：\n$\\sin A + \\sin B = 2 \\sin\\left(\\frac{A+B}{2}\\right) \\cos\\left(\\frac{A-B}{2}\\right)$\n$\\sin A - \\sin B = 2 \\cos\\left(\\frac{A+B}{2}\\right) \\sin\\left(\\frac{A-B}{2}\\right)$\n$\\cos A + \\cos B = 2 \\cos\\left(\\frac{A+B}{2}\\right) \\cos\\left(\\frac{A-B}{2}\\right)$\n$\\cos A - \\cos B = -2 \\sin\\left(\\frac{A+B}{2}\\right) \\sin\\left(\\frac{A-B}{2}\\right)$\n\n- 积化和差公式：\n$\\sin A \\cos B = \\frac{1}{2}[\\sin(A+B) + \\sin(A-B)]$\n$\\cos A \\sin B = \\frac{1}{2}[\\sin(A+B) - \\sin(A-B)]$\n$\\cos A \\cos B = \\frac{1}{2}[\\cos(A+B) + \\cos(A-B)]$\n$\\sin A \\sin B = -\\frac{1}{2}[\\cos(A+B) - \\cos(A-B)]$\n\n#### 对部分公式的推导：\n\n$\\int \\tan x \\, dx = -\\ln|\\cos x| + C$\n$\\int \\tan x \\, dx = \\int \\frac{sinx}{cosx} \\,dx = - \\int \\frac{dcosx}{sinx} \\, = -ln|cosx|+ C$\n\n- 对于 $\\int cotx$ 同理\n### 小技巧：\n\n- $sinx^m cosx^n$之类的，奇数的话拆一个进去积分，偶数的话用倍角或半角公式\n- 在对$\\int tanx\\,dx$或者$\\int secx\\,dx$等方法一样，可以类比\n\n奇数如$\\int sin^3 \\, dx$或者$\\int sin^3cosx\\,dx$等\n比如$\\int sinx^3\\,dx=-\\int sinx^2\\,dcosx=-\\int(1-cos^2x)\\,dcosx$\n$=-cosx+\\frac{1}{3}cosx^3+C$\n\n偶数如$\\int cosx^4\\,dx$等\n比如$\\int cosx^4\\,dx=\\int(\\frac{1+cos2x}{2})^2\\,dx=\\frac{1}{4}\\int1+cos2x^2+2cos2x\\,dx$\n$=\\frac{1}{4}(x+\\frac{1}{2}\\int cos2x^2\\,d2x+\\int cos2x\\,d2x)+C$\n$=\\frac{1}{4}(x+sin2x+\\frac{1}{2}\\int \\frac{1+cos4x}{2}\\,d2x)+C$\n$=\\frac{1}{4}(x+sin2x+\\frac{1}{8} \\int(1+cos4x)\\,d4x)+C$\n$=\\frac{1}{4}(x+sin2x+\\frac{1}{8}(4x+sin4x))+C$\n$=\\frac{3}{8}x+\\frac{1}{4}sin2x+\\frac{1}{32}sin4x+C$\n\n- 对于$\\frac{...+...}{...}$类的可能是把上面的式子拆成两个分别计算\n例如：$\\int \\frac{1+x}{\\sqrt{2-3x^2}}\\,dx$\n$=\\int \\frac{1}{\\sqrt{2-3x^2}}\\,dx+\\int \\frac{x}{\\sqrt{2-3x^2}}\\,dx$\n\n- 要熟记各种三角函数的导数和公式以及转换关系：\n $secx^2-1=tanx^2$\n $cscx^2-1=cotx^2$\n$$arctan(\\frac{1}{x})=\\begin{cases}\narccot(x)\\ \\ \\ \\ \\ \\ \\ \\ \\ x>0\\\\\narccot(x)-\\pi  \\ \\ x<0\n\\end{cases}$$\n#### 裂项计算积分\n注意，在第一类换元积分中，我们的计算只能处理$\\int \\frac{1}{ax+b}\\,dx$类的积分，所以，要变成分子是分母的导数的倍数的形式，（用$\\ln |x|$）来处理每一个分式。通常分母会是一个能因式分解的式子，然后要根据分母的形式来决定分子被写成什么样。\n例如:$\\int \\frac{x}{x^2-3x-4}\\,dx$\n这里我们首先对下面的式子进行因式分解，得到:$\\int \\frac{x}{(x-4)(x+1)}\\,dx$\n接下来我们来根据分母决定分子，应为分母是一次式子，所以分子应该对应常数，所以经过凑得到如下结果：$$\\frac{1}{5}\\int \\frac{4}{x-4}+\\frac{1}{x+1}\\,dx$$\n那么我们就能计算积分啦~\n\n### \n#### 含有 $\\sin x + \\cos x$ 的分母的积分\n\n对于含有 $\\sin x + \\cos x$ 的分母的积分，有一种类似于部分分式分解的方法。\n对于形如 $\\int \\frac{a\\sin x + b\\cos x}{c\\sin x + d\\cos x} dx$ 的积分，我们可以使用**线性组合法**，其核心思想是：\n\n**将被积函数的分子表示为分母和分母导数的线性组合**。\n**第一类积分实际上就是把前面的放到d里面，再除以对应的倒数即可**\n\n对于一般形式 $\\int \\frac{a\\sin x + b\\cos x}{c\\sin x + d\\cos x} dx$：\n\n1. 设 $D(x) = c\\sin x + d\\cos x$，$D'(x) = c\\cos x - d\\sin x$\n2. 解方程组：\n$$\\begin{cases} a=Ac-Bd \\\\\nb=Ad+Bc\n\n\\end{cases}$$\n求出 $A$ 和 $B$\n 积分变为：$$A\\int1dx+B\\int \\frac{D'(x)}{D(x)}\\,dx=Ax+Bln|D(x)|+C$$\n 对于更复杂的情况，如分母含有 $\\sin^2 x$、$\\cos^2 x$ 或 $\\sin x \\cos x$，可以使用：\n\n- 万能代换 $t = \\tan\\frac{x}{2}$\n- 三角恒等式化简\n- 配对积分法（如本文开始所示）\n\n\n\n- 我的通常做法是看被积函数有什么部分的导数在这里面出现过，然后提取这个部分\n\n例子：$\\int \\frac{1+lnx}{(xlnx)^3}\\,dx$\n\n下面的导数就是上面那一部分，所以直接提取就行了，按照我的逻辑来看，就是除去这个导数\n这两种理解方式实际上是一样的\n\n---\n## 第二类换元积分\n\n**第二类换元积分实际上就是把下换成t的代数式子再乘上这个式子的导数**\n**不要忘记乘以对应的倒数!!!**\n \n### 第二类换元积分法常用公式：\n\n- 三角代换：\n1. 含有 $\\sqrt{a^2-x^2}$，令 $x = a\\sin t$，则 $dx = a\\cos t\\, dt$\n   $\\int \\frac{1}{\\sqrt{a^2-x^2}} dx = \\arcsin\\frac{x}{a} + C$\n\n2. 含有 $\\sqrt{a^2+x^2}$，令 $x = a\\tan t$，则 $dx = a\\sec^2 t\\, dt$\n   $\\int \\frac{1}{\\sqrt{a^2+x^2}} dx = \\ln|x+\\sqrt{x^2+a^2}| + C$\n\n3. 含有 $\\sqrt{x^2-a^2}$，令 $x = a\\sec t$，则 $dx = a\\sec t\\tan t\\, dt$\n   $\\int \\frac{1}{\\sqrt{x^2-a^2}} dx = \\ln|x+\\sqrt{x^2-a^2}| + C$\n\n- 根式代换：\n1. 含有 $\\sqrt{ax+b}$，令 $t = \\sqrt{ax+b}$，则 $x = \\frac{t^2-b}{a}$，$dx = \\frac{2t}{a} dt$\n\n2. 含有 $\\sqrt[n]{ax+b}$，令 $t = \\sqrt[n]{ax+b}$，则 $x = \\frac{t^n-b}{a}$，$dx = \\frac{nt^{n-1}}{a} dt$\n\n- 倒代换：\n对于形如 $\\int \\frac{1}{x\\sqrt{ax^2+bx+c}} dx$ 等积分，可令 $x = \\frac{1}{t}$，则 $dx = -\\frac{1}{t^2} dt$\n\n- 欧拉代换：\n1. 对于 $\\sqrt{ax^2+bx+c}$，当 $a>0$ 时，令 $\\sqrt{ax^2+bx+c} = t-\\sqrt{a}x$\n2. 当 $c>0$ 时，令 $\\sqrt{ax^2+bx+c} = tx+\\sqrt{c}$\n\n- 万能代换：\n对于三角有理式 $\\int R(\\sin x, \\cos x) dx$，令 $t = \\tan\\frac{x}{2}$，则\n$\\sin x = \\frac{2t}{1+t^2}$，$\\cos x = \\frac{1-t^2}{1+t^2}$，$dx = \\frac{2}{1+t^2} dt$\n\n- 双曲代换：\n1. 含有 $\\sqrt{x^2+a^2}$，令 $x = a\\sinh t$，则 $dx = a\\cosh t\\, dt$\n2. 含有 $\\sqrt{x^2-a^2}$，令 $x = a\\cosh t$，则 $dx = a\\sinh t\\, dt$\n\n- 常用结论：\n$\\int \\sqrt{a^2-x^2} dx = \\frac{x}{2}\\sqrt{a^2-x^2} + \\frac{a^2}{2}\\arcsin\\frac{x}{a} + C$\n$\\int \\sqrt{a^2+x^2} dx = \\frac{x}{2}\\sqrt{a^2+x^2} + \\frac{a^2}{2}\\ln|x+\\sqrt{x^2+a^2}| + C$\n$\\int \\sqrt{x^2-a^2} dx = \\frac{x}{2}\\sqrt{x^2-a^2} - \\frac{a^2}{2}\\ln|x+\\sqrt{x^2-a^2}| + C$\n\n\n---\n\n### 重要例题\n#### 积分 $\\int \\frac{1}{x\\sqrt{x^2+1}} dx$ 的两种解法\n\n###### 方法一：三角代换\n\n令 $x = \\tan t$，则：\n- $dx = \\sec^2 t\\, dt$\n- $\\sqrt{x^2+1} = \\sqrt{\\tan^2 t + 1} = \\sec t$\n\n代入原积分：\n$$\\int \\frac{1}{x\\sqrt{x^2+1}} dx = \\int \\frac{1}{\\tan t \\cdot \\sec t} \\cdot \\sec^2 t\\, dt = \\int \\frac{\\sec t}{\\tan t} dt$$\n\n化简：\n$$\\int \\frac{\\sec t}{\\tan t} dt = \\int \\frac{\\frac{1}{\\cos t}}{\\frac{\\sin t}{\\cos t}} dt = \\int \\frac{1}{\\sin t} dt = \\int \\csc t\\, dt$$\n\n利用公式：\n$$\\int \\csc t\\, dt = \\ln|\\csc t - \\cot t| + C$$\n\n将变量换回 $x$：\n- $\\csc t = \\frac{\\sqrt{x^2+1}}{x}$\n- $\\cot t = \\frac{1}{x}$\n\n最终结果：\n$$\\int \\frac{1}{x\\sqrt{x^2+1}} dx = \\ln\\left|\\frac{\\sqrt{x^2+1}-1}{x}\\right| + C$$\n\n##### 方法二：倒代换\n\n令 $x = \\frac{1}{t}$，则：\n- $dx = -\\frac{1}{t^2} dt$\n- $\\sqrt{x^2+1} = \\sqrt{\\frac{1}{t^2}+1} = \\frac{\\sqrt{1+t^2}}{|t|}$\n\n代入原积分（假设 $t>0$，即 $x>0$）：\n$$\\int \\frac{1}{x\\sqrt{x^2+1}} dx = \\int \\frac{1}{\\frac{1}{t} \\cdot \\frac{\\sqrt{1+t^2}}{t}} \\cdot \\left(-\\frac{1}{t^2}\\right) dt = -\\int \\frac{1}{\\sqrt{1+t^2}} dt$$\n\n利用公式：\n$$\\int \\frac{1}{\\sqrt{1+t^2}} dt = \\ln|t+\\sqrt{1+t^2}| + C$$\n\n代入 $t = \\frac{1}{x}$：\n$$-\\ln\\left|\\frac{1}{x}+\\sqrt{1+\\frac{1}{x^2}}\\right| + C = -\\ln\\left|\\frac{1+\\sqrt{x^2+1}}{x}\\right| + C$$\n\n化简：\n$$-\\ln\\left|\\frac{1+\\sqrt{x^2+1}}{x}\\right| = \\ln\\left|\\frac{x}{1+\\sqrt{x^2+1}}\\right| = \\ln\\left|\\frac{x(\\sqrt{x^2+1}-1)}{x^2}\\right| = \\ln\\left|\\frac{\\sqrt{x^2+1}-1}{x}\\right|$$\n\n最终结果：\n$$\\int \\frac{1}{x\\sqrt{x^2+1}} dx = \\ln\\left|\\frac{\\sqrt{x^2+1}-1}{x}\\right| + C$$\n\n###### 结论\n\n两种方法得到相同的结果：\n$$\\int \\frac{1}{x\\sqrt{x^2+1}} dx = \\ln\\left|\\frac{\\sqrt{x^2+1}-1}{x}\\right| + C$$\n\n三角代换思路直接，倒代换计算简洁，两种方法都有效解决此类积分问题。\n\n#### 积分$\\int x^2(2x-3)^{10}\\,dx$的计算\n\n- 直接换元，这里不适合分步积分\n令$t=2x-3$来简化计算。然后就发现可以展开这个式子了。\n\n\n\n---\n### 什么时候可以统一结果？\n\n**在以下情况下，可以将负号放到三角函数中统一结果：**\n\n1. **当三角函数在某个区间内保持相同符号时**\n    \n    - 对于 $\\sqrt{x^2 - a^2}$，使用 $x = a\\sec\\theta$\n        \n    - 对于 $\\sqrt{a^2 - x^2}$，使用 $x = a\\sin\\theta$ 或 $x = a\\cos\\theta$\n        \n    - 对于 $\\sqrt{x^2 + a^2}$，使用 $x = a\\tan\\theta$\n        \n2. **选择的角范围要保证：**\n    \n    - 代换函数是单调的（便于反函数存在）\n        \n    - 根号内的表达式化简后不产生绝对值\n        \n3. **常见的选择：**\n    \n    - $\\sqrt{x^2 - a^2}$：$\\theta \\in (0, \\pi/2) \\cup (\\pi, 3\\pi/2)$\n        \n    - $\\sqrt{a^2 - x^2}$：$\\theta \\in (-\\pi/2, \\pi/2)$\n        \n    - $\\sqrt{x^2 + a^2}$：$\\theta \\in (-\\pi/2, \\pi/2)$\n\n此外含有$e^x$式子有特殊的计算技巧。\n例如：$$\\int \\frac{1}{e^x+1}\\,dx=\\int \\frac{e^{-x}}{e^{-x}+1}\\,dx$$\n从而实现第一类换元积分。","tags":["数学"]},{"title":"有理函数积分","url":"/ZestfulYK-blog/2025/12/07/不定积分笔记2（有理函数和部分积分）/","content":"# 基本方法\n\n- 凑成能第一类换元积分的式子\n\t例如$\\frac{1}{...}$类的\n部分分式分解\n## 有理函数积分适用条件\n- 1. 有理函数积分\n当被积函数是**有理函数**（两个多项式的商）时：$\\int \\frac{Q(x)}{P(x)}\\,​dx$\n其中 $P(x)$ 和 $Q(x)$ 都是多项式。\n- 2. 分母可因式分解\n\n部分分式分解是处理**有理函数积分**的**系统方法**，特别适用于：\n- 分母可明确因式分解\n- 没有更简单的特殊技巧\n- 需要精确解析表达式\n\n当分母 $Q(x)$ 可以分解为**一次因式**和**不可约二次因式**的乘积时：\n- **一次因式**：$(x-a)$\n- **不可约二次因式**：$(x^2+px+q)$，其中 $p^2-4q<0$\n#### 具体分解规则\n##### 对于一次因式 $(x-a)^k$：\n\n对应部分为：\n$$\\frac{A_1}{x-a}+\\frac{A_2}{(x-a)^2}+···+\\frac{A_k}{(x-a)^k}$$\n##### 对于二次因式 $(x^2+px+q)^m$：\n\n$$\\frac{B_1x+C_1}{x^2+px+q}+\\frac{B_2x+C_2}{(x^2+px+q)^2}+···+\\frac{B_mx+C_m}{(x^2+px+q)^k}$$\n\n但是，在这个部分有一种特殊情况，就是二次式:\n$$\\int \\frac{P(x)}{Q(x)^2}$$\n>在这里，可以把函数看成$\\frac{d}{dx}\\frac{Ax+B}{Q(x)}+\\frac{C}{Q(x)}$两种方法实际上是等价的，因为最后必然化成一个简单的倒数积分和简单的分数积分$\\frac{1}{Q(x)}$。\n\n### 例子：\n- 计算$\\int \\frac{x^2+1}{(x^2+x+1)^2}\\,dx$有两种方式，都能得到答案。\n1.用标准公式计算\n得到:\n$$\\int \\frac{x}{(x^2+x+1)^2}\\,dx-\\int \\frac{1}{x^2+x+1}\\,dx$$\n\n接着再分别计算前后的积分，前面得到的是一个分式加上一个含$\\arctan x$的式子\n比较麻烦，不过对于这类题目，我们知道一定能得到第二种简单的方法的式子，所以经过计算\n得到:\n$$\\frac{1}{3}\\frac{d}{dx}\\frac{x+2}{x^2+x+1}-\\frac{4}{3}\\int · \\frac{1}{x^2+x+1}\\,dx$$\n这种解法的好处是，得到前半段以后可以直接当作积分结果，不需要额外的处理。\n#### 判断步骤\n##### 第一步：检查是否为真分式\n- 如果 $\\deg P(x) \\geq \\deg Q(x)$：先进行**多项式除法**（大除法）\n- 如果 $\\deg P(x) < \\deg Q(x)$：直接进行部分分式分解\n 就是说最高项次数小就能用这个方法\n##### 第二步：因式分解分母\n将分母 $Q(x)$ 完全分解为：\n- 一次因式 $(x-a_i)^{k_i}$\n- 不可约二次因式 $(x^2+p_jx+q_j)^{m_j}$\n##### 第三步：确定分解形式\n根据因式分解结果，写出部分分式的**一般形式**。\n在计算过程中，可以通过给x赋值来快速计算带定值\n\n#### 具体例子分析\n\n##### 例1：$\\int \\frac{x^3+1}{(x^2+1)^2} dx$\n\n- 分母：$(x^2+1)^2$（二次因式的平方）\n- 分解形式：$\\frac{Ax+B}{x^2+1} + \\frac{Cx+D}{(x^2+1)^2}$\n\n##### 例2：$\\int \\frac{1}{x(x-1)^2} dx$\n\n- 分母：$x(x-1)^2$（一次因式及其平方）\n- 分解形式：$\\frac{A}{x} + \\frac{B}{x-1} + \\frac{C}{(x-1)^2}$\n\n##### 例3：$\\int \\frac{x^2+1}{x(x^2+4)} dx$\n\n- 分母：$x(x^2+4)$（一次因式 + 二次因式）\n- 分解形式：$\\frac{A}{x} + \\frac{Bx+C}{x^2+4}$\n\n**例4：**$\\int \\frac{x+1}{x^2+4x+6}\\,dx$\n这个题目看起来和裂项十分相似，但是分母无法因式分解，所以这个方法是不对的。\n注意到这里上方的次数正好是分母求导结束后的次数，所以游客能采取分开计算的方法。\n这里首先先把上面的分析翻倍，（因为分母的导数是$2x+4$），接下来在加一个2，减一个2外面再配上$\\frac{1}{2}$即可。\n所以式子变为:$\\frac{1}{2} \\int \\frac{2x+4-2}{x^2+4x+6}\\,dx$然后两个部分正好都是我们能计算的第一类换元积分，完成！\n\n- $\\int \\frac{f'(x)}{f(x)} dx$：直接得到 $\\ln|f(x)|$\n- $\\int \\frac{1}{x^2+a^2} dx$：直接得到 $\\frac{1}{a}\\arctan\\frac{x}{a}$\n\n## 个人技巧\n\n- 对于一般的式子，通常是去凑积分，先对其1次项，再分离常数项，这样就能直接得到一个ln积分和一个形如$\\frac{p}{t^2+a^2}$的式子了，这个是很好积分的($\\arctan x$)\n- 遇到三次式子，可能配凑一个$\\pm 1$来计算\n- 遇到分母次数很高的，考虑倒代换\n- 其余的式子，直接展开就行了\n\n## 三角代换部分\n\n### 重要公式\n当取$\\tan x=u$时\n$$\\begin{cases}\n\\sin x=\\frac{u}{\\sqrt{1+u^2}} \\\\\n\\cos x=\\sqrt{1+u^2}\n\\end{cases}\n$$\n\n当取$\\tan \\frac{x}{2}=u$时\n$$\\begin{cases}\n\\sin x=\\frac{2u}{1+u^2} \\\\\n\\cos x=\\frac{1-u^2}{1+u^2}\n\\end{cases}\n$$\n\n然后不要忘记，第二类换元积分是需要乘上对应的导数的，**这个导数是t关于x的函数**，乘上的是含有t的导数\n之后像前面一样计算就行了。\n\n#### 题型分类\n- 只含有一种三角函数的，用第一类换元积分，例如：$\\int \\frac{1}{\\sin x^4}\\,dx$\n- 上下均有且为一次式的，用上节课的方法代换，例如$\\int \\frac{\\sin x}{\\sin x+\\cos x}\\,dx$\n- 同名三角函数相加，和差化积，例如$\\int \\frac{1}{\\sin x+\\sin 3x}\\,dx$\n- 正常幂(不含分母的)，按奇偶正常拆分\n- 分母含有高次项的，拆解1，例如$\\int \\frac{1}{\\sin x\\cos x^2}$\n主要是把$\\cos x$化成$\\tan x$来计算。\n例如：1$$\\int \\frac{dx}{a^2+\\sin x^2+b^2+\\cos x^2}=\\int \\frac{\\frac{1}{\\cos x^2}}{a^2\\tan x^2+b^2}\\,dx=\\int \\frac{1+\\tan x^2}{a^2\\tan x^2+b^2}\\,dx$$\n## 根式的代换\n\n### 重要公式\n\n令$$t=\\sqrt[n]{ax+b}$$\n令$$t=\\sqrt[n]{\\frac{ax+b}{cx+d}}$$\n令$$t=\\sqrt[mn]{ax+b}$$\n看含有什么来决定怎么设t\n最后反解出x带入其余部分即可。\n\n### 重要例题根式代换类型\n\n求下面这个函数的积分\n$$\\int \\frac{dx}{\\sqrt[n]{(x-a)^{n+1}(x-b)^{n-1}}}\\,dx$$\n方法：先提取部分，构造类似上面2的一个式子，然后再考虑代换。\n$$\\text{原式}=\\int\\frac{1}{(x-a)(x-b)\\sqrt[n]{\\frac{x-a}{x-b}}}\\,dx$$\n不过接下来直接解出x再带回比较麻烦，所以考虑直接算出$\\frac{dx}{(x-a)(x-b)}$这个部分\n$$t^n=\\frac{a-b}{(x-b)^2}$$\n$$\\frac{nt^n\\,dt}{t}=\\frac{a-b}{(x-b)^2}\\,dx$$\n$$\\frac{n\\,dt}{t}=\\frac{a-b}{(x-b)^2t^n}\\,dx=\\frac{a-b}{(x-a)(x-b)}\\,dx$$\n所以得到原式变为：\n$$-\\frac{n}{a-b}\\sqrt[n]{\\frac{x-b}{x-a}}$$\n## 重要例题偶数次幂分数类型\n\n方法是化为平方分之括号内函数的导数\n即：\n$$\\int \\frac{f'(x)}{f(x)^2+a}$$\n例如：\n$$\\int \\frac{1}{x^4+1}\\,dx=\\frac{1}{2}\\int\\frac{1+\\frac{1}{x^2}-1}{x^2+\\frac{1}{x^2}}=\\frac{1}{2}(\\int \\frac{d x-\\frac{1}{x}}{(x-\\frac{1}{x})^2+2}+\\int \\frac{d x+\\frac{1}{x}}{(x+\\frac{1}{x})^2+2})$$$$=\\frac{1}{2\\sqrt{2}}\\arctan \\frac{x-\\frac{1}{x}}{\\sqrt{2}}-\\frac{1}{4\\sqrt{2}}\\ln|\\frac{x^2-\\sqrt{2}x+1}{x^2+\\sqrt{2}x+1}|$$\n 所以类似于$\\frac{\\text{二次}}{\\text{四次}}$的式子，理论上都有可能用这种方式解决","tags":["数学"]},{"title":"分步积分笔记","url":"/ZestfulYK-blog/2025/12/07/分步积分/","content":"\n## 核心公式\n$$\\int u\\,dv = uv - \\int v\\,du$$\n\n## 选择原则：\"反对幂指三\"\n优先级从高到低选择 $u$：\n- **反**三角函数（$arcsin$,$arccos$, $arctan$等）\n- **对**数函数（$\\ln x$, $log x$等）\n- **幂**函数（$x^n$, $x^2$, $\\sqrt{x}$等）\n- **指**数函数（$e^x$, $a^x$等）\n- **三**角函数（$\\sin x$, $\\cos x$等）\n\n**口诀解释**：越靠前的类型越优先选为 $u$，越靠后的类型越优先放入 $dv$。\n\n---\n\n## 经典类型与解法\n\n### 类型1：幂函数 × 三角函数\n$\\int x^n\\cos x\\,dx$ 或 $\\int x^n\\sin x\\,dx$\n- 将三角函数放入 $dv$（如 $\\cos x\\,dx = d(\\sin x)$）\n- 通过 $n$ 次分部积分逐次降幂\n\n### 类型2：幂函数 × 指数函数\n$\\int x^n e^{ax}\\,dx$\n- 将指数函数放入 $dv$（如 $e^{ax}\\,dx = \\frac{1}{a}d(e^{ax})$）\n- 逐次降幂至 $x^0$\n\n### 类型3：幂函数 × 对数函数\n$\\int x^n \\ln x\\,dx$\n- 将对数函数选为 $u$（$\\ln x$ 求导得 $\\frac{1}{x}$，可消去 $x$ 幂）\n- 幂函数放入 $dv$\n\n### 类型4：指数函数 × 三角函数\n$\\int e^{ax}\\sin(bx)\\,dx$ 或 $\\int e^{ax}\\cos(bx)\\,dx$\n- 任选其一放入 $dv$（通常选三角函数）\n- 两次分部积分后出现循环，解方程求得原积分\n\n---\n\n## 高级技巧与注意事项\n\n### 技巧1：隐藏的 $dv$\n当被积函数为分式时，常将分母或其部分放入 $dv$：\n$$\\int \\frac{x\\arcsin x}{\\sqrt{1-x^2}}\\,dx$$\n令 $u=\\arcsin x$，$dv=\\frac{x}{\\sqrt{1-x^2}}dx$，则 $v=-\\sqrt{1-x^2}$\n\n### 技巧2：凑微分调整\n对于 $\\int \\frac{x}{e^{2x}}\\,dx$，可改写为 $\\int x e^{-2x}\\,dx$\n- 令 $u=x$，$dv=e^{-2x}dx$\n- 则 $du=dx$，$v=-\\frac{1}{2}e^{-2x}$\n- 代入公式：$-\\frac{1}{2}xe^{-2x} + \\frac{1}{2}\\int e^{-2x}dx$\n\n### 技巧3：多次分部积分\n$$\\int x^2 e^x\\,dx = x^2 e^x - 2\\int x e^x\\,dx$$\n需连续使用分部积分，直到幂函数降为常数\n\n### 技巧4：递推关系\n某些积分可建立递推公式：\n$$\\int x^n e^x\\,dx = x^n e^x - n\\int x^{n-1} e^x\\,dx$$\n\n### 技巧5：组合拆分\n对于 $\\int e^x(\\sin x + \\cos x)\\,dx$，可拆分为两个分部积分，但更简单的方法是观察导数关系：\n$d(e^x \\sin x) = e^x(\\sin x + \\cos x)dx$\n\n---\n\n## 常见易错点\n1. **符号错误**：公式中的减号易漏写\n2. **$v$ 计算错误**：求 $v$ 时积分常数可省略（因最后会抵消）\n3. **选择不当**：违反\"反对幂指三\"可能导致积分更复杂\n4. **循环处理**：$\\int e^x \\sin x\\,dx$ 类问题，移项时注意系数\n\n---\n\n## 典型例题\n\n### 例1：对数函数\n$$\\int \\ln x\\,dx = x\\ln x - \\int x\\cdot\\frac{1}{x}dx = x\\ln x - x + C$$\n\n### 例2：反三角函数\n$$\\int \\arcsin x\\,dx = x\\arcsin x - \\int \\frac{x}{\\sqrt{1-x^2}}dx = x\\arcsin x + \\sqrt{1-x^2} + C$$\n\n### 例3：循环积分\n$$\\int e^x \\sin x\\,dx$$\n- 第一次：$u=\\sin x$，$dv=e^x dx$，得 $e^x \\sin x - \\int e^x \\cos x\\,dx$\n- 第二次：对 $\\int e^x \\cos x\\,dx$ 再分部积分\n- 得方程：$I = e^x \\sin x - e^x \\cos x - I$\n- 解得：$I = \\frac{e^x(\\sin x - \\cos x)}{2} + C$\n\n### 例4：含负指数\n$$\\int \\frac{\\arctan e^x}{e^{2x}}\\,dx = -\\frac{1}{2}\\int \\arctan e^x\\,d(e^{-2x})$$\n令 $u=\\arctan e^x$，$dv=d(e^{-2x})$，需注意 $du=\\frac{e^x}{1+e^{2x}}dx$\n\n---\n\n## 特殊情形处理\n1. **只有一类函数**：如 $\\int \\ln x\\,dx$，视为 $1\\cdot\\ln x\\,dx$\n2. **乘积含三个因子**：先组合两个放入 $dv$，或换元简化\n3. **分母复杂**：考虑整体代换或分部积分后消去分母\n4. **定积分**：计算时先求原函数，注意上下限代入\n\n**还有更重要的一点是**\n不要被形式迷惑了双眼，$\\frac{1}{\\cos x^2}$是什么啊？不认识？这就不对了\n我认为，直接先表示回去就行了，这下认出来了（\n然后看到对$\\sec x$求导时不要忘记公式，还在企图自己推导\n\n## 商的导数逆运算（反向商法则）\n\n在积分中，有时会遇到形如 $\\frac{u'v - uv'}{v^2}$ 的被积函数，这正是商函数 $\\left( \\frac{u}{v} \\right)'$ 的导数。因此，可以直接写出原函数 $\\frac{u}{v} + C$。\n\n---\n\n### 核心识别技巧\n\n1. **分母为平方形式**：通常为 $v^2$ 或可化为 $v^2$。\n2. **分子为两项之差**：且每项均为两个函数的乘积（即 $u'v$ 和 $uv'$）。\n3. **找出 $u$ 和 $v$**：从分母中猜测 $v$（通常为分母的“一部分”），再根据分子确定 $u$。\n\n---\n\n### 一般步骤\n\n设被积函数为 $\\frac{P(x)}{Q(x)}$：\n1. 尝试将 $Q(x)$ 写成 $v^2$ 的形式（或类似）。\n2. 观察 $P(x)$ 是否能表示为 $u'v - uv'$。\n3. 若可以，则积分结果为 $\\frac{u}{v} + C$。\n例题：\n$$\\int\\frac{xf'(x)-(1+x)f(x)}{x^2e^x}\\,dx$$\n- **分母**：$x^2 e^x = (x e^x)^2 \\cdot e^{-x}$？实际上，直接考虑函数 $\\frac{f(x)}{x e^x}$ 的导数。\n- 设 $v = x e^x$，则 $v' = (1+x)e^x$。\n- 设 $u = f(x)$，则 $u' = f'(x)$。\n- 计算 $\\left( \\frac{u}{v} \\right)' = \\frac{u'v - uv'}{v^2} = \\frac{f'(x) \\cdot x e^x - f(x) \\cdot (1+x)e^x}{(x e^x)^2} = \\frac{x f'(x) - (1+x)f(x)}{x^2 e^x}$。\n- 因此，原积分 $= \\frac{f(x)}{x e^x} + C$。\n\n### 常用构造\n\n1. **对于 $\\int \\frac{f'(x)g(x) - f(x)g'(x)}{g(x)^2} dx$**，结果为 $\\frac{f(x)}{g(x)} + C$。\n2. **对于 $\\int \\frac{f'(x)g(x) - f(x)g'(x)}{[g(x)]^n} dx$**（$n \\neq 2$），通常需要调整。","tags":["数学"]},{"title":"华中农业达大学迎新赛题解与反思","url":"/ZestfulYK-blog/2025/12/07/华中农业达大学迎新赛题解与反思/","content":"\n[M-终极考验](https://ac.nowcoder.com/acm/contest/123093/M)\n\n这题的大致思路是对的，但是最后处理差分时，直接选择了min(i+x,n)，这个就不对了，因为我们要的不是二选1，而是只有在满足要求时才处理。所以把min改成if判断就行了，下次需要注意这个逻辑问题。\n\n[H-对决](https://ac.nowcoder.com/acm/contest/123093/H)\n\n这个题目是纯暴力的搜索题，那么只要一个一个判断就好了，但是此处注意循环范围是$\\leq n-4$而不是$<n-4$.最好自己先之上推导一下再提交\n\n[B-爱的魔法](https://ac.nowcoder.com/acm/contest/123093/B)\n\n这一题一开始的错误原因是没有注意到交换最接近的会导致得到的不是最大的数字，例如1999，交换以后是9199是不对的，所以要倒遍历。建议自己先多造几组数据再提交，包括一些边界情况等等。随机数也不错（较小范围能手推的）\n\n","tags":["算法"]},{"title":"异或笔记","url":"/ZestfulYK-blog/2025/12/07/异或笔记/","content":"### 一、 异或的基本性质（基石）\n\n记住这四条，其他大多可以推导：\n\n1. **归零律**：`a ⊕ a = 0`\n2. **恒等律**：`a ⊕ 0 = a`\n3. **自反性**（交换律与结合律的推论）：`a ⊕ b ⊕ a = b`\n4. **交换律**与**结合律**：运算顺序和分组不影响结果。这使得前缀异或成为可能。\n\n### 二、 前缀异或：子数组问题的利器\n\n这是处理**子数组异或和查询**最核心的技巧，类似于前缀和。\n\n- **定义**：设 `pre[i] = a[1] ⊕ a[2] ⊕ ... ⊕ a[i]`，并约定 `pre[0] = 0`。\n- **核心公式**：`a[l] ⊕ a[l+1] ⊕ ... ⊕ a[r] = pre[r] ⊕ pre[l-1]`\n    - **原理**：`pre[r] ⊕ pre[l-1] = (前缀到r) ⊕ (前缀到l-1)`，根据结合律和归零律，相同的部分（前l-1项）抵消，剩下就是区间 `[l, r]` 的异或和。\n- **应用场景**：\n    - 快速求任意子数组异或和。\n    - 将“子数组异或和为0”的条件转化为 `pre[r] == pre[l-1]`。**这是解题的关键一步！**\n    - 问题转化为对前缀异或数组 `pre` 的分析，常结合哈希表（`unordered_map`）来统计次数、寻找配对。\n\n### 三、 位运算的独特性质（解题突破口）\n\n1. **不进位加法/减法**：异或在每一位上独立操作。`a ⊕ b` 在二进制下，每一位的规则是“相同为0，不同为1”。这暗示我们可以**按位考虑问题**。\n2. **判断奇偶性**（结合律的妙用）：\n    - 多个数异或，结果的**最低位** 等于 所有数最低位的异或。\n    - 而一个数二进制最低位为 `1` 代表奇数，为 `0` 代表偶数。\n    - **推论**：在一堆数中，异或结果的奇偶性 等于 所有数奇偶性的异或。这在一些博弈或奇偶分类问题中有用。\n3. **与加法的关系**：`a ⊕ b <= a + b`。等号成立当且仅当 `a` 和 `b` 的二进制表示没有同时为1的位（即 `a & b == 0`）。这个性质在涉及“最大异或和”与“和”的比较时常用。\n4. **构造互补对**：对于任意数 `x`，存在唯一的数 `y`，使得 `x ⊕ y = (全1的二进制串)`，这个 `y` 等于 `~x`（在限定位数下）。在构造题中，常用 `(1<<k)-1 - x` 来得到与 `x` 在 `k` 位下每一位都相反的数。\n### 四、 经典题型与技巧\n1. **寻找唯一出现奇数次的数**：利用 `a⊕a=0`，将所有数异或，出现偶数次的会两两抵消，结果就是那个出现奇数次的数。\n2. **寻找两个只出现一次的数**（其他出现两次）：\n    - 第一步：将所有数异或，得到 `x = a ⊕ b`（`a`, `b` 为所求）。\n    - 第二步：找到 `x` 的任意一个为 `1` 的二进制位。这一位意味着 `a` 和 `b` 在这一位上不同。\n    - 第三步：根据这一位将原数组分成两组，分别异或，得到的两个结果就是 `a` 和 `b`。\n3. **最大/最小异或对问题**：\n    - **暴力**：`O(n^2)` 对于大数据不行。\n    - **优化（`O(n*logC)`）**：使用**01-Trie（字典树）**。将数字按二进制从高位到低位插入Trie，查询时尽量“走相反位”可以得到最大异或值，“走相同位”可以得到最小异或值。这是必须掌握的高级数据结构。\n4. **异或相关的构造题**（如你刚才遇到的）：\n    - **核心目标**：控制前缀异或数组 `pre` 的值。\n    - **常用手段**：\n        - 让 `pre` 数组的值是 `0` 到 `n` 的一个排列，然后微调（例如交换两个值）来满足特定区间异或为0的条件。\n        - 利用性质：如果 `pre[l-1] = pre[r]`，则区间 `[l, r]` 异或为0。要保证其他区间不为0，就要保证其他任意 `pre[i]` 与 `pre[j]` 都不相等（除了我们特意制造的那一对相等）。\n        - 注意题目对 `a[i]` 取值范围的限制（如 `1 <= a[i] <= 1e9`），这要求 `pre[i] ⊕ pre[i-1]` 的结果必须在这个范围内。通常用连续整数构造 `pre` 可以满足。\n\n### 五、 做题时的注意事项（避坑指南）\n\n1. **注意数据范围和溢出**：你刚才遇到的问题就是典型。当使用2的幂构造时，`2^30 ≈ 1e9`，所以区间长度不能超过30。必须时刻检查构造值是否在允许范围内。\n2. **小心 `0`**：异或中 `0` 是单位元，非常特殊。在构造时，如果允许元素为 `0`，可能会意外产生多个异或为0的子数组（例如单个元素为0）。题目常要求**正整数**来避免这种情况。\n3. **前缀异或的初始化**：务必定义 `pre[0] = 0`，这样才能正确表示从 `a[1]` 开始的子数组。\n4. **调试方法**：对于小数据，可以暴力计算所有子数组的异或和来验证你的构造是否正确。\n5. **思维转化**：遇到“所有子数组异或和不为0”这类强条件，要立刻想到它等价于“前缀异或数组 `pre` 中所有元素两两不同（且 `pre[0]=0` 也不与其他重复）”。这大大简化了问题。\n### 六、 推荐的巩固练习方向\n\n1. **基础**：LeetCode 136（只出现一次的数字）、LeetCode 268（缺失数字）。\n2. **进阶**：LeetCode 260（只出现一次的数字 III）、LeetCode 421（数组中两个数的最大异或值）**（必做，练习01-Trie）**。\n3. **综合与构造**：Codeforces 上的许多构造题（难度 1500-1800），比如你刚才做的这道题的原型。多观察题解中是如何利用前缀异或性质进行构造的。\n\n总结一下，异或问题的核心思路是：**利用前缀异或转化区间问题，利用归零律和结合律进行抵消与配对，利用位独立性进行按位处理或使用Trie**。多练习，你会对这种“魔力”运算越来越有感觉。\n\n因为异或可以逆运算，所以此处直接先算1-n的异或和再和现在的异或和异或一下就行了。\n这样就找到了那个没有出现过的数字。\n找出现奇数次的数字时，可以直接异或，因为只有一个数字满足这个要求，那么最后剩下的那个就是无法完成匹配的数字，就是答案了。\n找两个只出现一次的数字时，也是先异或得到$x=x_1\\oplus x_2$，然后看不一样的那一位来分开数组。\n解释：就是看这一位是否是1，然后就和只出现一次的数那题一样了。出现两次的数，分组一定在一起，那么就相互异或抵消了。","tags":["算法"]},{"title":"ACM数字类题目","url":"/ZestfulYK-blog/2025/12/07/数字类算法/","content":"# 数字类题目\n\n- 定义：通常有乘除法，或者时分解质因数之类的\n\n**重要观察**\n\n$2^{30} >= 10^9$所以一般不需要几个数就能乘到上界，除法的话同理，分解质因数实际上也算乘法。\n因此这类题目往往可以比较暴力的解决。因为只要枚举这几个位置即可。\n\n重要例题：\n\n1.题目传送门[Strange Machine](https://codeforces.com/contest/2156/problem/B)\n- 重要观察：$log_2(10^9)=30$,所以除去全是1的情况，每次除2最多30次循环就结束了，因此可以暴力解决。除了有1的情况，因为n最大为20，所以最多$20*30$每个数据。\n\n2.题目传送门[Even Modulo Pair](https://codeforces.com/contest/2164/problem/B)\n- 重要观察，要塞大量数据来导致超时的话是不可能的，因为在30个数内必然能找到。\n理由：首先如果只有偶数，那么一定有解。（因为严格递增）\n\t当只有奇数时：\n\t因为当$y<2*x$时，必然有$y \\mod x \\ = \\ y-x \\ = \\text{偶数}$,因此要构造较大的数据的话，只能让$y \\geq x *2$\n\t要让$y \\mod x \\ !=  \\text{偶数}$，那么最小只能构造$y=x*2$那么和上一题就一样了。\n\n3.题目传送门[Add 0 or K](https://codeforces.com/problemset/problem/2134/B)\n- 题目理解，首先要求吧原数组每个元素加上K的若干倍，构成含有相同因子的数组。\n- 重要观察：加完以后，因为含有相同的因子，所以考虑把每个加完以后的数字拆分，得到一串质数，而前29个质数的乘积已经大于$10^9$了，所以直接可以算出最终的共同因子。\n接下来对最后结果化简$a_i+c_i*k \\equiv 0  (mod\\ g)$,所以$c_i=(-a_i)*inv_k$\n而k存在$mod \\ g$下有逆元，需要g和k互质，所以可以简单完成。\n\n4.题目传送门[C-区间乘_2025年广东工业大学新生赛（同步赛）](https://ac.nowcoder.com/acm/contest/123428/C)\n- 希望我们计算一个区间的乘积，判断是否可能达到给定的输出。\n- 数据规模n和查询规模q都是$2*10^5$所以不能直接查询。\n- 重要观察：如果把1去掉算法就能变简单，而如果不是全为1的话，查询数据$x \\leq 10^9$，所以当不是1的时候，只要30个2就能超过数据范围了，每个位置计算一下，可以直接提取计算可能出现的数字，故最多$30*2*10^5$次计算，查询$q\\log_2(x)$次就行了\n所以最终时间复杂度是$O(T*count*q\\log_2(q))$ \ndirt=（总提交次数-过题数量）/总提交次数\n\n然后注意，只有质因数时可以用，其他的如因子就不行\n出现奇偶判断的也不要用这个方法，用奇偶性分析特判\n\n# GCD二级结论\n\n## 结论1\n$$lcm(a,b)*gcd(a,b)=ab$$\n## 结论2\n$$gcd(a,b) = gcd(a,|b-a|)$$\n\n## 结论3\n$$gcd(a,b,c)=1等价于存在ax+by+cz =1$$\n## 结论4\n$$gcd(a,b) = g * gcd(a >> k,b >> k)\\,(g = 2 ^ k)$$\n## 结论5\n$$gcd(a^{n-1},a^{m-1})=a^{gcd(n,m)-1}$$\n## 结论6\n$$gcd(f_n,f_m)=f_{gcd(n,m)}$$\n斐波那契数列\n\n# 数论题目\n\n## 例题\n\n- 题目描述：求N个数，相乘等于M\n- 题目转化，因为相乘等于M，那么得到的每一个数必然都是由M的质因数转化而来的，那么考虑每一个质因数在排列中出现的位置，就得到实际上是求把m个球放到n个不同的盒子里的方案数，每一个质因数都要计算一次，相乘得到答案。\n那么怎么计算**把m个球放到n个不同的盒子里的方案数**呢？\n引用一下某大佬的解释：\n>我们回头看看2(球同，盒不同，不允许空盒)。在2的条件下，我们可以给出另一个处理方案：\n如果我们给每个盒子都放上1个球，那么剩下的n-m个球放入m个盒子里，就不需要管是否有空盒了（因为已经事先给每个盒子都放了一个球）。\n如果用T(n-m, m)表示加粗部分的方案数量，那么2的答案 = 1（先每个盒子一个球，只有1种放法） * T(n-m, m)。\n那么显然，T(n-m, m)就是情况3，只不过是n-m个球入m个盒，而不是我们要求的n个球入m个盒。\n那么我们只需要把2情况里，球的总数量变成n+m个，在上述方案里，就会变成“如果我们给每个盒子都放上1个球，那么剩下的n + m - m = n个球放入m个盒子里，就不需要管是否有空盒了”\n因此，方案数量在数值上是等于2里，把n替换成n+m的：\n方案数量 = C(n + m - 1, m - 1)\n\n那么接下来我们计算阶乘和逆元就能解答了（\n（怎么这么麻烦，没招了）","tags":["算法"]},{"title":"计算机18讲题解","url":"/ZestfulYK-blog/2025/12/07/计算机18讲题解/","content":"\n#### 小技巧\n- 在网页前面加上read有奇效\n例如：\n```html\nraed:https://www.reach-top.cn.com\n```\n这个是阅读器模式，开启以后就能获取里面原先不让复制的内容了\n## A题\n\n-  题目描述\n每个整数都应输出一个各位数字和，并独占一行。\n- 解题思路\n拿之前上课的程序自然是能解决的，直接一个循环算到底\n每一位的值是n%10，要取得下一位就n/=10再算就彳亍了\n但是注意到这节课的标题是函数，那么我们就编写一个递归程序来计算每一位的和\n边界条件：n<=10\n递推式子：n %10+solve(n/10)\n- 参考代码\n```C++\nll solve(ll n){\n  if(n<10) return n;\n  return n%10+solve(n/10);\n}\nsigned main(){\n  ll T;\n  while(cin>>T)\n\tcout<<solve(T)<<endl;\n  return 0;\n}//此处#define ll long long\n```\n## B题\n\n- 题目描述\n给定若干个正整数，请你从这些整数中找到最小值和第二小的值，计算一下第二小的数值减去最小值的结果是不是素数，如果是则输出Yes，否则输出No\"o。 \n- 解题思路\n直接写一个循环计算最小值和次小值，然后判断差是不是素数就行了\n计算最小值和次小值的思路，如果输入值x比最小值小，那么把次小值改成原先的最小值，再把最小值修改为输入值x，如果只是比次小值小，那么把次小值改成输入值x\n- 参考代码\n```C++\nvoid isprime(int n){\n  if(n==1){\n    cout<<\"No\\\"o\"<<endl;\n    return;\n  }\n  for(int i=2;i<=sqrt(n);i++){\n    if(n%i==0){\n      cout<<\"No\\\"o\"<<endl;\n      return;\n    }\n  }\n  cout<<\"Yes\"<<endl;\n}\nsigned main()\n  ll minn1=1e18,minn2=1e18,x;\n  while(cin>>x){\n    if(x<minn1){\n      minn2=minn1;\n      minn1=x;\n    }\n    else if(x<minn2)\n      minn2=x;\n  }\n  isprime(minn2-minn1);\n  return 0;\n}\n```\n\n\n## C题\n\n- 题目描述\n哥德巴赫猜想大家都知道一点吧。我们现在不是想证明这个结论，而是想在程序语言内部能够表示的数集中，任意取出一个偶数，来寻找两个素数，使得其和等于该偶数。  做好了这件实事，就能说明这个猜想是成立的。由于可以有不同的素数对来表示同一个偶数，所以专门要求所寻找的素数对是两个值最相近的。\n- 解题思路\n直接暴力求解从中间开始计算，设两个数分别是x，y，然后x--，y++，判断是否是合法的，如果合法那么输出，这样得到的第一组解必然是最小的一组解。\n判断是否是素数的代码可以用上一题的代码。\n- 参考代码\n```C++\nbool isprime(ll n){\n  if(n==1) return false;\n  for(int i=2;i<=sqrt(n);i++){\n    if(n%i==0)\n      return false;\n  }\n  return true;\n}\nsigned main(){\n  ll x;\n  while(cin>>x&&x){\n    ll a1=x/2,a2=x/2;\n    while(1){\n      if(isprime(a1)&&isprime(a2)){\n        cout<<a1<<' '<<a2<<endl;\n        break;\n      }\n      a1--; a2++;\n    }\n  }\n  return 0;\n}\n```\n\n## D题\n\n- 题目描述\n求给定n个正整数的最大公约数\n- 解题思路\n计算每个数和现在得到的最大公约数的最大公约数\n首先先默认最大公约数为第一个正数，然后计算即可。\n计算最大公约数其实有两种方式，要是你用万能头的话，可以使用自带函数直接计算。\n这里采用的是标准的辗转相除法。\n- 参考代码\n```C++\nll gcd(ll n,ll m){\n  if(n%m==0) return m;\n  else return gcd(m,n%m);\n}\nsigned main(){\n  ll n,x; cin>>n;\n  ll m=n,maxgcd;\n  while(cin>>x&&n){\n    if(x<=0) continue;\n    if(n==m) maxgcd=x;\n    n--;\n    maxgcd=gcd(maxgcd,x);\n    //maxgcd=__gcd(x,maxgcd);这个是自带的函数，也是可以的\n  }\n  cout<<maxgcd<<endl;\n}\n```\n\n## E题\n- 题目描述\n找比x大的第一个回文数\n- 解题思路\n每次加1，直到找到回文数为止。\n判断回文数的话，直接先一位一位取出来，然后计算，一个正向遍历，一个反向遍历，结果一样就是回文。\n- 参考代码\n```C++\nbool hws(ll x){\n  ll a[2000],id=1;\n  while(x){\n    a[id++]=x%10;\n    x/=10;\n  }\n  for(int i=1;i<id;i++)\n    if(a[i]!=a[id-i])\n      return false;\n  return true;\n}\nsigned main(){\n  ll x;\n  while(cin>>x){\n    x++;\n    while(!hws(x++));\n    cout<<x-1<<endl;\n  }\n}\n```\n这里因为要求要比x大，所以先x++，最后输出x-1的原因是循环里写的是x++最后会多1。\n\n## F题\n- 题目描述\n如果一个数从左到右和从右到左读都一样，那么这个数就叫做“回文数”。如果一个数的十进制和二进制表示都是回文数，则把这个数叫做“双重回文数”。例如，十进制33是回文数，将其转化为二进制表示100001也是回文数，所以33是双重回文数。编写程序，查找1~1000的所有双重回文数。\n- 解题思路\n和上一题一样，只不过要多出力一个二进制的而已。\n- 参考代码\n```C++\nbool hws(ll x){\n  ll a[2000],id=1;\n  ll y=x;\n  while(x){\n    a[id++]=x%10;\n    x/=10;\n  }\n  for(int i=1;i<id;i++)\n    if(a[i]!=a[id-i])\n      return false;\n  \n  id=1;\n  while(y){\n    a[id++]=y%2;\n    y/=2;\n  }\n  for(int i=1;i<id;i++)\n    if(a[i]!=a[id-i])\n      return false;\n  return true;\n}\nsigned main(){\n  for(int i=1;i<=1000;i++)\n    if(hws(i)) cout<<i<<\"为双重回文数\"<<endl;\n}\n```\n\n\n\n\n\n\n","tags":["算法"]},{"title":"模运算性质总结","url":"/ZestfulYK-blog/2025/11/25/mod/","content":"# 模运算（Mod）性质总结\n\n## 定义\n\n对于任意实数 $( x, y )$，有：\n\n$$x \\mod y = x - y \\left\\lfloor \\frac{x}{y} \\right\\rfloor, \\quad y \\neq 0$$\n\n模运算（在一些场合使用符号 % 表示）是一个二元运算。$( x \\mod y )$ 的值范围如下：\n\n- 当 $( y > 0 )$ 时：$( 0 \\leq x \\mod y < y )$\n- 当 $( y < 0 )$ 时：$( 0 \\geq x \\mod y > y )$\n- 当 $( y = 0 )$ 时：为避免除以零，定义 $( x \\mod 0 = x )$\n\n## 基本运算规则\n\n模运算与基本四则运算类似（除法除外）：\n\n1. **加法规则**：$((a + b) \\mod p = (a \\mod p + b \\mod p) \\mod p)$\n2. **减法规则**：$((a - b) \\mod p = (a \\mod p - b \\mod p) \\mod p)$\n3. **乘法规则**：$((a \\times b) \\mod p = (a \\mod p \\times b \\mod p) \\mod p)$\n4. **幂运算规则**：$(a^b \\mod p = ((a \\mod p)^b) \\mod p)$\n5. **求和规则**：由第1个公式可推导出 $(\\left(\\sum_{i=1}^{n} x_i\\right) \\mod p = \\left(\\sum_{i=1}^{n} (x_i \\mod p)\\right) \\mod p)$\n\n## 运算律\n\n### A. 结合律\n\n$$((a + b) \\mod p + c) \\mod p = (a + (b + c) \\mod p) \\mod p$$\n\n$$((a \\times b) \\mod p \\times c) \\mod p = (a \\times (b \\times c) \\mod p) \\mod p$$\n\n### B. 交换律\n\n$$(a + b) \\mod p = (b + a) \\mod p$$\n\n$$(a \\times b) \\mod p = (b \\times a) \\mod p$$\n\n### C. 分配律\n\n$$(a + b) \\mod p = (a \\mod p + b \\mod p) \\mod p$$\n\n$$((a + b) \\mod p \\times c) \\mod p = ((a \\times c) \\mod p + (b \\times c) \\mod p) \\mod p$$\n\n## 补充性质\n\n### 同余性质\n\n- **反身性**：$(a \\equiv a \\pmod{m})$\n- **对称性**：如果 $(a \\equiv b \\pmod{m})$，则 $(b \\equiv a \\pmod{m})$\n- **传递性**：如果 $(a \\equiv b \\pmod{m})$ 且 $(b \\equiv c \\pmod{m})$，则 $(a \\equiv c \\pmod{m})$\n\n### 模运算与除法\n\n模运算与除法不直接兼容，但有以下性质：\n\n- 如果 $(ac \\equiv bc \\pmod{m})$ 且 $(\\gcd(c, m) = 1)$，则 $(a \\equiv b \\pmod{m})$\n    \n- **模逆元**：如果 $(\\gcd(a, m) = 1)$，则存在整数 $(b)$ 使得 $(ab \\equiv 1 \\pmod{m})$，称 $(b)$ 为 $(a)$ 模 $(m)$ 的逆元\n    \n- **核心性质**：在模运算里除以一个数等于乘以这个数的逆元，即：$$c/a≡c×a^{−1} (modm)$$其中 $a^{-1}$ 是 $a$ 在模 $m$ 下的逆元。\n\n**重要前提**：模逆元存在的**充分必要条件**是 $\\gcd(a, m) = 1$（即 $a$ 与 $m$ 互质）。如果 $a$ 与 $m$ 不互质，则 $a$ 在模 $m$ 下没有逆元，除法操作无法进行。\n\n---\n#### 计算模逆元的方法\n\n常用的计算模逆元的方法是**扩展欧几里得算法**，它不仅能求最大公约数，还能找到满足贝祖等式的系数。\n\n示例代码;\n```C++\n#include <iostream>\nusing namespace std;\n\n// 扩展欧几里得算法求逆元\nlong long mod_inverse(long long a, long long m) {\n    long long m0 = m;\n    long long y = 0, x = 1;\n    \n    if (m == 1) return 0;\n    \n    while (a > 1) {\n        long long q = a / m;\n        long long t = m;\n        \n        m = a % m;\n        a = t;\n        t = y;\n        \n        y = x - q * y;\n        x = t;\n    }\n    \n    if (x < 0) x += m0;\n    \n    return (a == 1) ? x : -1; // 如果逆元不存在返回 -1\n}\n\n// 使用示例\nint main() {\n    long long a = 3, m = 7;\n    long long inv = mod_inverse(a, m);\n    if (inv != -1) {\n        cout << a << \" 在模 \" << m << \" 下的逆元是: \" << inv << endl;\n    } else {\n        cout << a << \" 在模 \" << m << \" 下没有逆元\" << endl;\n    }\n    return 0;\n}\n```\n\n#### 应用示例\n\n计算 $6 / 3 \\pmod{7}$：\n\n1. 先求 $3^{-1} \\pmod{7}$：$3 \\times 5 = 15 \\equiv 1 \\pmod{7}$，所以逆元为 5\n    \n2. $6 / 3 \\equiv 6 \\times 5 = 30 \\equiv 2 \\pmod{7}$\n    \n3. 验证：$2 \\times 3 = 6 \\equiv 6 \\pmod{7}$ ✓\n    \n\n这个性质在密码学、组合数学和算法竞赛中都有广泛应用。\n### 模运算的周期性质\n\n- 对于任意整数 $(k)$，有 $(a \\mod m = (a + km) \\mod m)$\n- 模运算的结果具有周期性，周期为模数 $(m)$\n\n# 逆元的计算\n\n- 如果是计算单个的逆元，那么使用小费定理：\n```C++\nll qpow(ll a,b=mod-2) {\n    ll res = 1;\n    while (b) {\n        if (b & 1) res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\n```\n\n- 计算多个数字的逆元，使用拓展欧几里得算法\n```C++\nLL inv[mod+5]; \nvoid getInv(LL mod) { \n\tinv[1]=1; \n\tfor(int i=2;i<mod;i++) \n\t\tinv[i]=(mod-mod/i)*inv[mod%i]%mod; \n}\n```\n\n- 然后如果是一个等式的话，考虑两边同时取逆元\n- 例如：计算$n!$的逆元，得到递推式子\n$$(i+1)! \\equiv i \\,!*(i+1) \\mod p$$\n所以：$$inv[(i+1)!]\\equiv inv[i]*inv[i+1] \\mod p$$\n又因为：$$inv[i+1]*(i+1)\\equiv1\\mod p$$\n所以把已知的$inv[i+1]$移到左边，得到：$$inv[(i+1)!]*(i+1)\\equiv inv[i] \\mod p$$\n这就是求阶乘逆元的递推式了","tags":["算法"]},{"title":"算法挑战赛题解","url":"/ZestfulYK-blog/2025/11/20/2/","content":"\n### 算法挑战赛第二期题解\n\n## 题目\n\n- 二进制小数的乘积~HC哥哥说这个很困！难！\n\n- Description\n\n> HC哥哥今天又突发奇想，它依然定义一个数字为二进制小数，如果它是一个正整数，并且其十进制表示中的所有数字都是0或1。例如，110 是一个二进制小数，而 102 和 787 不是。\n\n> 现在HC哥哥给定你一个数 n，你被要求判断是否可能将 n 表示为一些（不一定是不同的）二进制小数的乘积。\n\n\n- Input\n\n> 第一行包含一个整数 t（1≤t≤5⋅10^4）— 测试用例的数量。\n\n> 每个测试用例的唯一一行包含一个整数 n（1≤n≤10^5）。\n\n\n- Output\n\n> 对于每个测试用例，如果 n 可以表示为一些二进制小数的乘积，则输出 \"YES\"（不带引号），否则输出 \"NO\"（不带引号）。\n\n- 题目解释 （~~翻译成人话~~）\n\n计算把01串强制转换为整数，再相乘得到的数就是合法的数字，其余都是不合法的。\n那么直接**打表**就行了，总共1e5个数，打表还是很容易实现的\n\n接下来我们来学习一下该怎么打表\n\n## 打表\n\n- 定义 : 计算出所有情况，然后直接判断。\n\n比如问你100以内的数是否是质数，你肯定能直接回答，因为你已经把100以内的质数全部背下来了。这其实就是打表的一种体现，你提前计算前100内的数是否是质数，然后直接调用答案。\n\n但是我们的计算机实际上并不知道一个问题的所有解，那么你自己提前算好告诉它不就彳亍了吗。\n\n这时我们需要两个重要程序：**打表程序**和**判断程序**。\n\n### 打表程序\n\n- 用于计算所有情况的答案，不用关心时间复杂度，反正是提前计算\n\n比如计算素数集，你直接暴力就好了，不会欧拉筛又有什么关系呢？\n\n### 判断程序\n\n- 用于直接获得答案的程序，时间复杂度O(n),n为数据规模，每次查询的时间复杂度为O(1)。\n\n**接下来就该思考怎么写一个无脑的程序来计算这些情况了**\n\n## 做法\n\n- 首先先写一个无脑程序生成所有01组合的数\n```C++\nvector<ll> ans;\nint main(){\n    for(int i=1;i<=100000;i++){\n        ll x=i,cnt=0,w=0;\n        while(x){\n            if(x%10<2) cnt++;\n            w++;\n            x/=10;\n        }\n        if(cnt==w) ans.push_back(i);\n    }\n    for(auto &i:ans)\n        cout<<i<<\",\";\n}\n```\n\n> 此处是对每一位进行判断，如果01的个数和位数一样，那么就是一个合法的数字\n\n- 得到如下结果：\n```C++\n\n1,10,11,100,101,110,111,1000,1001,1010,\n1011,1100,1101,1110,1111,10000,10001,10010,\n10011,10100,10101,10110,10111,11000,11001,\n11010,11011,11100,11101,11110,11111,100000\n```\n\n- 把以上结果复制进下一段生成代码，然后再计算所有合法的数字\n```C++\nll number[1010]={0,1,10,11,100,101,110,111,1000,1001,\n    1010,1011,1100,1101,1110,1111,10000,10001\n    ,10010,10011,10100,10101,10110,10111,11000\n    ,11001,11010,11011,11100,11101,11110,11111,100000};\nset<ll> s;\nll dfs(ll n){\n    s.insert(n);\n    for(int i=2;i<=32;i++){\n        if(n*number[i]<=100000)\n           dfs(n*number[i]);\n    }\n    return 0;\n}\nsigned main(){\n    dfs(1);\n    ll cnt=0;\n    for(auto &i:s){\n        cout<<i<<\",\";\n        cnt++;\n    }\n    cout<<endl<<cnt<<endl;\n    return 0;\n\n}\n```\n\n> 此处使用了dfs(Deep First Search)，文末会有详细介绍\n\n- 得到如下结果：\n```C++\n1,10,11,100,101,110,111,121,1000\n,1001,1010,1011,1100,1101,1110,\n1111,1210,1221,1331,10000,10001,\n10010,10011,10100,10101,10110,10111,\n10201,11000,11001,11010,11011,11100,\n11101,11110,11111,11121,11211,12100,\n12111,12210,12221,12321,13310,13431,\n14641,100000\n```\n\n- 最后再是无脑的判断程序：\n```C++\nvector<string> ans;\nll a[1010]={0,1,10,11,100,101,110,111,121,1000,1001,1010,1011,1100,1101,\n    1110,1111,1210,1221,1331,10000,10001,10010,10011,10100,10101,10110,\n    10111,10201,11000,11001,11010,11011,11100,11101,11110,11111,11121,\n    11211,12100,12111,12210,12221,12321,13310,13431,14641,100000};\nvoid solve(){\n    ll x; cin>>x;\n    for(int i=1;i<=47;i++){\n        if(a[i]==x){\n            ans.push_back(\"YES\");\n            return;\n        }\n    }\n    ans.push_back(\"NO\");\n}\nint main(){\n    ll T; cin>>T;\n    while(T--) solve();\n    for(auto &i:ans)\n        cout<<i<<endl;\n}\n```\n\n不是我说，这种做法在打表题目是真轮椅吧，时间复杂度完全没影响，计算出来总共就47个数字，简单版甚至20个都没到，非常适合不会搜索的蒻蒟(比如我)学习和理解。\n\n\n### 下面是对dfs(Deep First Search)算法的详细介绍：\n\n- 什么是dfs？\ndfs是深度优先搜索的英文缩写，以深度为优先来进行计算\n\n比如，要计算走n级楼梯（每次一到两级台阶）有几种走法，就可以使用dfs，假设第一次先走一步，依次遍历，如果能刚好走到n则方法数加1，如果超过了n则返回到上一步，回头找下一个方法。\n\n- 在本题的应用\n\n那么在这题，我们已经提前计算了所有合法的数字，我们每次乘上可能的数字，看看是否依旧合法，之后在超过1e5时返回，相当于楼梯数为1e5，每次可以走number[1....n]步，但是每一个小于n的位置都合法，并存储答案。\n\n如果想进一步了解dfs，可以访问OIwiki进行学习！\n\n那么本期的题解就到此结束了，感谢阅读！如果想交流算法题，也可以添加我的qq哦(717056060)\n\n#                        关注ZestfulYK，谢谢喵！"},{"title":"算法挑战赛题解（11.2）","url":"/ZestfulYK-blog/2025/11/03/1/","content":"\n# 算法挑战赛题解（11.2）\n\n## 简单版本：\n\n### 题目大意：\n\n给定n个区间，判断这些区间能划分出几种不同的区域\n\n- [性质不同的数字](http://www.zjutacm.cn/problem/3120)\n\n### 题目分析：\n\n实际上是在讨论每个点被哪几个区包含，在样例中，数据是这样的，我们来分析一下这两个样例\n\n```yaml\nSample Input 1 \n\n1\n1 6\n\nSample Output 1\n\n2\n\nSample Input 2\n\n4\n0 12\n4 13\n6 13\n12 13\n\nSample Output 2\n\n6\n\n```\n\n### 样例分析：\n\n```yaml\n样例1: 0 1 1 1 1 1 1 0 0 … …  所以是两种区间\n样例2: 1   2  3   4   5   6   7  8    9   10  11  12  13 … …\n       1   1  1   1   1   1   1  1   1    1   1   1\n                  2   2   2   2  2   2    2   2   2   2\n                          3   3  3   3    3   3   3   3\n                                                  4   4\n       |< ------ >|< ---- >|< ----------------- >|<->|<->|<--\n\n```\n\n所以是6种区间\n这样,我们就弄明白了题目在讲什么,接下来就可以思考怎么实现了\n\n### 题目思路：\n\n实际上有些人会以为我们需要统计的是这个点有几个区间经过，但是这是错误的，在样例二就能发现这一点。\n（这也是我第一次的想法，测试样例二时发现的T_T）\n\n我们需要思考怎么表示这一个点有哪些区间经过，而且每一个区间是互不相同的。这里我们考虑类似**状态压缩**的思想。\n\n什么是状态压缩呢？简而言之就是用一个数来代替这个状态。\n比如说，我们用1表示未进行，2表示正在进行，3表示完成，\n那么一个含有4个任务的任务表可以是这样的：\n\n                1321\n\n（1，4任务未进行，2任务完成，3正在进行）\n\n我们使用了一个4位数表示了这一状态，这样就实现了状态压缩，我们没有用数组存储状态，而是一个数，这样我们在判断两个状态是否相同时就可以直接判断数字是否相同了，节约了时间和判断的复杂度。\n\n那么怎么把这个思想用在这一题呢？我们考虑给每个区间一个标号k，每个区间内的点加上2^k，这样就保证了每一个状态不会重复。\n但是这么写居然WA了！这是因为数据范围n是[0,300]也就是会有2^300，远大于long long的最大范围(2^64-1)这显然是不行的。\n\n实际上这个算法已经十分接近答案了,但我们还需要改进这个算法。\n接着我们想到一个类似的方法，**哈希表(hash)**。\n\n其实哈希表和刚才的思路差不多，不过加入了一些更高级的算法来防止数据溢出。\n\n### 那么什么是hash呢？\n\n实际上也是创建一种对应关系，使得在查询时能快速访问这种情况对应的值。就像上面的例子一样，我们通过我们规定的方式把任务状态和整数一一对应。\n\n### 怎么创建hash表呢？\n\n首先，找到一个质数作为进制数P，通常取131或者13331，模数mod通常取1e9+7或1e9+9，对应关系就是对应的P进制数%mod\n例如这个点上经过了134这三个集合，那么我们就把134转化为131进制，即1 * 131^2+3 * 131+4，在实际操作时，就是每一个集合的下标k作为对应的位数，则每一个点的表示可以是这样的：\n\n![公式](/images/公式.png)\n\n这样我们就计算出了每一个点的唯一标识，含有相同标识的才能算是同一个点。（这里选择质数是为了防止哈希碰撞，即不同状态的得到了相同的标记；选择mod是防止溢出）\n\n最后只要统计一下标识的个数就行了（可以用set实现）\n代码实现：对于简单版本，暴力完全够用了。\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define endl '\\n'\nconst ll P=131,mod=1e9+7;\nint main(){\n    ll n,z=1,a[1010]; cin>>n;\n    for(int i=0;i<=1000;i++) a[i]=0;\n    while(n--){\n        ll l,r; cin>>l>>r;\n        for(int i=l;i<=r;i++){\n            a[i]=(a[i]+z)%mod;\n        }\n        z=(z*P)%mod;\n    }\n    set<ll> q;\n    for(int i=0;i<=1000;i++){\n        q.insert(a[i]);\n    }\n    cout<<q.size()<<endl;\n}\n```\n\n\n所以这样我们就解决了简单版本。\n\n## 复杂版本：\n\n那么对于数据量大的**复杂版本**呢？\n\n这里我们依然采用hash，但是由于数据量大，为了防止冲突，我们给每一个区间都分配一个随机hash值，在计算时只考虑起点和终点，在进入起点时加入标记，离开时移除标记。这时我们就想到了具有可逆性质的异或，我们只要给对应的起终点打上相同标记就行了，最后还是用set统计产生的不同标记数\n\n### 参考代码：\n\n```C++\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ULL unsigned long long\n#define endl '\\n'\nint main(){\n    ll n; cin>>n;\n    vector<pair<ll,int>> box;\n    for (int i=0;i<n;i++){\n        ll l,r; cin>>l>>r;\n        box.push_back({l,i});\n        box.push_back({r+1,i});\n    }\n    sort(box.begin(),box.end());\n    vector<unsigned long long> h(n);\n    mt19937_64 rng(time(0));\n    for(int i=0;i<n;i++){\n        h[i]=rng();\n    }\n    set<ULL> s; s.insert(0);\n    ULL cur=0;ll last=-2e9;\n    for(auto& i:box){\n        ll pos=i.first,idx=i.second;\n        if(pos>last&&last!=-2e9) s.insert(cur);\n        cur^=h[idx];\n        last=pos;\n    }\n    s.insert(cur);\n    cout<<s.size()<<endl;\n}\n```\n\n```yaml\n                     感谢观看！关注ZestfulYK喵，谢谢喵！","tags":["算法"]},{"title":"压行技巧","url":"/ZestfulYK-blog/2025/10/24/压行技巧/","content":"\n#   如何给你的代码压行？\n\n如果不会压行，你的代码看起来会是这样的：\n\n```C++\nint ml(vector<int> s, int n)\n{\n    int m = s[0];\n    for (int i = 0; i <= n; i++)\n    {\n        if (s[i] > m)\n            m = s[i];\n    }\n    return m;\n}\n```\n\n整整用了9行！\n实际上其实根本不需用那么多行：\n```C++\nint ml(vector<int> s,int n){\n    int m=s[0];\n    for(int i=0;i<=n;i++){\n        if(s[i]>m)m=s[i];\n    }\n    return m;\n}\n```\n\n当然也可以更短：\n```C++\nint ml(vector<int> s,int n){\n    int m=s[0];\n    for(int i=0;i<=n;i++) if(s[i]>m) m=s[i];\n    return m;\n}\n```\n那么问题来了，怎么在不影响代码运行的情况下合理的压行呢？\n\n# 判断类循环类的压行技巧\n\n## 判断类\n\n如果判断语句仅一行，可以考虑压行：\n\n```C++\nif(a==1) sum++;\nelse sum--;\n\n//或者这样\n\nif(a==1)\n    sum++;//可以通过缩进来方便区分\n```\n\n两句的话，压行可以考虑用大括号包起来压行~~前提是你觉得看着没影响~~\n\n```C++\nif(a==1) {sum++;a=2;}\n```\n\n注意在大括号里的每一句都是要加上封号的，因为这一段代码实际上等价于：\n\n```C++\nif(a==1){\n    sum++;\n    a=2;\n}\n```\n\n## 循环类压行\n\n也和判断的一样，可以这么压行：\n\n```C++\nfor(int i=1;i<=n;i++) cout<<1<<endl;\n\n//或者这样：\n\nfor(int i=1;i<=n;i++)\n    cout<<1<<endl;\n```\n\n如果是输出的话，其实可以这么写：\n\n```C++\nfor(int i=1;i<=n;i++) cout<<i<<\" \"; cout<<endl;\n```\n\n因为```C++cout<<endl;```其实是在循环之外的，所以这么写是正确的\n\n# 头文件压行\n\n下面送给大家万能头文件：\n\n```C++\n#include<bits/stdc++.h>\n```\n\n# 其他技巧\n\n```C++\n#define ll long long\n#define rep(1,n) for(int i=1;i<=(n);i++)\nll n;\nint main(){\n    rep(1,n) cout<<\"*\"; cout<<endl;\n}\n```\n\n通过define来减少代码长度，增加可读性\n\n## 一些非常有用的C++自带函数\n\n```C++\nsort(a,a+n);//a为数组，n为a的大小\n__gcd(x,y);//x，y的最大公约数\nx=1<<n;//2的n次方\n```\n","tags":["算法"]},{"title":"过关考模拟考题解","url":"/ZestfulYK-blog/2025/10/23/过关考模拟考题解/","content":"# 过关考模拟考题解\n\n## A签到题\n\n- 分析:\n\n要是这也不会那学习委员真没招了\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    cout<<\"Help others voluntarily but never let them know they owe you a favor.\"<<endl;\n}\n```\n\n## B选择结构\n\n- 分析:\n\n按照要求逐个判断，然后取最小值就行了\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    double x,y,n,p,ans=200;\n    cin>>x>>y>>n>>p;\n    if(p>=x) ans=min(ans,p-y);\n    ans=min(ans,p/10*n);\n    printf(\"%.2lf\",ans);\n}\n```\n\n## C循环\n\n- 分析:\n\n分三种情况，<10的一定成立，两三四位数自己判断就行了\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,cnt=0; cin>>n;\n    for(int i=1;i<=n;i++){\n        if(i<10) cnt++;\n        else if(i<100){\n            if(i%10==i/10) cnt++;\n        }\n        else if(i<1000){\n            if(i%10==i/10%10&&i%10==i/100) cnt++;\n        }\n        else if(i%10==i/10%10&&i%10==i/100%10&&i%10==i/1000) cnt++;\n    }\n    cout<<cnt<<endl;\n}\n```\n- 打表的做法\n\n为什么没人想到这题能打表呢？总共也就28个数啊\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int a[30]={1,2,3,4,5,6,7,8,9,11,\n    22,33,44,55,66,77,88,99,111,\n    222,333,444,555,666,777,888,999,1111,2222},n;\n    cin>>n;\n    for(int i=0;i<=28;i++){\n        if(a[i]>n) {cout<<i<<endl;break;}\n    }\n}\n```\n\n## D菱形\n\n- 分析:\n\n逐行输出，先上半部分，再是后半部分\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n; cin>>n;\n    for(int i=0;i<=n/2;i++){\n        for(int j=1;j<=n/2-i;j++) cout<<\".\";\n        cout<<\"#\";\n        for(int j=1;j<=i*2-1;j++) cout<<\".\";\n        if(i!=0) cout<<\"#\";\n        for(int j=1;j<=n/2-i;j++) cout<<\".\";\n        cout<<endl;\n    }\n    for(int i=n/2-1;i>=0;i--){\n        for(int j=1;j<=n/2-i;j++) cout<<\".\";\n        cout<<\"#\";\n        for(int j=1;j<=i*2-1;j++) cout<<\".\";\n        if(i!=0) cout<<\"#\";\n        for(int j=1;j<=n/2-i;j++) cout<<\".\";\n        cout<<endl;\n    }\n}\n```\n\n\n## E金字塔\n\n- 分析:\n\n逐个循环相加就行了\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,ans=0; cin>>n;\n    for(int i=1;i<=n;i++) ans+=i*i;\n    cout<<ans<<endl;\n}\n```\n\n## F假期阅读\n\n- 分析:\n\n最多k*t页，但不能超过n\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,k,t; cin>>n>>k>>t;\n    cout<<min(n,k*t)<<endl;\n}\n```\n\n## G值日\n\n- 分析:\n\n求最小公倍数\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,m,i; cin>>n>>m;\n    for(i=n;i%m!=0;i+=n);\n    cout<<i<<endl;\n}\n```\n\n## H数三角形\n\n- 分析:\n\n循环i 1..n，j 1..i即可，每次判断一下是否存在整数解\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n,cnt=0; cin>>n;\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=i;j++){\n            if(i*j%2==0) cnt++;\n        }\n    }\n    cout<<cnt<<endl;\n}\n```\n\n## I幂数和\n\n- 分析:\n\n直接暴力枚举所有数，判断是否能拆就行了\n遍历每种可能的情况，计算和是否为这个数就行了\n至于代码中的<<是二进制内左移的意思，用来计算2的n次幂\n比如1<<1是10，变成了2，同理还有右移，自己学习\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int l,r,cnt=0; cin>>l>>r;\n    for(int i=l;i<=r;i++){\n        bool f=false;\n        for(int j=0;j<=20;j++){\n            for(int k=0;k<=20;k++){\n                if((1<<j)+(1<<k)==i) {cnt++;f=true;break;}\n            }\n            if(f) break;\n        }\n    }\n    cout<<cnt<<endl;\n}\n```\n\n\n## J质因数分解\n\n- 分析:\n\n第一空，先输出n，免得后面n的值变掉了\n第二空判断是否算一个因子，当然最后一个是需要特判的\n第三空，既然发现了因子，那么把n减小，变为n/i\n第四空，找的不对，i自增，寻找下一个位置\n第五空，输出最后一个质因数\n\n- 参考代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint main(){\n    ll n,i=2; cin>>n;\n    cout<<n<<\"=\";\n    for(i=2;i<=n;){\n        if(n%i==0&&n/i!=1){\n            cout<<i<<\"*\";\n            n/=i;\n        }\n        else{\n            i++;\n        }\n    }\n    cout<<i-1<<endl;\n}\n```","tags":["算法"]},{"title":"全排列函数的应用","url":"/ZestfulYK-blog/2025/10/22/全排列函数的应用/","content":"# 全排列函数\n\n## 什么是全排列？\n\n简单来说就是排列组合的所有情况，并按照字典顺序输出\n例如：123全排列的结果为\n\n```yaml\n123\n132\n213\n231\n312\n321\n```\n\n而实际上全排列需要在代码中用复杂的深度搜索来写\n这实在是太复杂了！！！\n于是我就发现了全排列函数这个东西^__^\n现在我们就来学习一下这个高级函数————next_permutation\n\n## 全排列函数\n\n```C++\n#include <iostream>  \n#include <algorithm>  \nusing namespace std;  \nint main()  \n{  \n    int num[3]={1,2,3};  \n    do  \n    {  \n        cout<<num[0]<<\" \"<<num[1]<<\" \"<<num[2]<<endl;\n    }while(next_permutation(num,num+3));  \n    return 0;  \n}\n```\n- 全排列函数详细定义\n对于next_permutation函数，其函数原型为：\n\n    #include <algorithm>\n\n    bool next_permutation(iterator start,iterator end)\n\n当当前序列不存在下一个排列时，函数返回false，否则返回true\n\n- 全排列函数的特性\n\nnext_permutation(num,num+n)函数是对数组num中的前n个元素进行全排列，同时并改变num数组的值。\n\n另外，需要强调的是，next_permutation()在使用前需要对欲排列数组按升序排序，否则只能找出该序列之后的全排列数。比如，如果数组num初始化为2,3,1，那么输出就变为了：\n```yaml\n231\n312\n321\n```\n\n# 全排列函数的应用\n\n[题目链接](https://atcoder.jp/contests/abc326/tasks/abc326_d?lang=en)\n\n题目要求我们按要求完成5*5数独，且只要填ABC，可以有空格子\n一种方法是遍历每一个格子，逐个填入，\n时间复杂度(4^25)，显然不行\n不过我的朋友使用了大量剪枝，最后还是过了\n%%%大佬 qinye_leaf\n\n[代码链接](https://atcoder.jp/contests/abc326/submissions/70334070)\n\n但是我们刚学了全排列函数，就不能使用一下吗？\n你别说，还真能使用！\n我们只要先填写每一行，然后就只用40^5就能计算完了\n因为可以加上一个判断，看看每一行是否符合标准(也算剪枝吧)\n\n```C++\n    vector<string> eachrow(int row) {\n        vector<string> result;\n        string h=string(n-3,'.')+\"ABC\";\n        do{ for(int i=0;i<n;i++){\n            if(h[i]!='.'){\n                if(h[i]==r[row]) result.push_back(h);\n                break;\n            }\n        }\n        }while(next_permutation(h.begin(),h.end()));\n        return result;\n    }\n```\n那么这样我们就能得到每一行的可能情况，每行40种\n之后就可以正常的DFS了\n\n[个人AC代码链接](https://atcoder.jp/contests/abc326/submissions/70340782)","tags":["算法"]},{"title":"广工月赛","url":"/ZestfulYK-blog/2025/10/20/广工月赛/","content":"# ZestfulYK的战绩\n![图片](/images/ggys.png)\n\n# 比赛难度\n中等，以基础题为主，拼尽全力战胜少量难题\n\n# 部分代码\n## F\n- 分析\n很不错的博弈题目，使我的大脑旋转，最后打表做出来了\n\n[题目链接](https://ac.nowcoder.com/acm/contest/119605/F)\n\n![代码](/images/image.png)\n\n代码:\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    if(n==0&&m==0) cout<<\"Bob\"<<endl;\n    else if(n==1&m==0) cout<<\"Alice\"<<endl;\n    else if(n==2&m==0) cout<<\"Bob\"<<endl;\n    else if(n==3&m==0) cout<<\"Bob\"<<endl;\n    else if(n==0&m==1) cout<<\"Alice\"<<endl;\n    else if(n==0&m==2) cout<<\"Bob\"<<endl;\n    else if(n==0&m==3) cout<<\"Alice\"<<endl;//\n    else if(n==1&m==1) cout<<\"Bob\"<<endl;\n    else if(n==1&m==2) cout<<\"Bob\"<<endl;\n    else if(n==1&m==3) cout<<\"Alice\"<<endl;//\n    else if(n==2&m==1) cout<<\"Bob\"<<endl;\n    else if(n==2&m==2) cout<<\"Bob\"<<endl;\n    else if(n==2&m==3) cout<<\"Alice\"<<endl;//\n    else if(n==3&m==1) cout<<\"Bob\"<<endl;\n    else if(n==3&m==2) cout<<\"Bob\"<<endl;\n    else if(n==3&m==3) cout<<\"Alice\"<<endl;\n}\n```\n\n## J\n- 分析\n这题目也不错，但其实看代码找规律就行了\n\n[题目链接](https://ac.nowcoder.com/acm/contest/119605/J)\n\n![代码](/images/J.png)\n\n代码:\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nint main(){\n    ll n; cin>>n;\n    ll s=sqrt(n);\n    if(s*s!=n) s++;\n    ll last=n%s;\n    for(int i=last;i>=1;i--) cout<<i<<\" \";\n    for(int j=1;j<=n/s;j++){\n        for(int i=last+j*s;i>last+(j-1)*s;i--) cout<<i<<\" \";\n    }\n}\n```","tags":["算法"]},{"title":"markdown使用教程","url":"/ZestfulYK-blog/2025/10/20/markdown使用教程/","content":"### 标题的使用\n```yaml\n# 一级标题\n## 二级标题\n### 三级标题\n```\n### 字体\n\n**粗体** *斜体* ~~删除线~~ `行内代码`\n\n### 小标题的使用\n\n- 无序列表项\n- 另一个项目\n\n1. 有序列表\n2. 第二项\n\n### 链接，图片\n\n```yaml\n[链接文字](https://example.com)\n![图片描述](https://example.com/image.jpg)\n```\n\n### 引用块\n\n```yaml\n> 这是一个引用块\n> 可以多行使用\n```\n> 这是一个引用块\n> 可以多行使用\n\n### 表格\n\n```yaml\n| 姓名 | 年龄 | 城市 |\n|------|------|------|\n| 张三 | 25   | 北京 |\n| 李四 | 30   | 上海 |\n```\n\n| 姓名 | 年龄 | 城市 |\n|------|------|------|\n| 张三 | 25   | 北京 |\n| 李四 | 30   | 上海 |","tags":["技术"]}]