[{"title":"算法挑战赛题解（11.2）","url":"/ZestfulYK-blog/2025/11/03/1/","content":"算法挑战赛题解（11.2）简单版本：题目大意：给定n个区间，判断这些区间能划分出几种不同的区域\n\n性质不同的数字\n\n题目分析：实际上是在讨论每个点被哪几个区包含，在样例中，数据是这样的，我们来分析一下这两个样例\nSample Input 1 11 6Sample Output 12Sample Input 240 124 136 1312 13Sample Output 26\n\n样例分析：样例1: 0 1 1 1 1 1 1 0 0 … …  所以是两种区间样例2: 1   2  3   4   5   6   7  8    9   10  11  12  13 … …       1   1  1   1   1   1   1  1   1    1   1   1                  2   2   2   2  2   2    2   2   2   2                          3   3  3   3    3   3   3   3                                                  4   4       |&lt; ------ &gt;|&lt; ---- &gt;|&lt; ----------------- &gt;|&lt;-&gt;|&lt;-&gt;|&lt;--\n\n所以是6种区间这样,我们就弄明白了题目在讲什么,接下来就可以思考怎么实现了\n题目思路：实际上有些人会以为我们需要统计的是这个点有几个区间经过，但是这是错误的，在样例二就能发现这一点。（这也是我第一次的想法，测试样例二时发现的T_T）\n我们需要思考怎么表示这一个点有哪些区间经过，而且每一个区间是互不相同的。这里我们考虑类似状态压缩的思想。\n什么是状态压缩呢？简而言之就是用一个数来代替这个状态。比如说，我们用1表示未进行，2表示正在进行，3表示完成，那么一个含有4个任务的任务表可以是这样的：\n            1321\n\n（1，4任务未进行，2任务完成，3正在进行）\n我们使用了一个4位数表示了这一状态，这样就实现了状态压缩，我们没有用数组存储状态，而是一个数，这样我们在判断两个状态是否相同时就可以直接判断数字是否相同了，节约了时间和判断的复杂度。\n那么怎么把这个思想用在这一题呢？我们考虑给每个区间一个标号k，每个区间内的点加上2^k，这样就保证了每一个状态不会重复。但是这么写居然WA了！这是因为数据范围n是[0,300]也就是会有2^300，远大于long long的最大范围(2^64-1)这显然是不行的。\n实际上这个算法已经十分接近答案了,但我们还需要改进这个算法。接着我们想到一个类似的方法，哈希表(hash)。\n其实哈希表和刚才的思路差不多，不过加入了一些更高级的算法来防止数据溢出。\n那么什么是hash呢？实际上也是创建一种对应关系，使得在查询时能快速访问这种情况对应的值。就像上面的例子一样，我们通过我们规定的方式把任务状态和整数一一对应。\n怎么创建hash表呢？首先，找到一个质数作为进制数P，通常取131或者13331，模数mod通常取1e9+7或1e9+9，对应关系就是对应的P进制数%mod例如这个点上经过了134这三个集合，那么我们就把134转化为131进制，即1 * 131^2+3 * 131+4，在实际操作时，就是每一个集合的下标k作为对应的位数，则每一个点的表示可以是这样的：\n\n这样我们就计算出了每一个点的唯一标识，含有相同标识的才能算是同一个点。（这里选择质数是为了防止哈希碰撞，即不同状态的得到了相同的标记；选择mod是防止溢出）\n最后只要统计一下标识的个数就行了（可以用set实现）代码实现：对于简单版本，暴力完全够用了。\n#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define endl &#x27;\\n&#x27;const ll P=131,mod=1e9+7;int main()&#123;    ll n,z=1,a[1010]; cin&gt;&gt;n;    for(int i=0;i&lt;=1000;i++) a[i]=0;    while(n--)&#123;        ll l,r; cin&gt;&gt;l&gt;&gt;r;        for(int i=l;i&lt;=r;i++)&#123;            a[i]=(a[i]+z)%mod;        &#125;        z=(z*P)%mod;    &#125;    set&lt;ll&gt; q;    for(int i=0;i&lt;=1000;i++)&#123;        q.insert(a[i]);    &#125;    cout&lt;&lt;q.size()&lt;&lt;endl;&#125;\n\n\n所以这样我们就解决了简单版本。\n复杂版本：那么对于数据量大的复杂版本呢？\n这里我们依然采用hash，但是由于数据量大，为了防止冲突，我们给每一个区间都分配一个随机hash值，在计算时只考虑起点和终点，在进入起点时加入标记，离开时移除标记。这时我们就想到了具有可逆性质的异或，我们只要给对应的起终点打上相同标记就行了，最后还是用set统计产生的不同标记数\n参考代码：#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define ULL unsigned long long#define endl &#x27;\\n&#x27;int main()&#123;    ll n; cin&gt;&gt;n;    vector&lt;pair&lt;ll,int&gt;&gt; box;    for (int i=0;i&lt;n;i++)&#123;        ll l,r; cin&gt;&gt;l&gt;&gt;r;        box.push_back(&#123;l,i&#125;);        box.push_back(&#123;r+1,i&#125;);    &#125;    sort(box.begin(),box.end());    vector&lt;unsigned long long&gt; h(n);    mt19937_64 rng(time(0));    for(int i=0;i&lt;n;i++)&#123;        h[i]=rng();    &#125;    set&lt;ULL&gt; s; s.insert(0);    ULL cur=0;ll last=-2e9;    for(auto&amp; i:box)&#123;        ll pos=i.first,idx=i.second;        if(pos&gt;last&amp;&amp;last!=-2e9) s.insert(cur);        cur^=h[idx];        last=pos;    &#125;    s.insert(cur);    cout&lt;&lt;s.size()&lt;&lt;endl;&#125;\n\n                     感谢观看！关注ZestfulYK喵，谢谢喵！\n\n","tags":["算法"]},{"title":"markdown使用教程","url":"/ZestfulYK-blog/2025/10/20/markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","content":"标题的使用# 一级标题## 二级标题### 三级标题\n字体粗体 斜体 删除线 行内代码\n小标题的使用\n无序列表项\n另一个项目\n\n\n有序列表\n第二项\n\n链接，图片[链接文字](https://example.com)![图片描述](https://example.com/image.jpg)\n\n引用块&gt; 这是一个引用块&gt; 可以多行使用\n\n这是一个引用块可以多行使用\n\n表格| 姓名 | 年龄 | 城市 ||------|------|------|| 张三 | 25   | 北京 || 李四 | 30   | 上海 |\n\n\n\n\n姓名\n年龄\n城市\n\n\n\n张三\n25\n北京\n\n\n李四\n30\n上海\n\n\n","tags":["技术"]},{"title":"全排列函数的应用","url":"/ZestfulYK-blog/2025/10/22/%E5%85%A8%E6%8E%92%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8/","content":"全排列函数什么是全排列？简单来说就是排列组合的所有情况，并按照字典顺序输出例如：123全排列的结果为\n123132213231312321\n\n而实际上全排列需要在代码中用复杂的深度搜索来写这实在是太复杂了！！！于是我就发现了全排列函数这个东西^__^现在我们就来学习一下这个高级函数————next_permutation\n全排列函数#include &lt;iostream&gt;  #include &lt;algorithm&gt;  using namespace std;  int main()  &#123;      int num[3]=&#123;1,2,3&#125;;      do      &#123;          cout&lt;&lt;num[0]&lt;&lt;&quot; &quot;&lt;&lt;num[1]&lt;&lt;&quot; &quot;&lt;&lt;num[2]&lt;&lt;endl;    &#125;while(next_permutation(num,num+3));      return 0;  &#125;\n\n全排列函数详细定义对于next_permutation函数，其函数原型为：\n  #include \n  bool next_permutation(iterator start,iterator end)\n\n\n当当前序列不存在下一个排列时，函数返回false，否则返回true\n\n全排列函数的特性\n\nnext_permutation(num,num+n)函数是对数组num中的前n个元素进行全排列，同时并改变num数组的值。\n另外，需要强调的是，next_permutation()在使用前需要对欲排列数组按升序排序，否则只能找出该序列之后的全排列数。比如，如果数组num初始化为2,3,1，那么输出就变为了：\n231312321\n\n全排列函数的应用题目链接\n题目要求我们按要求完成5*5数独，且只要填ABC，可以有空格子一种方法是遍历每一个格子，逐个填入，时间复杂度(4^25)，显然不行不过我的朋友使用了大量剪枝，最后还是过了%%%大佬 qinye_leaf\n代码链接\n但是我们刚学了全排列函数，就不能使用一下吗？你别说，还真能使用！我们只要先填写每一行，然后就只用40^5就能计算完了因为可以加上一个判断，看看每一行是否符合标准(也算剪枝吧)\nvector&lt;string&gt; eachrow(int row) &#123;    vector&lt;string&gt; result;    string h=string(n-3,&#x27;.&#x27;)+&quot;ABC&quot;;    do&#123; for(int i=0;i&lt;n;i++)&#123;        if(h[i]!=&#x27;.&#x27;)&#123;            if(h[i]==r[row]) result.push_back(h);            break;        &#125;    &#125;    &#125;while(next_permutation(h.begin(),h.end()));    return result;&#125;\n那么这样我们就能得到每一行的可能情况，每行40种之后就可以正常的DFS了\n个人AC代码链接\n","tags":["算法"]},{"title":"算法挑战赛题解","url":"/ZestfulYK-blog/2025/11/20/2/","content":"算法挑战赛第二期题解题目\n二进制小数的乘积~HC哥哥说这个很困！难！\n\nDescription\n\n\n\nHC哥哥今天又突发奇想，它依然定义一个数字为二进制小数，如果它是一个正整数，并且其十进制表示中的所有数字都是0或1。例如，110 是一个二进制小数，而 102 和 787 不是。\n\n\n现在HC哥哥给定你一个数 n，你被要求判断是否可能将 n 表示为一些（不一定是不同的）二进制小数的乘积。\n\n\nInput\n\n\n第一行包含一个整数 t（1≤t≤5⋅10^4）— 测试用例的数量。\n\n\n每个测试用例的唯一一行包含一个整数 n（1≤n≤10^5）。\n\n\nOutput\n\n\n对于每个测试用例，如果 n 可以表示为一些二进制小数的乘积，则输出 “YES”（不带引号），否则输出 “NO”（不带引号）。\n\n\n题目解释 （翻译成人话）\n\n计算把01串强制转换为整数，再相乘得到的数就是合法的数字，其余都是不合法的。那么直接打表就行了，总共1e5个数，打表还是很容易实现的\n接下来我们来学习一下该怎么打表\n打表\n定义 : 计算出所有情况，然后直接判断。\n\n比如问你100以内的数是否是质数，你肯定能直接回答，因为你已经把100以内的质数全部背下来了。这其实就是打表的一种体现，你提前计算前100内的数是否是质数，然后直接调用答案。\n但是我们的计算机实际上并不知道一个问题的所有解，那么你自己提前算好告诉它不就彳亍了吗。\n这时我们需要两个重要程序：打表程序和判断程序。\n打表程序\n用于计算所有情况的答案，不用关心时间复杂度，反正是提前计算\n\n比如计算素数集，你直接暴力就好了，不会欧拉筛又有什么关系呢？\n判断程序\n用于直接获得答案的程序，时间复杂度O(n),n为数据规模，每次查询的时间复杂度为O(1)。\n\n接下来就该思考怎么写一个无脑的程序来计算这些情况了\n做法\n首先先写一个无脑程序生成所有01组合的数\n\nvector&lt;ll&gt; ans;int main()&#123;    for(int i=1;i&lt;=100000;i++)&#123;        ll x=i,cnt=0,w=0;        while(x)&#123;            if(x%10&lt;2) cnt++;            w++;            x/=10;        &#125;        if(cnt==w) ans.push_back(i);    &#125;    for(auto &amp;i:ans)        cout&lt;&lt;i&lt;&lt;&quot;,&quot;;&#125;\n\n\n此处是对每一位进行判断，如果01的个数和位数一样，那么就是一个合法的数字\n\n\n得到如下结果：\n\n1,10,11,100,101,110,111,1000,1001,1010,1011,1100,1101,1110,1111,10000,10001,10010,10011,10100,10101,10110,10111,11000,11001,11010,11011,11100,11101,11110,11111,100000\n\n\n把以上结果复制进下一段生成代码，然后再计算所有合法的数字\n\nll number[1010]=&#123;0,1,10,11,100,101,110,111,1000,1001,    1010,1011,1100,1101,1110,1111,10000,10001    ,10010,10011,10100,10101,10110,10111,11000    ,11001,11010,11011,11100,11101,11110,11111,100000&#125;;set&lt;ll&gt; s;ll dfs(ll n)&#123;    s.insert(n);    for(int i=2;i&lt;=32;i++)&#123;        if(n*number[i]&lt;=100000)           dfs(n*number[i]);    &#125;    return 0;&#125;signed main()&#123;    dfs(1);    ll cnt=0;    for(auto &amp;i:s)&#123;        cout&lt;&lt;i&lt;&lt;&quot;,&quot;;        cnt++;    &#125;    cout&lt;&lt;endl&lt;&lt;cnt&lt;&lt;endl;    return 0;&#125;\n\n\n此处使用了dfs(Deep First Search)，文末会有详细介绍\n\n\n得到如下结果：\n\n1,10,11,100,101,110,111,121,1000,1001,1010,1011,1100,1101,1110,1111,1210,1221,1331,10000,10001,10010,10011,10100,10101,10110,10111,10201,11000,11001,11010,11011,11100,11101,11110,11111,11121,11211,12100,12111,12210,12221,12321,13310,13431,14641,100000\n\n\n最后再是无脑的判断程序：\n\nvector&lt;string&gt; ans;ll a[1010]=&#123;0,1,10,11,100,101,110,111,121,1000,1001,1010,1011,1100,1101,    1110,1111,1210,1221,1331,10000,10001,10010,10011,10100,10101,10110,    10111,10201,11000,11001,11010,11011,11100,11101,11110,11111,11121,    11211,12100,12111,12210,12221,12321,13310,13431,14641,100000&#125;;void solve()&#123;    ll x; cin&gt;&gt;x;    for(int i=1;i&lt;=47;i++)&#123;        if(a[i]==x)&#123;            ans.push_back(&quot;YES&quot;);            return;        &#125;    &#125;    ans.push_back(&quot;NO&quot;);&#125;int main()&#123;    ll T; cin&gt;&gt;T;    while(T--) solve();    for(auto &amp;i:ans)        cout&lt;&lt;i&lt;&lt;endl;&#125;\n\n不是我说，这种做法在打表题目是真轮椅吧，时间复杂度完全没影响，计算出来总共就47个数字，简单版甚至20个都没到，非常适合不会搜索的蒻蒟(比如我)学习和理解。\n下面是对dfs(Deep First Search)算法的详细介绍：\n什么是dfs？dfs是深度优先搜索的英文缩写，以深度为优先来进行计算\n\n比如，要计算走n级楼梯（每次一到两级台阶）有几种走法，就可以使用dfs，假设第一次先走一步，依次遍历，如果能刚好走到n则方法数加1，如果超过了n则返回到上一步，回头找下一个方法。\n\n在本题的应用\n\n那么在这题，我们已经提前计算了所有合法的数字，我们每次乘上可能的数字，看看是否依旧合法，之后在超过1e5时返回，相当于楼梯数为1e5，每次可以走number[1….n]步，但是每一个小于n的位置都合法，并存储答案。\n如果想进一步了解dfs，可以访问OIwiki进行学习！\n那么本期的题解就到此结束了，感谢阅读！如果想交流算法题，也可以添加我的qq哦(717056060)\n关注ZestfulYK，谢谢喵！"},{"title":"过关考模拟考题解","url":"/ZestfulYK-blog/2025/10/23/%E8%BF%87%E5%85%B3%E8%80%83%E6%A8%A1%E6%8B%9F%E8%80%83%E9%A2%98%E8%A7%A3/","content":"过关考模拟考题解A签到题\n分析:\n\n要是这也不会那学习委员真没招了\n\n参考代码:\n\n#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    cout&lt;&lt;&quot;Help others voluntarily but never let them know they owe you a favor.&quot;&lt;&lt;endl;&#125;\n\nB选择结构\n分析:\n\n按照要求逐个判断，然后取最小值就行了\n\n参考代码:\n\n#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    double x,y,n,p,ans=200;    cin&gt;&gt;x&gt;&gt;y&gt;&gt;n&gt;&gt;p;    if(p&gt;=x) ans=min(ans,p-y);    ans=min(ans,p/10*n);    printf(&quot;%.2lf&quot;,ans);&#125;\n\nC循环\n分析:\n\n分三种情况，&lt;10的一定成立，两三四位数自己判断就行了\n\n参考代码:\n\n#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n,cnt=0; cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        if(i&lt;10) cnt++;        else if(i&lt;100)&#123;            if(i%10==i/10) cnt++;        &#125;        else if(i&lt;1000)&#123;            if(i%10==i/10%10&amp;&amp;i%10==i/100) cnt++;        &#125;        else if(i%10==i/10%10&amp;&amp;i%10==i/100%10&amp;&amp;i%10==i/1000) cnt++;    &#125;    cout&lt;&lt;cnt&lt;&lt;endl;&#125;\n\n打表的做法\n\n为什么没人想到这题能打表呢？总共也就28个数啊\n#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int a[30]=&#123;1,2,3,4,5,6,7,8,9,11,    22,33,44,55,66,77,88,99,111,    222,333,444,555,666,777,888,999,1111,2222&#125;,n;    cin&gt;&gt;n;    for(int i=0;i&lt;=28;i++)&#123;        if(a[i]&gt;n) &#123;cout&lt;&lt;i&lt;&lt;endl;break;&#125;    &#125;&#125;\n\nD菱形\n分析:\n\n逐行输出，先上半部分，再是后半部分\n\n参考代码:\n\n#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n; cin&gt;&gt;n;    for(int i=0;i&lt;=n/2;i++)&#123;        for(int j=1;j&lt;=n/2-i;j++) cout&lt;&lt;&quot;.&quot;;        cout&lt;&lt;&quot;#&quot;;        for(int j=1;j&lt;=i*2-1;j++) cout&lt;&lt;&quot;.&quot;;        if(i!=0) cout&lt;&lt;&quot;#&quot;;        for(int j=1;j&lt;=n/2-i;j++) cout&lt;&lt;&quot;.&quot;;        cout&lt;&lt;endl;    &#125;    for(int i=n/2-1;i&gt;=0;i--)&#123;        for(int j=1;j&lt;=n/2-i;j++) cout&lt;&lt;&quot;.&quot;;        cout&lt;&lt;&quot;#&quot;;        for(int j=1;j&lt;=i*2-1;j++) cout&lt;&lt;&quot;.&quot;;        if(i!=0) cout&lt;&lt;&quot;#&quot;;        for(int j=1;j&lt;=n/2-i;j++) cout&lt;&lt;&quot;.&quot;;        cout&lt;&lt;endl;    &#125;&#125;\n\n\nE金字塔\n分析:\n\n逐个循环相加就行了\n\n参考代码:\n\n#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n,ans=0; cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++) ans+=i*i;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n\nF假期阅读\n分析:\n\n最多k*t页，但不能超过n\n\n参考代码:\n\n#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n,k,t; cin&gt;&gt;n&gt;&gt;k&gt;&gt;t;    cout&lt;&lt;min(n,k*t)&lt;&lt;endl;&#125;\n\nG值日\n分析:\n\n求最小公倍数\n\n参考代码:\n\n#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n,m,i; cin&gt;&gt;n&gt;&gt;m;    for(i=n;i%m!=0;i+=n);    cout&lt;&lt;i&lt;&lt;endl;&#125;\n\nH数三角形\n分析:\n\n循环i 1..n，j 1..i即可，每次判断一下是否存在整数解\n\n参考代码:\n\n#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n,cnt=0; cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=i;j++)&#123;            if(i*j%2==0) cnt++;        &#125;    &#125;    cout&lt;&lt;cnt&lt;&lt;endl;&#125;\n\nI幂数和\n分析:\n\n直接暴力枚举所有数，判断是否能拆就行了遍历每种可能的情况，计算和是否为这个数就行了至于代码中的&lt;&lt;是二进制内左移的意思，用来计算2的n次幂比如1&lt;&lt;1是10，变成了2，同理还有右移，自己学习\n\n参考代码:\n\n#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int l,r,cnt=0; cin&gt;&gt;l&gt;&gt;r;    for(int i=l;i&lt;=r;i++)&#123;        bool f=false;        for(int j=0;j&lt;=20;j++)&#123;            for(int k=0;k&lt;=20;k++)&#123;                if((1&lt;&lt;j)+(1&lt;&lt;k)==i) &#123;cnt++;f=true;break;&#125;            &#125;            if(f) break;        &#125;    &#125;    cout&lt;&lt;cnt&lt;&lt;endl;&#125;\n\n\nJ质因数分解\n分析:\n\n第一空，先输出n，免得后面n的值变掉了第二空判断是否算一个因子，当然最后一个是需要特判的第三空，既然发现了因子，那么把n减小，变为n&#x2F;i第四空，找的不对，i自增，寻找下一个位置第五空，输出最后一个质因数\n\n参考代码:\n\n#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123;    ll n,i=2; cin&gt;&gt;n;    cout&lt;&lt;n&lt;&lt;&quot;=&quot;;    for(i=2;i&lt;=n;)&#123;        if(n%i==0&amp;&amp;n/i!=1)&#123;            cout&lt;&lt;i&lt;&lt;&quot;*&quot;;            n/=i;        &#125;        else&#123;            i++;        &#125;    &#125;    cout&lt;&lt;i-1&lt;&lt;endl;&#125;","tags":["算法"]},{"title":"广工月赛","url":"/ZestfulYK-blog/2025/10/20/%E5%B9%BF%E5%B7%A5%E6%9C%88%E8%B5%9B/","content":"ZestfulYK的战绩\n比赛难度中等，以基础题为主，拼尽全力战胜少量难题\n部分代码F\n分析很不错的博弈题目，使我的大脑旋转，最后打表做出来了\n\n题目链接\n\n代码:\n#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123;    ll n,m;    cin&gt;&gt;n&gt;&gt;m;    if(n==0&amp;&amp;m==0) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==1&amp;m==0) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl;    else if(n==2&amp;m==0) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==3&amp;m==0) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==0&amp;m==1) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl;    else if(n==0&amp;m==2) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==0&amp;m==3) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl;//    else if(n==1&amp;m==1) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==1&amp;m==2) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==1&amp;m==3) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl;//    else if(n==2&amp;m==1) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==2&amp;m==2) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==2&amp;m==3) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl;//    else if(n==3&amp;m==1) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==3&amp;m==2) cout&lt;&lt;&quot;Bob&quot;&lt;&lt;endl;    else if(n==3&amp;m==3) cout&lt;&lt;&quot;Alice&quot;&lt;&lt;endl;&#125;\n\nJ\n分析这题目也不错，但其实看代码找规律就行了\n\n题目链接\n\n代码:\n#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longint main()&#123;    ll n; cin&gt;&gt;n;    ll s=sqrt(n);    if(s*s!=n) s++;    ll last=n%s;    for(int i=last;i&gt;=1;i--) cout&lt;&lt;i&lt;&lt;&quot; &quot;;    for(int j=1;j&lt;=n/s;j++)&#123;        for(int i=last+j*s;i&gt;last+(j-1)*s;i--) cout&lt;&lt;i&lt;&lt;&quot; &quot;;    &#125;&#125;","tags":["算法"]},{"title":"压行技巧","url":"/ZestfulYK-blog/2025/10/24/%E5%8E%8B%E8%A1%8C%E6%8A%80%E5%B7%A7/","content":"如何给你的代码压行？如果不会压行，你的代码看起来会是这样的：\nint ml(vector&lt;int&gt; s, int n)&#123;    int m = s[0];    for (int i = 0; i &lt;= n; i++)    &#123;        if (s[i] &gt; m)            m = s[i];    &#125;    return m;&#125;\n\n整整用了9行！实际上其实根本不需用那么多行：\nint ml(vector&lt;int&gt; s,int n)&#123;    int m=s[0];    for(int i=0;i&lt;=n;i++)&#123;        if(s[i]&gt;m)m=s[i];    &#125;    return m;&#125;\n\n当然也可以更短：\nint ml(vector&lt;int&gt; s,int n)&#123;    int m=s[0];    for(int i=0;i&lt;=n;i++) if(s[i]&gt;m) m=s[i];    return m;&#125;\n那么问题来了，怎么在不影响代码运行的情况下合理的压行呢？\n判断类循环类的压行技巧判断类如果判断语句仅一行，可以考虑压行：\nif(a==1) sum++;else sum--;//或者这样if(a==1)    sum++;//可以通过缩进来方便区分\n\n两句的话，压行可以考虑用大括号包起来压行前提是你觉得看着没影响\nif(a==1) &#123;sum++;a=2;&#125;\n\n注意在大括号里的每一句都是要加上封号的，因为这一段代码实际上等价于：\nif(a==1)&#123;    sum++;    a=2;&#125;\n\n循环类压行也和判断的一样，可以这么压行：\nfor(int i=1;i&lt;=n;i++) cout&lt;&lt;1&lt;&lt;endl;//或者这样：for(int i=1;i&lt;=n;i++)    cout&lt;&lt;1&lt;&lt;endl;\n\n如果是输出的话，其实可以这么写：\nfor(int i=1;i&lt;=n;i++) cout&lt;&lt;i&lt;&lt;&quot; &quot;; cout&lt;&lt;endl;\n\n因为C++cout&lt;&lt;endl;其实是在循环之外的，所以这么写是正确的\n头文件压行下面送给大家万能头文件：\n#include&lt;bits/stdc++.h&gt;\n\n其他技巧#define ll long long#define rep(1,n) for(int i=1;i&lt;=(n);i++)ll n;int main()&#123;    rep(1,n) cout&lt;&lt;&quot;*&quot;; cout&lt;&lt;endl;&#125;\n\n通过define来减少代码长度，增加可读性\n一些非常有用的C++自带函数sort(a,a+n);//a为数组，n为a的大小__gcd(x,y);//x，y的最大公约数x=1&lt;&lt;n;//2的n次方\n","tags":["算法"]}]